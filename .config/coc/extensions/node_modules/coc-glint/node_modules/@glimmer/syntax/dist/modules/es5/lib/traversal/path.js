function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

import RootTransformScope from './scope';

var WalkerPath = /*#__PURE__*/function () {
  function WalkerPath(node, parent, parentKey) {
    var _this = this;

    if (parent === void 0) {
      parent = null;
    }

    if (parentKey === void 0) {
      parentKey = null;
    }

    this.node = node;
    this.parent = parent;
    this.parentKey = parentKey;
    this.scope = parent ? parent.scope.child(node) : new RootTransformScope(node); // Consume in scope values

    if (node.type === 'PathExpression') {
      this.scope.useLocal(node);
    }

    if (node.type === 'ElementNode') {
      this.scope.useLocal(node);
      node.children.forEach(function (node) {
        return _this.scope.useLocal(node);
      });
    }
  }

  var _proto = WalkerPath.prototype;

  _proto.parents = function parents() {
    var _this2 = this,
        _ref;

    return _ref = {}, _ref[Symbol.iterator] = function () {
      return new PathParentsIterator(_this2);
    }, _ref;
  };

  _createClass(WalkerPath, [{
    key: "parentNode",
    get: function get() {
      return this.parent ? this.parent.node : null;
    }
  }]);

  return WalkerPath;
}();

export { WalkerPath as default };

var PathParentsIterator = /*#__PURE__*/function () {
  function PathParentsIterator(path) {
    this.path = path;
  }

  var _proto2 = PathParentsIterator.prototype;

  _proto2.next = function next() {
    if (this.path.parent) {
      this.path = this.path.parent;
      return {
        done: false,
        value: this.path
      };
    } else {
      return {
        done: true,
        value: null
      };
    }
  };

  return PathParentsIterator;
}();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdHJhdmVyc2FsL3BhdGgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUNBLE9BQUEsa0JBQUEsTUFBQSxTQUFBOztJQUVjLFU7QUFNWixzQkFBQSxJQUFBLEVBRUUsTUFGRixFQUdFLFNBSEYsRUFHaUM7QUFBQTs7QUFBQSxRQUQvQixNQUMrQjtBQUQvQixNQUFBLE1BQytCLEdBSGpDLElBR2lDO0FBQUE7O0FBQUEsUUFBL0IsU0FBK0I7QUFBL0IsTUFBQSxTQUErQixHQUhqQyxJQUdpQztBQUFBOztBQUUvQixTQUFBLElBQUEsR0FBQSxJQUFBO0FBQ0EsU0FBQSxNQUFBLEdBQUEsTUFBQTtBQUNBLFNBQUEsU0FBQSxHQUFBLFNBQUE7QUFDQSxTQUFBLEtBQUEsR0FBYSxNQUFNLEdBQUcsTUFBTSxDQUFOLEtBQUEsQ0FBQSxLQUFBLENBQUgsSUFBRyxDQUFILEdBQThCLElBQUEsa0JBQUEsQ0FMbEIsSUFLa0IsQ0FBakQsQ0FMK0IsQ0FPL0I7O0FBQ0EsUUFBSSxJQUFJLENBQUosSUFBQSxLQUFKLGdCQUFBLEVBQW9DO0FBQ2xDLFdBQUEsS0FBQSxDQUFBLFFBQUEsQ0FBQSxJQUFBO0FBQ0Q7O0FBRUQsUUFBSSxJQUFJLENBQUosSUFBQSxLQUFKLGFBQUEsRUFBaUM7QUFDL0IsV0FBQSxLQUFBLENBQUEsUUFBQSxDQUFBLElBQUE7QUFFQyxNQUFBLElBQTBCLENBQTFCLFFBQUEsQ0FBQSxPQUFBLENBQTZDLFVBQUEsSUFBRDtBQUFBLGVBQzNDLEtBQUEsQ0FBQSxLQUFBLENBQUEsUUFBQSxDQURELElBQ0MsQ0FEMkM7QUFBQSxPQUE1QztBQUdGO0FBQ0Y7Ozs7U0FNRCxPLEdBQUEsbUJBQU87QUFBQTtBQUFBOztBQUNMLDJCQUNHLE1BQU0sQ0FBUCxRQURGLElBQ3FCLFlBQUs7QUFDdEIsYUFBTyxJQUFBLG1CQUFBLENBQVAsTUFBTyxDQUFQO0FBQ0QsS0FISDtBQUtELEc7Ozs7d0JBVmE7QUFDWixhQUFPLEtBQUEsTUFBQSxHQUFjLEtBQUEsTUFBQSxDQUFkLElBQUEsR0FBUCxJQUFBO0FBQ0Q7Ozs7OztTQWhDVyxVOztJQTJDZCxtQjtBQUdFLCtCQUFBLElBQUEsRUFBd0M7QUFDdEMsU0FBQSxJQUFBLEdBQUEsSUFBQTtBQUNEOzs7O1VBRUQsSSxHQUFBLGdCQUFJO0FBQ0YsUUFBSSxLQUFBLElBQUEsQ0FBSixNQUFBLEVBQXNCO0FBQ3BCLFdBQUEsSUFBQSxHQUFZLEtBQUEsSUFBQSxDQUFaLE1BQUE7QUFDQSxhQUFPO0FBQUUsUUFBQSxJQUFJLEVBQU4sS0FBQTtBQUFlLFFBQUEsS0FBSyxFQUFFLEtBQUs7QUFBM0IsT0FBUDtBQUZGLEtBQUEsTUFHTztBQUNMLGFBQU87QUFBRSxRQUFBLElBQUksRUFBTixJQUFBO0FBQWMsUUFBQSxLQUFLLEVBQUU7QUFBckIsT0FBUDtBQUNEO0FBQ0YsRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFTVHYxIGZyb20gJy4uL3YxL2FwaSc7XG5pbXBvcnQgUm9vdFRyYW5zZm9ybVNjb3BlLCB7IFRyYW5zZm9ybVNjb3BlIH0gZnJvbSAnLi9zY29wZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdhbGtlclBhdGg8TiBleHRlbmRzIEFTVHYxLk5vZGU+IHtcbiAgbm9kZTogTjtcbiAgcGFyZW50OiBXYWxrZXJQYXRoPEFTVHYxLk5vZGU+IHwgbnVsbDtcbiAgcGFyZW50S2V5OiBzdHJpbmcgfCBudWxsO1xuICBzY29wZTogVHJhbnNmb3JtU2NvcGU7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgbm9kZTogTixcbiAgICBwYXJlbnQ6IFdhbGtlclBhdGg8QVNUdjEuTm9kZT4gfCBudWxsID0gbnVsbCxcbiAgICBwYXJlbnRLZXk6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICkge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5wYXJlbnRLZXkgPSBwYXJlbnRLZXk7XG4gICAgdGhpcy5zY29wZSA9IHBhcmVudCA/IHBhcmVudC5zY29wZS5jaGlsZChub2RlKSA6IG5ldyBSb290VHJhbnNmb3JtU2NvcGUobm9kZSk7XG5cbiAgICAvLyBDb25zdW1lIGluIHNjb3BlIHZhbHVlc1xuICAgIGlmIChub2RlLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICAgIHRoaXMuc2NvcGUudXNlTG9jYWwobm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0VsZW1lbnROb2RlJykge1xuICAgICAgdGhpcy5zY29wZS51c2VMb2NhbChub2RlKTtcblxuICAgICAgKG5vZGUgYXMgQVNUdjEuRWxlbWVudE5vZGUpLmNoaWxkcmVuLmZvckVhY2goKG5vZGU6IEFTVHYxLlN0YXRlbWVudCkgPT5cbiAgICAgICAgdGhpcy5zY29wZS51c2VMb2NhbChub2RlKVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBnZXQgcGFyZW50Tm9kZSgpOiBBU1R2MS5Ob2RlIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQubm9kZSA6IG51bGw7XG4gIH1cblxuICBwYXJlbnRzKCk6IEl0ZXJhYmxlPFdhbGtlclBhdGg8QVNUdjEuTm9kZT4gfCBudWxsPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aFBhcmVudHNJdGVyYXRvcih0aGlzKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuXG5jbGFzcyBQYXRoUGFyZW50c0l0ZXJhdG9yIGltcGxlbWVudHMgSXRlcmF0b3I8V2Fsa2VyUGF0aDxBU1R2MS5Ob2RlPiB8IG51bGw+IHtcbiAgcGF0aDogV2Fsa2VyUGF0aDxBU1R2MS5Ob2RlPjtcblxuICBjb25zdHJ1Y3RvcihwYXRoOiBXYWxrZXJQYXRoPEFTVHYxLk5vZGU+KSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuXG4gIG5leHQoKSB7XG4gICAgaWYgKHRoaXMucGF0aC5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGF0aCA9IHRoaXMucGF0aC5wYXJlbnQ7XG4gICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHRoaXMucGF0aCB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbnVsbCB9O1xuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==