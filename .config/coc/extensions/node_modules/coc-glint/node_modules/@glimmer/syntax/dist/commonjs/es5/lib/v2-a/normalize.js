"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalize = normalize;
exports.BlockContext = void 0;

var _util = require("@glimmer/util");

var _printer = _interopRequireDefault(require("../generation/printer"));

var _tokenizerEventHandlers = require("../parser/tokenizer-event-handlers");

var _slice = require("../source/slice");

var _spanList = require("../source/span-list");

var _symbolTable = require("../symbol-table");

var _syntaxError = require("../syntax-error");

var _parserBuilders = _interopRequireDefault(require("../v1/parser-builders"));

var ASTv2 = _interopRequireWildcard(require("./api"));

var _builders = require("./builders");

var _looseResolution = require("./loose-resolution");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  it = o[Symbol.iterator]();
  return it.next.bind(it);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function normalize(source, options) {
  if (options === void 0) {
    options = {};
  }

  var ast = (0, _tokenizerEventHandlers.preprocess)(source, options);
  var normalizeOptions = (0, _util.assign)({
    strictMode: false,
    locals: []
  }, options);

  var top = _symbolTable.SymbolTable.top(normalizeOptions.strictMode ? normalizeOptions.locals : []);

  var block = new BlockContext(source, normalizeOptions, top);
  var normalizer = new StatementNormalizer(block);
  return new TemplateChildren(block.loc(ast.loc), ast.body.map(function (b) {
    return normalizer.normalize(b);
  }), block).assertTemplate(top);
}
/**
 * A `BlockContext` represents the block that a particular AST node is contained inside of.
 *
 * `BlockContext` is aware of template-wide options (such as strict mode), as well as the bindings
 * that are in-scope within that block.
 *
 * Concretely, it has the `PrecompileOptions` and current `SymbolTable`, and provides
 * facilities for working with those options.
 *
 * `BlockContext` is stateless.
 */


var BlockContext = /*#__PURE__*/function () {
  function BlockContext(source, options, table) {
    this.source = source;
    this.options = options;
    this.table = table;
    this.builder = new _builders.Builder();
  }

  var _proto = BlockContext.prototype;

  _proto.loc = function loc(_loc) {
    return this.source.spanFor(_loc);
  };

  _proto.resolutionFor = function resolutionFor(node, resolution) {
    if (this.strict) {
      return {
        resolution: ASTv2.STRICT_RESOLUTION
      };
    }

    if (this.isFreeVar(node)) {
      var r = resolution(node);

      if (r === null) {
        return {
          resolution: 'error',
          path: printPath(node),
          head: printHead(node)
        };
      }

      return {
        resolution: r
      };
    } else {
      return {
        resolution: ASTv2.STRICT_RESOLUTION
      };
    }
  };

  _proto.isFreeVar = function isFreeVar(callee) {
    if (callee.type === 'PathExpression') {
      if (callee.head.type !== 'VarHead') {
        return false;
      }

      return !this.table.has(callee.head.name);
    } else if (callee.path.type === 'PathExpression') {
      return this.isFreeVar(callee.path);
    } else {
      return false;
    }
  };

  _proto.hasBinding = function hasBinding(name) {
    return this.table.has(name);
  };

  _proto.child = function child(blockParams) {
    return new BlockContext(this.source, this.options, this.table.child(blockParams));
  };

  _proto.customizeComponentName = function customizeComponentName(input) {
    if (this.options.customizeComponentName) {
      return this.options.customizeComponentName(input);
    } else {
      return input;
    }
  };

  _createClass(BlockContext, [{
    key: "strict",
    get: function get() {
      return this.options.strictMode || false;
    }
  }]);

  return BlockContext;
}();
/**
 * An `ExpressionNormalizer` normalizes expressions within a block.
 *
 * `ExpressionNormalizer` is stateless.
 */


exports.BlockContext = BlockContext;

var ExpressionNormalizer = /*#__PURE__*/function () {
  function ExpressionNormalizer(block) {
    this.block = block;
  }

  var _proto2 = ExpressionNormalizer.prototype;

  _proto2.normalize = function normalize(expr, resolution) {
    switch (expr.type) {
      case 'NullLiteral':
      case 'BooleanLiteral':
      case 'NumberLiteral':
      case 'StringLiteral':
      case 'UndefinedLiteral':
        return this.block.builder.literal(expr.value, this.block.loc(expr.loc));

      case 'PathExpression':
        return this.path(expr, resolution);

      case 'SubExpression':
        {
          var _resolution = this.block.resolutionFor(expr, _looseResolution.SexpSyntaxContext);

          if (_resolution.resolution === 'error') {
            throw (0, _syntaxError.generateSyntaxError)("You attempted to invoke a path (`" + _resolution.path + "`) but " + _resolution.head + " was not in scope", expr.loc);
          }

          return this.block.builder.sexp(this.callParts(expr, _resolution.resolution), this.block.loc(expr.loc));
        }
    }
  };

  _proto2.path = function path(expr, resolution) {
    var headOffsets = this.block.loc(expr.head.loc);
    var tail = []; // start with the head

    var offset = headOffsets;

    for (var _iterator = _createForOfIteratorHelperLoose(expr.tail), _step; !(_step = _iterator()).done;) {
      var part = _step.value;
      offset = offset.sliceStartChars({
        chars: part.length,
        skipStart: 1
      });
      tail.push(new _slice.SourceSlice({
        loc: offset,
        chars: part
      }));
    }

    return this.block.builder.path(this.ref(expr.head, resolution), tail, this.block.loc(expr.loc));
  }
  /**
   * The `callParts` method takes ASTv1.CallParts as well as a syntax context and normalizes
   * it to an ASTv2 CallParts.
   */
  ;

  _proto2.callParts = function callParts(parts, context) {
    var _this = this;

    var path = parts.path,
        params = parts.params,
        hash = parts.hash;
    var callee = this.normalize(path, context);
    var paramList = params.map(function (p) {
      return _this.normalize(p, ASTv2.ARGUMENT_RESOLUTION);
    });

    var paramLoc = _spanList.SpanList.range(paramList, callee.loc.collapse('end'));

    var namedLoc = this.block.loc(hash.loc);

    var argsLoc = _spanList.SpanList.range([paramLoc, namedLoc]);

    var positional = this.block.builder.positional(params.map(function (p) {
      return _this.normalize(p, ASTv2.ARGUMENT_RESOLUTION);
    }), paramLoc);
    var named = this.block.builder.named(hash.pairs.map(function (p) {
      return _this.namedArgument(p);
    }), this.block.loc(hash.loc));
    return {
      callee: callee,
      args: this.block.builder.args(positional, named, argsLoc)
    };
  };

  _proto2.namedArgument = function namedArgument(pair) {
    var offsets = this.block.loc(pair.loc);
    var keyOffsets = offsets.sliceStartChars({
      chars: pair.key.length
    });
    return this.block.builder.namedArgument(new _slice.SourceSlice({
      chars: pair.key,
      loc: keyOffsets
    }), this.normalize(pair.value, ASTv2.ARGUMENT_RESOLUTION));
  }
  /**
   * The `ref` method normalizes an `ASTv1.PathHead` into an `ASTv2.VariableReference`.
   * This method is extremely important, because it is responsible for normalizing free
   * variables into an an ASTv2.PathHead *with appropriate context*.
   *
   * The syntax context is originally determined by the syntactic position that this `PathHead`
   * came from, and is ultimately attached to the `ASTv2.VariableReference` here. In ASTv2,
   * the `VariableReference` node bears full responsibility for loose mode rules that control
   * the behavior of free variables.
   */
  ;

  _proto2.ref = function ref(head, resolution) {
    var block = this.block;
    var builder = block.builder,
        table = block.table;
    var offsets = block.loc(head.loc);

    switch (head.type) {
      case 'ThisHead':
        return builder.self(offsets);

      case 'AtHead':
        {
          var symbol = table.allocateNamed(head.name);
          return builder.at(head.name, symbol, offsets);
        }

      case 'VarHead':
        {
          if (block.hasBinding(head.name)) {
            var _symbol = table.isRoot ? table.allocateTemplateLocal(head.name) : table.get(head.name);

            return block.builder.localVar(head.name, _symbol, table.isRoot, offsets);
          } else {
            var _symbol2 = block.table.allocateFree(head.name);

            return block.builder.freeVar({
              name: head.name,
              context: block.strict ? ASTv2.STRICT_RESOLUTION : resolution,
              symbol: _symbol2,
              loc: offsets
            });
          }
        }
    }
  };

  return ExpressionNormalizer;
}();
/**
 * `TemplateNormalizer` normalizes top-level ASTv1 statements to ASTv2.
 */


var StatementNormalizer = /*#__PURE__*/function () {
  function StatementNormalizer(block) {
    this.block = block;
  }

  var _proto3 = StatementNormalizer.prototype;

  _proto3.normalize = function normalize(node) {
    switch (node.type) {
      case 'PartialStatement':
        throw new Error("Handlebars partial syntax ({{> ...}}) is not allowed in Glimmer");

      case 'BlockStatement':
        return this.BlockStatement(node);

      case 'ElementNode':
        return new ElementNormalizer(this.block).ElementNode(node);

      case 'MustacheStatement':
        return this.MustacheStatement(node);
      // These are the same in ASTv2

      case 'MustacheCommentStatement':
        return this.MustacheCommentStatement(node);

      case 'CommentStatement':
        {
          var loc = this.block.loc(node.loc);
          return new ASTv2.HtmlComment({
            loc: loc,
            text: loc.slice({
              skipStart: 4,
              skipEnd: 3
            }).toSlice(node.value)
          });
        }

      case 'TextNode':
        return new ASTv2.HtmlText({
          loc: this.block.loc(node.loc),
          chars: node.chars
        });
    }
  };

  _proto3.MustacheCommentStatement = function MustacheCommentStatement(node) {
    var loc = this.block.loc(node.loc);
    var textLoc;

    if (loc.asString().slice(0, 5) === '{{!--') {
      textLoc = loc.slice({
        skipStart: 5,
        skipEnd: 4
      });
    } else {
      textLoc = loc.slice({
        skipStart: 3,
        skipEnd: 2
      });
    }

    return new ASTv2.GlimmerComment({
      loc: loc,
      text: textLoc.toSlice(node.value)
    });
  }
  /**
   * Normalizes an ASTv1.MustacheStatement to an ASTv2.AppendStatement
   */
  ;

  _proto3.MustacheStatement = function MustacheStatement(mustache) {
    var escaped = mustache.escaped;
    var loc = this.block.loc(mustache.loc); // Normalize the call parts in AppendSyntaxContext

    var callParts = this.expr.callParts({
      path: mustache.path,
      params: mustache.params,
      hash: mustache.hash
    }, (0, _looseResolution.AppendSyntaxContext)(mustache));
    var value = callParts.args.isEmpty() ? callParts.callee : this.block.builder.sexp(callParts, loc);
    return this.block.builder.append({
      table: this.block.table,
      trusting: !escaped,
      value: value
    }, loc);
  }
  /**
   * Normalizes a ASTv1.BlockStatement to an ASTv2.BlockStatement
   */
  ;

  _proto3.BlockStatement = function BlockStatement(block) {
    var program = block.program,
        inverse = block.inverse;
    var loc = this.block.loc(block.loc);
    var resolution = this.block.resolutionFor(block, _looseResolution.BlockSyntaxContext);

    if (resolution.resolution === 'error') {
      throw (0, _syntaxError.generateSyntaxError)("You attempted to invoke a path (`{{#" + resolution.path + "}}`) but " + resolution.head + " was not in scope", loc);
    }

    var callParts = this.expr.callParts(block, resolution.resolution);
    return this.block.builder.blockStatement((0, _util.assign)({
      symbols: this.block.table,
      program: this.Block(program),
      inverse: inverse ? this.Block(inverse) : null
    }, callParts), loc);
  };

  _proto3.Block = function Block(_ref) {
    var body = _ref.body,
        loc = _ref.loc,
        blockParams = _ref.blockParams;
    var child = this.block.child(blockParams);
    var normalizer = new StatementNormalizer(child);
    return new BlockChildren(this.block.loc(loc), body.map(function (b) {
      return normalizer.normalize(b);
    }), this.block).assertBlock(child.table);
  };

  _createClass(StatementNormalizer, [{
    key: "expr",
    get: function get() {
      return new ExpressionNormalizer(this.block);
    }
  }]);

  return StatementNormalizer;
}();

var ElementNormalizer = /*#__PURE__*/function () {
  function ElementNormalizer(ctx) {
    this.ctx = ctx;
  }
  /**
   * Normalizes an ASTv1.ElementNode to:
   *
   * - ASTv2.NamedBlock if the tag name begins with `:`
   * - ASTv2.Component if the tag name matches the component heuristics
   * - ASTv2.SimpleElement if the tag name doesn't match the component heuristics
   *
   * A tag name represents a component if:
   *
   * - it begins with `@`
   * - it is exactly `this` or begins with `this.`
   * - the part before the first `.` is a reference to an in-scope variable binding
   * - it begins with an uppercase character
   */


  var _proto4 = ElementNormalizer.prototype;

  _proto4.ElementNode = function ElementNode(element) {
    var _this2 = this;

    var tag = element.tag,
        selfClosing = element.selfClosing,
        comments = element.comments;
    var loc = this.ctx.loc(element.loc);

    var _tag$split = tag.split('.'),
        tagHead = _tag$split[0],
        rest = _tag$split.slice(1); // the head, attributes and modifiers are in the current scope


    var path = this.classifyTag(tagHead, rest, element.loc);
    var attrs = element.attributes.filter(function (a) {
      return a.name[0] !== '@';
    }).map(function (a) {
      return _this2.attr(a);
    });
    var args = element.attributes.filter(function (a) {
      return a.name[0] === '@';
    }).map(function (a) {
      return _this2.arg(a);
    });
    var modifiers = element.modifiers.map(function (m) {
      return _this2.modifier(m);
    }); // the element's block params are in scope for the children

    var child = this.ctx.child(element.blockParams);
    var normalizer = new StatementNormalizer(child);
    var childNodes = element.children.map(function (s) {
      return normalizer.normalize(s);
    });
    var el = this.ctx.builder.element({
      selfClosing: selfClosing,
      attrs: attrs,
      componentArgs: args,
      modifiers: modifiers,
      comments: comments.map(function (c) {
        return new StatementNormalizer(_this2.ctx).MustacheCommentStatement(c);
      })
    });
    var children = new ElementChildren(el, loc, childNodes, this.ctx);
    var offsets = this.ctx.loc(element.loc);
    var tagOffsets = offsets.sliceStartChars({
      chars: tag.length,
      skipStart: 1
    });

    if (path === 'ElementHead') {
      if (tag[0] === ':') {
        return children.assertNamedBlock(tagOffsets.slice({
          skipStart: 1
        }).toSlice(tag.slice(1)), child.table);
      } else {
        return children.assertElement(tagOffsets.toSlice(tag), element.blockParams.length > 0);
      }
    }

    if (element.selfClosing) {
      return el.selfClosingComponent(path, loc);
    } else {
      var blocks = children.assertComponent(tag, child.table, element.blockParams.length > 0);
      return el.componentWithNamedBlocks(path, blocks, loc);
    }
  };

  _proto4.modifier = function modifier(m) {
    var resolution = this.ctx.resolutionFor(m, _looseResolution.ModifierSyntaxContext);

    if (resolution.resolution === 'error') {
      throw (0, _syntaxError.generateSyntaxError)("You attempted to invoke a path (`{{#" + resolution.path + "}}`) but " + resolution.head + " was not in scope", m.loc);
    }

    var callParts = this.expr.callParts(m, resolution.resolution);
    return this.ctx.builder.modifier(callParts, this.ctx.loc(m.loc));
  }
  /**
   * This method handles attribute values that are curlies, as well as curlies nested inside of
   * interpolations:
   *
   * ```hbs
   * <a href={{url}} />
   * <a href="{{url}}.html" />
   * ```
   */
  ;

  _proto4.mustacheAttr = function mustacheAttr(mustache) {
    // Normalize the call parts in AttrValueSyntaxContext
    var sexp = this.ctx.builder.sexp(this.expr.callParts(mustache, (0, _looseResolution.AttrValueSyntaxContext)(mustache)), this.ctx.loc(mustache.loc)); // If there are no params or hash, just return the function part as its own expression

    if (sexp.args.isEmpty()) {
      return sexp.callee;
    } else {
      return sexp;
    }
  }
  /**
   * attrPart is the narrowed down list of valid attribute values that are also
   * allowed as a concat part (you can't nest concats).
   */
  ;

  _proto4.attrPart = function attrPart(part) {
    switch (part.type) {
      case 'MustacheStatement':
        return {
          expr: this.mustacheAttr(part),
          trusting: !part.escaped
        };

      case 'TextNode':
        return {
          expr: this.ctx.builder.literal(part.chars, this.ctx.loc(part.loc)),
          trusting: true
        };
    }
  };

  _proto4.attrValue = function attrValue(part) {
    var _this3 = this;

    switch (part.type) {
      case 'ConcatStatement':
        {
          var parts = part.parts.map(function (p) {
            return _this3.attrPart(p).expr;
          });
          return {
            expr: this.ctx.builder.interpolate(parts, this.ctx.loc(part.loc)),
            trusting: false
          };
        }

      default:
        return this.attrPart(part);
    }
  };

  _proto4.attr = function attr(m) {
    false && (0, _util.assert)(m.name[0] !== '@', 'An attr name must not start with `@`');

    if (m.name === '...attributes') {
      return this.ctx.builder.splatAttr(this.ctx.table.allocateBlock('attrs'), this.ctx.loc(m.loc));
    }

    var offsets = this.ctx.loc(m.loc);
    var nameSlice = offsets.sliceStartChars({
      chars: m.name.length
    }).toSlice(m.name);
    var value = this.attrValue(m.value);
    return this.ctx.builder.attr({
      name: nameSlice,
      value: value.expr,
      trusting: value.trusting
    }, offsets);
  };

  _proto4.arg = function arg(_arg) {
    false && (0, _util.assert)(_arg.name[0] === '@', 'An arg name must start with `@`');
    var offsets = this.ctx.loc(_arg.loc);
    var nameSlice = offsets.sliceStartChars({
      chars: _arg.name.length
    }).toSlice(_arg.name);
    var value = this.attrValue(_arg.value);
    return this.ctx.builder.arg({
      name: nameSlice,
      value: value.expr,
      trusting: value.trusting
    }, offsets);
  }
  /**
   * This function classifies the head of an ASTv1.Element into an ASTv2.PathHead (if the
   * element is a component) or `'ElementHead'` (if the element is a simple element).
   *
   * Rules:
   *
   * 1. If the variable is an `@arg`, return an `AtHead`
   * 2. If the variable is `this`, return a `ThisHead`
   * 3. If the variable is in the current scope:
   *   a. If the scope is the root scope, then return a Free `LocalVarHead`
   *   b. Else, return a standard `LocalVarHead`
   * 4. If the tag name is a path and the variable is not in the current scope, Syntax Error
   * 5. If the variable is uppercase return a FreeVar(ResolveAsComponentHead)
   * 6. Otherwise, return `'ElementHead'`
   */
  ;

  _proto4.classifyTag = function classifyTag(variable, tail, loc) {
    var uppercase = isUpperCase(variable);
    var inScope = this.ctx.hasBinding(variable); // Since the parser handed us the HTML element name as a string, we need
    // to convert it into an ASTv1 path so it can be processed using the
    // expression normalizer.

    var isComponent = variable[0] === '@' || variable === 'this' || inScope || uppercase;
    var variableLoc = loc.sliceStartChars({
      skipStart: 1,
      chars: variable.length
    });
    var tailLength = tail.reduce(function (accum, part) {
      return accum + 1 + part.length;
    }, 0);
    var pathEnd = variableLoc.getEnd().move(tailLength);
    var pathLoc = variableLoc.withEnd(pathEnd);

    if (isComponent) {
      // If the component name is uppercase, the variable is not in scope,
      // and the template is not in strict mode, run the optional
      // `customizeComponentName` function provided as an option to the
      // precompiler.
      if (!this.ctx.strict && uppercase && !inScope) {
        variable = this.ctx.customizeComponentName(variable);
      }

      var path = _parserBuilders.default.path({
        head: _parserBuilders.default.head(variable, variableLoc),
        tail: tail,
        loc: pathLoc
      });

      var resolution = this.ctx.resolutionFor(path, _looseResolution.ComponentSyntaxContext);

      if (resolution.resolution === 'error') {
        throw (0, _syntaxError.generateSyntaxError)("You attempted to invoke a path (`<" + resolution.path + ">`) but " + resolution.head + " was not in scope", loc);
      }

      return new ExpressionNormalizer(this.ctx).normalize(path, resolution.resolution);
    } // If the tag name wasn't a valid component but contained a `.`, it's
    // a syntax error.


    if (tail.length > 0) {
      throw (0, _syntaxError.generateSyntaxError)("You used " + variable + "." + tail.join('.') + " as a tag name, but " + variable + " is not in scope", loc);
    }

    return 'ElementHead';
  };

  _createClass(ElementNormalizer, [{
    key: "expr",
    get: function get() {
      return new ExpressionNormalizer(this.ctx);
    }
  }]);

  return ElementNormalizer;
}();

var Children = function Children(loc, children, block) {
  this.loc = loc;
  this.children = children;
  this.block = block;
  this.namedBlocks = children.filter(function (c) {
    return c instanceof ASTv2.NamedBlock;
  });
  this.hasSemanticContent = Boolean(children.filter(function (c) {
    if (c instanceof ASTv2.NamedBlock) {
      return false;
    }

    switch (c.type) {
      case 'GlimmerComment':
      case 'HtmlComment':
        return false;

      case 'HtmlText':
        return !/^\s*$/.exec(c.chars);

      default:
        return true;
    }
  }).length);
  this.nonBlockChildren = children.filter(function (c) {
    return !(c instanceof ASTv2.NamedBlock);
  });
};

var TemplateChildren = /*#__PURE__*/function (_Children) {
  _inheritsLoose(TemplateChildren, _Children);

  function TemplateChildren() {
    return _Children.apply(this, arguments) || this;
  }

  var _proto5 = TemplateChildren.prototype;

  _proto5.assertTemplate = function assertTemplate(table) {
    if ((0, _util.isPresent)(this.namedBlocks)) {
      throw (0, _syntaxError.generateSyntaxError)("Unexpected named block at the top-level of a template", this.loc);
    }

    return this.block.builder.template(table, this.nonBlockChildren, this.block.loc(this.loc));
  };

  return TemplateChildren;
}(Children);

var BlockChildren = /*#__PURE__*/function (_Children2) {
  _inheritsLoose(BlockChildren, _Children2);

  function BlockChildren() {
    return _Children2.apply(this, arguments) || this;
  }

  var _proto6 = BlockChildren.prototype;

  _proto6.assertBlock = function assertBlock(table) {
    if ((0, _util.isPresent)(this.namedBlocks)) {
      throw (0, _syntaxError.generateSyntaxError)("Unexpected named block nested in a normal block", this.loc);
    }

    return this.block.builder.block(table, this.nonBlockChildren, this.loc);
  };

  return BlockChildren;
}(Children);

var ElementChildren = /*#__PURE__*/function (_Children3) {
  _inheritsLoose(ElementChildren, _Children3);

  function ElementChildren(el, loc, children, block) {
    var _this4;

    _this4 = _Children3.call(this, loc, children, block) || this;
    _this4.el = el;
    return _this4;
  }

  var _proto7 = ElementChildren.prototype;

  _proto7.assertNamedBlock = function assertNamedBlock(name, table) {
    if (this.el.base.selfClosing) {
      throw (0, _syntaxError.generateSyntaxError)("<:" + name + "> is not a valid named block: named blocks cannot be self-closing", this.loc);
    }

    if ((0, _util.isPresent)(this.namedBlocks)) {
      throw (0, _syntaxError.generateSyntaxError)("Unexpected named block inside <:" + name + "> named block: named blocks cannot contain nested named blocks", this.loc);
    }

    if (!isLowerCase(name.chars)) {
      throw (0, _syntaxError.generateSyntaxError)("<:" + name + "> is not a valid named block: `" + name + "` is uppercase, and named blocks must be lowercase", this.loc);
    }

    var offsets = _spanList.SpanList.range(this.nonBlockChildren, this.loc);

    return this.block.builder.namedBlock(name, this.block.builder.block(table, this.nonBlockChildren, offsets), this.loc);
  };

  _proto7.assertElement = function assertElement(name, hasBlockParams) {
    if (hasBlockParams) {
      throw (0, _syntaxError.generateSyntaxError)("Unexpected block params in <" + name + ">: simple elements cannot have block params", this.loc);
    }

    if ((0, _util.isPresent)(this.namedBlocks)) {
      var names = this.namedBlocks.map(function (b) {
        return b.name;
      });

      if (names.length === 1) {
        throw (0, _syntaxError.generateSyntaxError)("Syntax Error: Unexpected named block <:foo> inside <" + name + "> HTML element", this.loc);
      } else {
        var printedNames = names.map(function (n) {
          return "<:" + n.chars + ">";
        }).join(', ');
        throw (0, _syntaxError.generateSyntaxError)("Syntax Error: Unexpected named blocks inside <" + name + "> HTML element (" + printedNames + ")", this.loc);
      }
    }

    return this.el.simple(name, this.nonBlockChildren, this.loc);
  };

  _proto7.assertComponent = function assertComponent(name, table, hasBlockParams) {
    if ((0, _util.isPresent)(this.namedBlocks) && this.hasSemanticContent) {
      throw (0, _syntaxError.generateSyntaxError)("Unexpected content inside <" + name + "> component invocation: when using named blocks, the tag cannot contain other content", this.loc);
    }

    if ((0, _util.isPresent)(this.namedBlocks)) {
      if (hasBlockParams) {
        throw (0, _syntaxError.generateSyntaxError)("Unexpected block params list on <" + name + "> component invocation: when passing named blocks, the invocation tag cannot take block params", this.loc);
      }

      return this.namedBlocks;
    } else {
      return [this.block.builder.namedBlock(_slice.SourceSlice.synthetic('default'), this.block.builder.block(table, this.nonBlockChildren, this.loc), this.loc)];
    }
  };

  return ElementChildren;
}(Children);

function isUpperCase(tag) {
  return tag[0] === tag[0].toUpperCase() && tag[0] !== tag[0].toLowerCase();
}

function isLowerCase(tag) {
  return tag[0] === tag[0].toLowerCase() && tag[0] !== tag[0].toUpperCase();
}

function printPath(node) {
  if (node.type !== 'PathExpression' && node.path.type === 'PathExpression') {
    return printPath(node.path);
  } else {
    return new _printer.default({
      entityEncoding: 'raw'
    }).print(node);
  }
}

function printHead(node) {
  if (node.type === 'PathExpression') {
    switch (node.head.type) {
      case 'AtHead':
      case 'VarHead':
        return node.head.name;

      case 'ThisHead':
        return 'this';
    }
  } else if (node.path.type === 'PathExpression') {
    return printHead(node.path);
  } else {
    return new _printer.default({
      entityEncoding: 'raw'
    }).print(node);
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvdjItYS9ub3JtYWxpemUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7QUFFQTs7QUFDQTs7QUFFQTs7QUFHQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVTSxTQUFBLFNBQUEsQ0FBQSxNQUFBLEVBQUEsT0FBQSxFQUFtRTtBQUFBLE1BQS9CLE9BQStCLEtBQUEsS0FBQSxDQUFBLEVBQUE7QUFBL0IsSUFBQSxPQUErQixHQUFuRSxFQUFvQztBQUErQjs7QUFDdkUsTUFBSSxHQUFHLEdBQUcsd0NBQVUsTUFBVixFQUFWLE9BQVUsQ0FBVjtBQUVBLE1BQUksZ0JBQWdCLEdBQUcsa0JBQ3JCO0FBQ0UsSUFBQSxVQUFVLEVBRFosS0FBQTtBQUVFLElBQUEsTUFBTSxFQUFFO0FBRlYsR0FEcUIsRUFBdkIsT0FBdUIsQ0FBdkI7O0FBUUEsTUFBSSxHQUFHLEdBQUcseUJBQUEsR0FBQSxDQUFnQixnQkFBZ0IsQ0FBaEIsVUFBQSxHQUE4QixnQkFBZ0IsQ0FBOUMsTUFBQSxHQUExQixFQUFVLENBQVY7O0FBQ0EsTUFBSSxLQUFLLEdBQUcsSUFBQSxZQUFBLENBQUEsTUFBQSxFQUFBLGdCQUFBLEVBQVosR0FBWSxDQUFaO0FBQ0EsTUFBSSxVQUFVLEdBQUcsSUFBQSxtQkFBQSxDQUFqQixLQUFpQixDQUFqQjtBQUVBLFNBQU8sSUFBQSxnQkFBQSxDQUNMLEtBQUssQ0FBTCxHQUFBLENBQVUsR0FBRyxDQURSLEdBQ0wsQ0FESyxFQUVMLEdBQUcsQ0FBSCxJQUFBLENBQUEsR0FBQSxDQUFjLFVBQUQsQ0FBQyxFQUFEO0FBQUEsV0FBTyxVQUFVLENBQVYsU0FBQSxDQUZmLENBRWUsQ0FBUDtBQUZSLEdBRUws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Rjs7QUFFRCxTQUFBLFNBQUEsQ0FBQSxJQUFBLEVBQThEO0FBQzVELE1BQUksSUFBSSxDQUFKLElBQUEsS0FBSixnQkFBQSxFQUFvQztBQUNsQyxZQUFRLElBQUksQ0FBSixJQUFBLENBQVIsSUFBQTtBQUNFLFdBQUEsUUFBQTtBQUNBLFdBQUEsU0FBQTtBQUNFLGVBQU8sSUFBSSxDQUFKLElBQUEsQ0FBUCxJQUFBOztBQUNGLFdBQUEsVUFBQTtBQUNFLGVBQUEsTUFBQTtBQUxKO0FBREYsR0FBQSxNQVFPLElBQUksSUFBSSxDQUFKLElBQUEsQ0FBQSxJQUFBLEtBQUosZ0JBQUEsRUFBeUM7QUFDOUMsV0FBTyxTQUFTLENBQUMsSUFBSSxDQUFyQixJQUFnQixDQUFoQjtBQURLLEdBQUEsTUFFQTtBQUNMLFdBQU8sSUFBQSxnQkFBQSxDQUFZO0FBQUUsTUFBQSxjQUFjLEVBQUU7QUFBbEIsS0FBWixFQUFBLEtBQUEsQ0FBUCxJQUFPLENBQVA7QUFDRDtBQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJlc2VudEFycmF5IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBhc3NlcnQsIGFzc2lnbiwgaXNQcmVzZW50IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCBQcmludGVyIGZyb20gJy4uL2dlbmVyYXRpb24vcHJpbnRlcic7XG5pbXBvcnQgeyBQcmVjb21waWxlT3B0aW9ucywgcHJlcHJvY2VzcyB9IGZyb20gJy4uL3BhcnNlci90b2tlbml6ZXItZXZlbnQtaGFuZGxlcnMnO1xuaW1wb3J0IHsgU291cmNlTG9jYXRpb24gfSBmcm9tICcuLi9zb3VyY2UvbG9jYXRpb24nO1xuaW1wb3J0IHsgU291cmNlU2xpY2UgfSBmcm9tICcuLi9zb3VyY2Uvc2xpY2UnO1xuaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi4vc291cmNlL3NvdXJjZSc7XG5pbXBvcnQgeyBTb3VyY2VTcGFuIH0gZnJvbSAnLi4vc291cmNlL3NwYW4nO1xuaW1wb3J0IHsgU3Bhbkxpc3QgfSBmcm9tICcuLi9zb3VyY2Uvc3Bhbi1saXN0JztcbmltcG9ydCB7IEJsb2NrU3ltYm9sVGFibGUsIFByb2dyYW1TeW1ib2xUYWJsZSwgU3ltYm9sVGFibGUgfSBmcm9tICcuLi9zeW1ib2wtdGFibGUnO1xuaW1wb3J0IHsgZ2VuZXJhdGVTeW50YXhFcnJvciB9IGZyb20gJy4uL3N5bnRheC1lcnJvcic7XG5pbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuLi92MS9hcGknO1xuaW1wb3J0IGIgZnJvbSAnLi4vdjEvcGFyc2VyLWJ1aWxkZXJzJztcbmltcG9ydCAqIGFzIEFTVHYyIGZyb20gJy4vYXBpJztcbmltcG9ydCB7IEJ1aWxkRWxlbWVudCwgQnVpbGRlciwgQ2FsbFBhcnRzIH0gZnJvbSAnLi9idWlsZGVycyc7XG5pbXBvcnQge1xuICBBcHBlbmRTeW50YXhDb250ZXh0LFxuICBBdHRyVmFsdWVTeW50YXhDb250ZXh0LFxuICBCbG9ja1N5bnRheENvbnRleHQsXG4gIENvbXBvbmVudFN5bnRheENvbnRleHQsXG4gIE1vZGlmaWVyU3ludGF4Q29udGV4dCxcbiAgUmVzb2x1dGlvbixcbiAgU2V4cFN5bnRheENvbnRleHQsXG59IGZyb20gJy4vbG9vc2UtcmVzb2x1dGlvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUoc291cmNlOiBTb3VyY2UsIG9wdGlvbnM6IFByZWNvbXBpbGVPcHRpb25zID0ge30pOiBBU1R2Mi5UZW1wbGF0ZSB7XG4gIGxldCBhc3QgPSBwcmVwcm9jZXNzKHNvdXJjZSwgb3B0aW9ucyk7XG5cbiAgbGV0IG5vcm1hbGl6ZU9wdGlvbnMgPSBhc3NpZ24oXG4gICAge1xuICAgICAgc3RyaWN0TW9kZTogZmFsc2UsXG4gICAgICBsb2NhbHM6IFtdLFxuICAgIH0sXG4gICAgb3B0aW9uc1xuICApO1xuXG4gIGxldCB0b3AgPSBTeW1ib2xUYWJsZS50b3Aobm9ybWFsaXplT3B0aW9ucy5zdHJpY3RNb2RlID8gbm9ybWFsaXplT3B0aW9ucy5sb2NhbHMgOiBbXSk7XG4gIGxldCBibG9jayA9IG5ldyBCbG9ja0NvbnRleHQoc291cmNlLCBub3JtYWxpemVPcHRpb25zLCB0b3ApO1xuICBsZXQgbm9ybWFsaXplciA9IG5ldyBTdGF0ZW1lbnROb3JtYWxpemVyKGJsb2NrKTtcblxuICByZXR1cm4gbmV3IFRlbXBsYXRlQ2hpbGRyZW4oXG4gICAgYmxvY2subG9jKGFzdC5sb2MpLFxuICAgIGFzdC5ib2R5Lm1hcCgoYikgPT4gbm9ybWFsaXplci5ub3JtYWxpemUoYikpLFxuICAgIGJsb2NrXG4gICkuYXNzZXJ0VGVtcGxhdGUodG9wKTtcbn1cblxuLyoqXG4gKiBBIGBCbG9ja0NvbnRleHRgIHJlcHJlc2VudHMgdGhlIGJsb2NrIHRoYXQgYSBwYXJ0aWN1bGFyIEFTVCBub2RlIGlzIGNvbnRhaW5lZCBpbnNpZGUgb2YuXG4gKlxuICogYEJsb2NrQ29udGV4dGAgaXMgYXdhcmUgb2YgdGVtcGxhdGUtd2lkZSBvcHRpb25zIChzdWNoIGFzIHN0cmljdCBtb2RlKSwgYXMgd2VsbCBhcyB0aGUgYmluZGluZ3NcbiAqIHRoYXQgYXJlIGluLXNjb3BlIHdpdGhpbiB0aGF0IGJsb2NrLlxuICpcbiAqIENvbmNyZXRlbHksIGl0IGhhcyB0aGUgYFByZWNvbXBpbGVPcHRpb25zYCBhbmQgY3VycmVudCBgU3ltYm9sVGFibGVgLCBhbmQgcHJvdmlkZXNcbiAqIGZhY2lsaXRpZXMgZm9yIHdvcmtpbmcgd2l0aCB0aG9zZSBvcHRpb25zLlxuICpcbiAqIGBCbG9ja0NvbnRleHRgIGlzIHN0YXRlbGVzcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrQ29udGV4dDxUYWJsZSBleHRlbmRzIFN5bWJvbFRhYmxlID0gU3ltYm9sVGFibGU+IHtcbiAgcmVhZG9ubHkgYnVpbGRlcjogQnVpbGRlcjtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBzb3VyY2U6IFNvdXJjZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbnM6IFByZWNvbXBpbGVPcHRpb25zLFxuICAgIHJlYWRvbmx5IHRhYmxlOiBUYWJsZVxuICApIHtcbiAgICB0aGlzLmJ1aWxkZXIgPSBuZXcgQnVpbGRlcigpO1xuICB9XG5cbiAgZ2V0IHN0cmljdCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0cmljdE1vZGUgfHwgZmFsc2U7XG4gIH1cblxuICBsb2MobG9jOiBTb3VyY2VMb2NhdGlvbik6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5zcGFuRm9yKGxvYyk7XG4gIH1cblxuICByZXNvbHV0aW9uRm9yPE4gZXh0ZW5kcyBBU1R2MS5DYWxsTm9kZSB8IEFTVHYxLlBhdGhFeHByZXNzaW9uPihcbiAgICBub2RlOiBOLFxuICAgIHJlc29sdXRpb246IFJlc29sdXRpb248Tj5cbiAgKTogeyByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbiB9IHwgeyByZXNvbHV0aW9uOiAnZXJyb3InOyBwYXRoOiBzdHJpbmc7IGhlYWQ6IHN0cmluZyB9IHtcbiAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgIHJldHVybiB7IHJlc29sdXRpb246IEFTVHYyLlNUUklDVF9SRVNPTFVUSU9OIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNGcmVlVmFyKG5vZGUpKSB7XG4gICAgICBsZXQgciA9IHJlc29sdXRpb24obm9kZSk7XG5cbiAgICAgIGlmIChyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzb2x1dGlvbjogJ2Vycm9yJyxcbiAgICAgICAgICBwYXRoOiBwcmludFBhdGgobm9kZSksXG4gICAgICAgICAgaGVhZDogcHJpbnRIZWFkKG5vZGUpLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geyByZXNvbHV0aW9uOiByIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHJlc29sdXRpb246IEFTVHYyLlNUUklDVF9SRVNPTFVUSU9OIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBpc0ZyZWVWYXIoY2FsbGVlOiBBU1R2MS5DYWxsTm9kZSB8IEFTVHYxLlBhdGhFeHByZXNzaW9uKTogYm9vbGVhbiB7XG4gICAgaWYgKGNhbGxlZS50eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKSB7XG4gICAgICBpZiAoY2FsbGVlLmhlYWQudHlwZSAhPT0gJ1ZhckhlYWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICF0aGlzLnRhYmxlLmhhcyhjYWxsZWUuaGVhZC5uYW1lKTtcbiAgICB9IGVsc2UgaWYgKGNhbGxlZS5wYXRoLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzRnJlZVZhcihjYWxsZWUucGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBoYXNCaW5kaW5nKG5hbWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRhYmxlLmhhcyhuYW1lKTtcbiAgfVxuXG4gIGNoaWxkKGJsb2NrUGFyYW1zOiBzdHJpbmdbXSk6IEJsb2NrQ29udGV4dDxCbG9ja1N5bWJvbFRhYmxlPiB7XG4gICAgcmV0dXJuIG5ldyBCbG9ja0NvbnRleHQodGhpcy5zb3VyY2UsIHRoaXMub3B0aW9ucywgdGhpcy50YWJsZS5jaGlsZChibG9ja1BhcmFtcykpO1xuICB9XG5cbiAgY3VzdG9taXplQ29tcG9uZW50TmFtZShpbnB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmN1c3RvbWl6ZUNvbXBvbmVudE5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuY3VzdG9taXplQ29tcG9uZW50TmFtZShpbnB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBgRXhwcmVzc2lvbk5vcm1hbGl6ZXJgIG5vcm1hbGl6ZXMgZXhwcmVzc2lvbnMgd2l0aGluIGEgYmxvY2suXG4gKlxuICogYEV4cHJlc3Npb25Ob3JtYWxpemVyYCBpcyBzdGF0ZWxlc3MuXG4gKi9cbmNsYXNzIEV4cHJlc3Npb25Ob3JtYWxpemVyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBibG9jazogQmxvY2tDb250ZXh0KSB7fVxuXG4gIC8qKlxuICAgKiBUaGUgYG5vcm1hbGl6ZWAgbWV0aG9kIHRha2VzIGFuIGFyYml0cmFyeSBleHByZXNzaW9uIGFuZCBpdHMgb3JpZ2luYWwgc3ludGF4IGNvbnRleHQgYW5kXG4gICAqIG5vcm1hbGl6ZXMgaXQgdG8gYW4gQVNUdjIgZXhwcmVzc2lvbi5cbiAgICpcbiAgICogQHNlZSB7U3ludGF4Q29udGV4dH1cbiAgICovXG4gIG5vcm1hbGl6ZShleHByOiBBU1R2MS5MaXRlcmFsLCByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbik6IEFTVHYyLkxpdGVyYWxFeHByZXNzaW9uO1xuICBub3JtYWxpemUoXG4gICAgZXhwcjogQVNUdjEuTWluaW1hbFBhdGhFeHByZXNzaW9uLFxuICAgIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uXG4gICk6IEFTVHYyLlBhdGhFeHByZXNzaW9uO1xuICBub3JtYWxpemUoZXhwcjogQVNUdjEuU3ViRXhwcmVzc2lvbiwgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb24pOiBBU1R2Mi5DYWxsRXhwcmVzc2lvbjtcbiAgbm9ybWFsaXplKGV4cHI6IEFTVHYxLkV4cHJlc3Npb24sIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uKTogQVNUdjIuRXhwcmVzc2lvbk5vZGU7XG4gIG5vcm1hbGl6ZShcbiAgICBleHByOiBBU1R2MS5FeHByZXNzaW9uIHwgQVNUdjEuTWluaW1hbFBhdGhFeHByZXNzaW9uLFxuICAgIHJlc29sdXRpb246IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uXG4gICk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHtcbiAgICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICAgICAgY2FzZSAnTnVsbExpdGVyYWwnOlxuICAgICAgY2FzZSAnQm9vbGVhbkxpdGVyYWwnOlxuICAgICAgY2FzZSAnTnVtYmVyTGl0ZXJhbCc6XG4gICAgICBjYXNlICdTdHJpbmdMaXRlcmFsJzpcbiAgICAgIGNhc2UgJ1VuZGVmaW5lZExpdGVyYWwnOlxuICAgICAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLmxpdGVyYWwoZXhwci52YWx1ZSwgdGhpcy5ibG9jay5sb2MoZXhwci5sb2MpKTtcbiAgICAgIGNhc2UgJ1BhdGhFeHByZXNzaW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0aChleHByLCByZXNvbHV0aW9uKTtcbiAgICAgIGNhc2UgJ1N1YkV4cHJlc3Npb24nOiB7XG4gICAgICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5ibG9jay5yZXNvbHV0aW9uRm9yKGV4cHIsIFNleHBTeW50YXhDb250ZXh0KTtcblxuICAgICAgICBpZiAocmVzb2x1dGlvbi5yZXNvbHV0aW9uID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICAgIGBZb3UgYXR0ZW1wdGVkIHRvIGludm9rZSBhIHBhdGggKFxcYCR7cmVzb2x1dGlvbi5wYXRofVxcYCkgYnV0ICR7cmVzb2x1dGlvbi5oZWFkfSB3YXMgbm90IGluIHNjb3BlYCxcbiAgICAgICAgICAgIGV4cHIubG9jXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIuc2V4cChcbiAgICAgICAgICB0aGlzLmNhbGxQYXJ0cyhleHByLCByZXNvbHV0aW9uLnJlc29sdXRpb24pLFxuICAgICAgICAgIHRoaXMuYmxvY2subG9jKGV4cHIubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcGF0aChcbiAgICBleHByOiBBU1R2MS5NaW5pbWFsUGF0aEV4cHJlc3Npb24sXG4gICAgcmVzb2x1dGlvbjogQVNUdjIuRnJlZVZhclJlc29sdXRpb25cbiAgKTogQVNUdjIuUGF0aEV4cHJlc3Npb24ge1xuICAgIGxldCBoZWFkT2Zmc2V0cyA9IHRoaXMuYmxvY2subG9jKGV4cHIuaGVhZC5sb2MpO1xuXG4gICAgbGV0IHRhaWwgPSBbXTtcblxuICAgIC8vIHN0YXJ0IHdpdGggdGhlIGhlYWRcbiAgICBsZXQgb2Zmc2V0ID0gaGVhZE9mZnNldHM7XG5cbiAgICBmb3IgKGxldCBwYXJ0IG9mIGV4cHIudGFpbCkge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0LnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBwYXJ0Lmxlbmd0aCwgc2tpcFN0YXJ0OiAxIH0pO1xuICAgICAgdGFpbC5wdXNoKFxuICAgICAgICBuZXcgU291cmNlU2xpY2Uoe1xuICAgICAgICAgIGxvYzogb2Zmc2V0LFxuICAgICAgICAgIGNoYXJzOiBwYXJ0LFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLnBhdGgodGhpcy5yZWYoZXhwci5oZWFkLCByZXNvbHV0aW9uKSwgdGFpbCwgdGhpcy5ibG9jay5sb2MoZXhwci5sb2MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYGNhbGxQYXJ0c2AgbWV0aG9kIHRha2VzIEFTVHYxLkNhbGxQYXJ0cyBhcyB3ZWxsIGFzIGEgc3ludGF4IGNvbnRleHQgYW5kIG5vcm1hbGl6ZXNcbiAgICogaXQgdG8gYW4gQVNUdjIgQ2FsbFBhcnRzLlxuICAgKi9cbiAgY2FsbFBhcnRzKHBhcnRzOiBBU1R2MS5DYWxsUGFydHMsIGNvbnRleHQ6IEFTVHYyLkZyZWVWYXJSZXNvbHV0aW9uKTogQ2FsbFBhcnRzIHtcbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IHBhcnRzO1xuXG4gICAgbGV0IGNhbGxlZSA9IHRoaXMubm9ybWFsaXplKHBhdGgsIGNvbnRleHQpO1xuICAgIGxldCBwYXJhbUxpc3QgPSBwYXJhbXMubWFwKChwKSA9PiB0aGlzLm5vcm1hbGl6ZShwLCBBU1R2Mi5BUkdVTUVOVF9SRVNPTFVUSU9OKSk7XG4gICAgbGV0IHBhcmFtTG9jID0gU3Bhbkxpc3QucmFuZ2UocGFyYW1MaXN0LCBjYWxsZWUubG9jLmNvbGxhcHNlKCdlbmQnKSk7XG4gICAgbGV0IG5hbWVkTG9jID0gdGhpcy5ibG9jay5sb2MoaGFzaC5sb2MpO1xuICAgIGxldCBhcmdzTG9jID0gU3Bhbkxpc3QucmFuZ2UoW3BhcmFtTG9jLCBuYW1lZExvY10pO1xuXG4gICAgbGV0IHBvc2l0aW9uYWwgPSB0aGlzLmJsb2NrLmJ1aWxkZXIucG9zaXRpb25hbChcbiAgICAgIHBhcmFtcy5tYXAoKHApID0+IHRoaXMubm9ybWFsaXplKHAsIEFTVHYyLkFSR1VNRU5UX1JFU09MVVRJT04pKSxcbiAgICAgIHBhcmFtTG9jXG4gICAgKTtcblxuICAgIGxldCBuYW1lZCA9IHRoaXMuYmxvY2suYnVpbGRlci5uYW1lZChcbiAgICAgIGhhc2gucGFpcnMubWFwKChwKSA9PiB0aGlzLm5hbWVkQXJndW1lbnQocCkpLFxuICAgICAgdGhpcy5ibG9jay5sb2MoaGFzaC5sb2MpXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBjYWxsZWUsXG4gICAgICBhcmdzOiB0aGlzLmJsb2NrLmJ1aWxkZXIuYXJncyhwb3NpdGlvbmFsLCBuYW1lZCwgYXJnc0xvYyksXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgbmFtZWRBcmd1bWVudChwYWlyOiBBU1R2MS5IYXNoUGFpcik6IEFTVHYyLk5hbWVkQXJndW1lbnQge1xuICAgIGxldCBvZmZzZXRzID0gdGhpcy5ibG9jay5sb2MocGFpci5sb2MpO1xuXG4gICAgbGV0IGtleU9mZnNldHMgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBwYWlyLmtleS5sZW5ndGggfSk7XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLm5hbWVkQXJndW1lbnQoXG4gICAgICBuZXcgU291cmNlU2xpY2UoeyBjaGFyczogcGFpci5rZXksIGxvYzoga2V5T2Zmc2V0cyB9KSxcbiAgICAgIHRoaXMubm9ybWFsaXplKHBhaXIudmFsdWUsIEFTVHYyLkFSR1VNRU5UX1JFU09MVVRJT04pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYHJlZmAgbWV0aG9kIG5vcm1hbGl6ZXMgYW4gYEFTVHYxLlBhdGhIZWFkYCBpbnRvIGFuIGBBU1R2Mi5WYXJpYWJsZVJlZmVyZW5jZWAuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQsIGJlY2F1c2UgaXQgaXMgcmVzcG9uc2libGUgZm9yIG5vcm1hbGl6aW5nIGZyZWVcbiAgICogdmFyaWFibGVzIGludG8gYW4gYW4gQVNUdjIuUGF0aEhlYWQgKndpdGggYXBwcm9wcmlhdGUgY29udGV4dCouXG4gICAqXG4gICAqIFRoZSBzeW50YXggY29udGV4dCBpcyBvcmlnaW5hbGx5IGRldGVybWluZWQgYnkgdGhlIHN5bnRhY3RpYyBwb3NpdGlvbiB0aGF0IHRoaXMgYFBhdGhIZWFkYFxuICAgKiBjYW1lIGZyb20sIGFuZCBpcyB1bHRpbWF0ZWx5IGF0dGFjaGVkIHRvIHRoZSBgQVNUdjIuVmFyaWFibGVSZWZlcmVuY2VgIGhlcmUuIEluIEFTVHYyLFxuICAgKiB0aGUgYFZhcmlhYmxlUmVmZXJlbmNlYCBub2RlIGJlYXJzIGZ1bGwgcmVzcG9uc2liaWxpdHkgZm9yIGxvb3NlIG1vZGUgcnVsZXMgdGhhdCBjb250cm9sXG4gICAqIHRoZSBiZWhhdmlvciBvZiBmcmVlIHZhcmlhYmxlcy5cbiAgICovXG4gIHByaXZhdGUgcmVmKGhlYWQ6IEFTVHYxLlBhdGhIZWFkLCByZXNvbHV0aW9uOiBBU1R2Mi5GcmVlVmFyUmVzb2x1dGlvbik6IEFTVHYyLlZhcmlhYmxlUmVmZXJlbmNlIHtcbiAgICBsZXQgeyBibG9jayB9ID0gdGhpcztcbiAgICBsZXQgeyBidWlsZGVyLCB0YWJsZSB9ID0gYmxvY2s7XG4gICAgbGV0IG9mZnNldHMgPSBibG9jay5sb2MoaGVhZC5sb2MpO1xuXG4gICAgc3dpdGNoIChoZWFkLnR5cGUpIHtcbiAgICAgIGNhc2UgJ1RoaXNIZWFkJzpcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuc2VsZihvZmZzZXRzKTtcbiAgICAgIGNhc2UgJ0F0SGVhZCc6IHtcbiAgICAgICAgbGV0IHN5bWJvbCA9IHRhYmxlLmFsbG9jYXRlTmFtZWQoaGVhZC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuYXQoaGVhZC5uYW1lLCBzeW1ib2wsIG9mZnNldHMpO1xuICAgICAgfVxuICAgICAgY2FzZSAnVmFySGVhZCc6IHtcbiAgICAgICAgaWYgKGJsb2NrLmhhc0JpbmRpbmcoaGVhZC5uYW1lKSkge1xuICAgICAgICAgIGxldCBzeW1ib2wgPSB0YWJsZS5pc1Jvb3QgPyB0YWJsZS5hbGxvY2F0ZVRlbXBsYXRlTG9jYWwoaGVhZC5uYW1lKSA6IHRhYmxlLmdldChoZWFkLm5hbWUpO1xuXG4gICAgICAgICAgcmV0dXJuIGJsb2NrLmJ1aWxkZXIubG9jYWxWYXIoaGVhZC5uYW1lLCBzeW1ib2wsIHRhYmxlLmlzUm9vdCwgb2Zmc2V0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHN5bWJvbCA9IGJsb2NrLnRhYmxlLmFsbG9jYXRlRnJlZShoZWFkLm5hbWUpO1xuICAgICAgICAgIHJldHVybiBibG9jay5idWlsZGVyLmZyZWVWYXIoe1xuICAgICAgICAgICAgbmFtZTogaGVhZC5uYW1lLFxuICAgICAgICAgICAgY29udGV4dDogYmxvY2suc3RyaWN0ID8gQVNUdjIuU1RSSUNUX1JFU09MVVRJT04gOiByZXNvbHV0aW9uLFxuICAgICAgICAgICAgc3ltYm9sLFxuICAgICAgICAgICAgbG9jOiBvZmZzZXRzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogYFRlbXBsYXRlTm9ybWFsaXplcmAgbm9ybWFsaXplcyB0b3AtbGV2ZWwgQVNUdjEgc3RhdGVtZW50cyB0byBBU1R2Mi5cbiAqL1xuY2xhc3MgU3RhdGVtZW50Tm9ybWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYmxvY2s6IEJsb2NrQ29udGV4dCkge31cblxuICBub3JtYWxpemUobm9kZTogQVNUdjEuU3RhdGVtZW50KTogQVNUdjIuQ29udGVudE5vZGUgfCBBU1R2Mi5OYW1lZEJsb2NrIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSAnUGFydGlhbFN0YXRlbWVudCc6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSGFuZGxlYmFycyBwYXJ0aWFsIHN5bnRheCAoe3s+IC4uLn19KSBpcyBub3QgYWxsb3dlZCBpbiBHbGltbWVyYCk7XG4gICAgICBjYXNlICdCbG9ja1N0YXRlbWVudCc6XG4gICAgICAgIHJldHVybiB0aGlzLkJsb2NrU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSAnRWxlbWVudE5vZGUnOlxuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnROb3JtYWxpemVyKHRoaXMuYmxvY2spLkVsZW1lbnROb2RlKG5vZGUpO1xuICAgICAgY2FzZSAnTXVzdGFjaGVTdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5NdXN0YWNoZVN0YXRlbWVudChub2RlKTtcblxuICAgICAgLy8gVGhlc2UgYXJlIHRoZSBzYW1lIGluIEFTVHYyXG4gICAgICBjYXNlICdNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQobm9kZSk7XG5cbiAgICAgIGNhc2UgJ0NvbW1lbnRTdGF0ZW1lbnQnOiB7XG4gICAgICAgIGxldCBsb2MgPSB0aGlzLmJsb2NrLmxvYyhub2RlLmxvYyk7XG4gICAgICAgIHJldHVybiBuZXcgQVNUdjIuSHRtbENvbW1lbnQoe1xuICAgICAgICAgIGxvYyxcbiAgICAgICAgICB0ZXh0OiBsb2Muc2xpY2UoeyBza2lwU3RhcnQ6IDQsIHNraXBFbmQ6IDMgfSkudG9TbGljZShub2RlLnZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1RleHROb2RlJzpcbiAgICAgICAgcmV0dXJuIG5ldyBBU1R2Mi5IdG1sVGV4dCh7XG4gICAgICAgICAgbG9jOiB0aGlzLmJsb2NrLmxvYyhub2RlLmxvYyksXG4gICAgICAgICAgY2hhcnM6IG5vZGUuY2hhcnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIE11c3RhY2hlQ29tbWVudFN0YXRlbWVudChub2RlOiBBU1R2MS5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQpOiBBU1R2Mi5HbGltbWVyQ29tbWVudCB7XG4gICAgbGV0IGxvYyA9IHRoaXMuYmxvY2subG9jKG5vZGUubG9jKTtcbiAgICBsZXQgdGV4dExvYzogU291cmNlU3BhbjtcblxuICAgIGlmIChsb2MuYXNTdHJpbmcoKS5zbGljZSgwLCA1KSA9PT0gJ3t7IS0tJykge1xuICAgICAgdGV4dExvYyA9IGxvYy5zbGljZSh7IHNraXBTdGFydDogNSwgc2tpcEVuZDogNCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dExvYyA9IGxvYy5zbGljZSh7IHNraXBTdGFydDogMywgc2tpcEVuZDogMiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEFTVHYyLkdsaW1tZXJDb21tZW50KHtcbiAgICAgIGxvYyxcbiAgICAgIHRleHQ6IHRleHRMb2MudG9TbGljZShub2RlLnZhbHVlKSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGFuIEFTVHYxLk11c3RhY2hlU3RhdGVtZW50IHRvIGFuIEFTVHYyLkFwcGVuZFN0YXRlbWVudFxuICAgKi9cbiAgTXVzdGFjaGVTdGF0ZW1lbnQobXVzdGFjaGU6IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50KTogQVNUdjIuQXBwZW5kQ29udGVudCB7XG4gICAgbGV0IHsgZXNjYXBlZCB9ID0gbXVzdGFjaGU7XG4gICAgbGV0IGxvYyA9IHRoaXMuYmxvY2subG9jKG11c3RhY2hlLmxvYyk7XG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIGNhbGwgcGFydHMgaW4gQXBwZW5kU3ludGF4Q29udGV4dFxuICAgIGxldCBjYWxsUGFydHMgPSB0aGlzLmV4cHIuY2FsbFBhcnRzKFxuICAgICAge1xuICAgICAgICBwYXRoOiBtdXN0YWNoZS5wYXRoLFxuICAgICAgICBwYXJhbXM6IG11c3RhY2hlLnBhcmFtcyxcbiAgICAgICAgaGFzaDogbXVzdGFjaGUuaGFzaCxcbiAgICAgIH0sXG4gICAgICBBcHBlbmRTeW50YXhDb250ZXh0KG11c3RhY2hlKVxuICAgICk7XG5cbiAgICBsZXQgdmFsdWUgPSBjYWxsUGFydHMuYXJncy5pc0VtcHR5KClcbiAgICAgID8gY2FsbFBhcnRzLmNhbGxlZVxuICAgICAgOiB0aGlzLmJsb2NrLmJ1aWxkZXIuc2V4cChjYWxsUGFydHMsIGxvYyk7XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLmFwcGVuZChcbiAgICAgIHtcbiAgICAgICAgdGFibGU6IHRoaXMuYmxvY2sudGFibGUsXG4gICAgICAgIHRydXN0aW5nOiAhZXNjYXBlZCxcbiAgICAgICAgdmFsdWUsXG4gICAgICB9LFxuICAgICAgbG9jXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemVzIGEgQVNUdjEuQmxvY2tTdGF0ZW1lbnQgdG8gYW4gQVNUdjIuQmxvY2tTdGF0ZW1lbnRcbiAgICovXG4gIEJsb2NrU3RhdGVtZW50KGJsb2NrOiBBU1R2MS5CbG9ja1N0YXRlbWVudCk6IEFTVHYyLkludm9rZUJsb2NrIHtcbiAgICBsZXQgeyBwcm9ncmFtLCBpbnZlcnNlIH0gPSBibG9jaztcbiAgICBsZXQgbG9jID0gdGhpcy5ibG9jay5sb2MoYmxvY2subG9jKTtcblxuICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5ibG9jay5yZXNvbHV0aW9uRm9yKGJsb2NrLCBCbG9ja1N5bnRheENvbnRleHQpO1xuXG4gICAgaWYgKHJlc29sdXRpb24ucmVzb2x1dGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYFlvdSBhdHRlbXB0ZWQgdG8gaW52b2tlIGEgcGF0aCAoXFxge3sjJHtyZXNvbHV0aW9uLnBhdGh9fX1cXGApIGJ1dCAke3Jlc29sdXRpb24uaGVhZH0gd2FzIG5vdCBpbiBzY29wZWAsXG4gICAgICAgIGxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgY2FsbFBhcnRzID0gdGhpcy5leHByLmNhbGxQYXJ0cyhibG9jaywgcmVzb2x1dGlvbi5yZXNvbHV0aW9uKTtcblxuICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIuYmxvY2tTdGF0ZW1lbnQoXG4gICAgICBhc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBzeW1ib2xzOiB0aGlzLmJsb2NrLnRhYmxlLFxuICAgICAgICAgIHByb2dyYW06IHRoaXMuQmxvY2socHJvZ3JhbSksXG4gICAgICAgICAgaW52ZXJzZTogaW52ZXJzZSA/IHRoaXMuQmxvY2soaW52ZXJzZSkgOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgICBjYWxsUGFydHNcbiAgICAgICksXG4gICAgICBsb2NcbiAgICApO1xuICB9XG5cbiAgQmxvY2soeyBib2R5LCBsb2MsIGJsb2NrUGFyYW1zIH06IEFTVHYxLkJsb2NrKTogQVNUdjIuQmxvY2sge1xuICAgIGxldCBjaGlsZCA9IHRoaXMuYmxvY2suY2hpbGQoYmxvY2tQYXJhbXMpO1xuICAgIGxldCBub3JtYWxpemVyID0gbmV3IFN0YXRlbWVudE5vcm1hbGl6ZXIoY2hpbGQpO1xuICAgIHJldHVybiBuZXcgQmxvY2tDaGlsZHJlbihcbiAgICAgIHRoaXMuYmxvY2subG9jKGxvYyksXG4gICAgICBib2R5Lm1hcCgoYikgPT4gbm9ybWFsaXplci5ub3JtYWxpemUoYikpLFxuICAgICAgdGhpcy5ibG9ja1xuICAgICkuYXNzZXJ0QmxvY2soY2hpbGQudGFibGUpO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgZXhwcigpOiBFeHByZXNzaW9uTm9ybWFsaXplciB7XG4gICAgcmV0dXJuIG5ldyBFeHByZXNzaW9uTm9ybWFsaXplcih0aGlzLmJsb2NrKTtcbiAgfVxufVxuXG5jbGFzcyBFbGVtZW50Tm9ybWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgY3R4OiBCbG9ja0NvbnRleHQpIHt9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZXMgYW4gQVNUdjEuRWxlbWVudE5vZGUgdG86XG4gICAqXG4gICAqIC0gQVNUdjIuTmFtZWRCbG9jayBpZiB0aGUgdGFnIG5hbWUgYmVnaW5zIHdpdGggYDpgXG4gICAqIC0gQVNUdjIuQ29tcG9uZW50IGlmIHRoZSB0YWcgbmFtZSBtYXRjaGVzIHRoZSBjb21wb25lbnQgaGV1cmlzdGljc1xuICAgKiAtIEFTVHYyLlNpbXBsZUVsZW1lbnQgaWYgdGhlIHRhZyBuYW1lIGRvZXNuJ3QgbWF0Y2ggdGhlIGNvbXBvbmVudCBoZXVyaXN0aWNzXG4gICAqXG4gICAqIEEgdGFnIG5hbWUgcmVwcmVzZW50cyBhIGNvbXBvbmVudCBpZjpcbiAgICpcbiAgICogLSBpdCBiZWdpbnMgd2l0aCBgQGBcbiAgICogLSBpdCBpcyBleGFjdGx5IGB0aGlzYCBvciBiZWdpbnMgd2l0aCBgdGhpcy5gXG4gICAqIC0gdGhlIHBhcnQgYmVmb3JlIHRoZSBmaXJzdCBgLmAgaXMgYSByZWZlcmVuY2UgdG8gYW4gaW4tc2NvcGUgdmFyaWFibGUgYmluZGluZ1xuICAgKiAtIGl0IGJlZ2lucyB3aXRoIGFuIHVwcGVyY2FzZSBjaGFyYWN0ZXJcbiAgICovXG4gIEVsZW1lbnROb2RlKGVsZW1lbnQ6IEFTVHYxLkVsZW1lbnROb2RlKTogQVNUdjIuRWxlbWVudE5vZGUge1xuICAgIGxldCB7IHRhZywgc2VsZkNsb3NpbmcsIGNvbW1lbnRzIH0gPSBlbGVtZW50O1xuICAgIGxldCBsb2MgPSB0aGlzLmN0eC5sb2MoZWxlbWVudC5sb2MpO1xuXG4gICAgbGV0IFt0YWdIZWFkLCAuLi5yZXN0XSA9IHRhZy5zcGxpdCgnLicpO1xuXG4gICAgLy8gdGhlIGhlYWQsIGF0dHJpYnV0ZXMgYW5kIG1vZGlmaWVycyBhcmUgaW4gdGhlIGN1cnJlbnQgc2NvcGVcbiAgICBsZXQgcGF0aCA9IHRoaXMuY2xhc3NpZnlUYWcodGFnSGVhZCwgcmVzdCwgZWxlbWVudC5sb2MpO1xuXG4gICAgbGV0IGF0dHJzID0gZWxlbWVudC5hdHRyaWJ1dGVzLmZpbHRlcigoYSkgPT4gYS5uYW1lWzBdICE9PSAnQCcpLm1hcCgoYSkgPT4gdGhpcy5hdHRyKGEpKTtcbiAgICBsZXQgYXJncyA9IGVsZW1lbnQuYXR0cmlidXRlcy5maWx0ZXIoKGEpID0+IGEubmFtZVswXSA9PT0gJ0AnKS5tYXAoKGEpID0+IHRoaXMuYXJnKGEpKTtcblxuICAgIGxldCBtb2RpZmllcnMgPSBlbGVtZW50Lm1vZGlmaWVycy5tYXAoKG0pID0+IHRoaXMubW9kaWZpZXIobSkpO1xuXG4gICAgLy8gdGhlIGVsZW1lbnQncyBibG9jayBwYXJhbXMgYXJlIGluIHNjb3BlIGZvciB0aGUgY2hpbGRyZW5cbiAgICBsZXQgY2hpbGQgPSB0aGlzLmN0eC5jaGlsZChlbGVtZW50LmJsb2NrUGFyYW1zKTtcbiAgICBsZXQgbm9ybWFsaXplciA9IG5ldyBTdGF0ZW1lbnROb3JtYWxpemVyKGNoaWxkKTtcblxuICAgIGxldCBjaGlsZE5vZGVzID0gZWxlbWVudC5jaGlsZHJlbi5tYXAoKHMpID0+IG5vcm1hbGl6ZXIubm9ybWFsaXplKHMpKTtcblxuICAgIGxldCBlbCA9IHRoaXMuY3R4LmJ1aWxkZXIuZWxlbWVudCh7XG4gICAgICBzZWxmQ2xvc2luZyxcbiAgICAgIGF0dHJzLFxuICAgICAgY29tcG9uZW50QXJnczogYXJncyxcbiAgICAgIG1vZGlmaWVycyxcbiAgICAgIGNvbW1lbnRzOiBjb21tZW50cy5tYXAoKGMpID0+IG5ldyBTdGF0ZW1lbnROb3JtYWxpemVyKHRoaXMuY3R4KS5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQoYykpLFxuICAgIH0pO1xuXG4gICAgbGV0IGNoaWxkcmVuID0gbmV3IEVsZW1lbnRDaGlsZHJlbihlbCwgbG9jLCBjaGlsZE5vZGVzLCB0aGlzLmN0eCk7XG5cbiAgICBsZXQgb2Zmc2V0cyA9IHRoaXMuY3R4LmxvYyhlbGVtZW50LmxvYyk7XG4gICAgbGV0IHRhZ09mZnNldHMgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiB0YWcubGVuZ3RoLCBza2lwU3RhcnQ6IDEgfSk7XG5cbiAgICBpZiAocGF0aCA9PT0gJ0VsZW1lbnRIZWFkJykge1xuICAgICAgaWYgKHRhZ1swXSA9PT0gJzonKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5hc3NlcnROYW1lZEJsb2NrKFxuICAgICAgICAgIHRhZ09mZnNldHMuc2xpY2UoeyBza2lwU3RhcnQ6IDEgfSkudG9TbGljZSh0YWcuc2xpY2UoMSkpLFxuICAgICAgICAgIGNoaWxkLnRhYmxlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4uYXNzZXJ0RWxlbWVudCh0YWdPZmZzZXRzLnRvU2xpY2UodGFnKSwgZWxlbWVudC5ibG9ja1BhcmFtcy5sZW5ndGggPiAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5zZWxmQ2xvc2luZykge1xuICAgICAgcmV0dXJuIGVsLnNlbGZDbG9zaW5nQ29tcG9uZW50KHBhdGgsIGxvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBibG9ja3MgPSBjaGlsZHJlbi5hc3NlcnRDb21wb25lbnQodGFnLCBjaGlsZC50YWJsZSwgZWxlbWVudC5ibG9ja1BhcmFtcy5sZW5ndGggPiAwKTtcbiAgICAgIHJldHVybiBlbC5jb21wb25lbnRXaXRoTmFtZWRCbG9ja3MocGF0aCwgYmxvY2tzLCBsb2MpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbW9kaWZpZXIobTogQVNUdjEuRWxlbWVudE1vZGlmaWVyU3RhdGVtZW50KTogQVNUdjIuRWxlbWVudE1vZGlmaWVyIHtcbiAgICBsZXQgcmVzb2x1dGlvbiA9IHRoaXMuY3R4LnJlc29sdXRpb25Gb3IobSwgTW9kaWZpZXJTeW50YXhDb250ZXh0KTtcblxuICAgIGlmIChyZXNvbHV0aW9uLnJlc29sdXRpb24gPT09ICdlcnJvcicpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIGBZb3UgYXR0ZW1wdGVkIHRvIGludm9rZSBhIHBhdGggKFxcYHt7IyR7cmVzb2x1dGlvbi5wYXRofX19XFxgKSBidXQgJHtyZXNvbHV0aW9uLmhlYWR9IHdhcyBub3QgaW4gc2NvcGVgLFxuICAgICAgICBtLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgY2FsbFBhcnRzID0gdGhpcy5leHByLmNhbGxQYXJ0cyhtLCByZXNvbHV0aW9uLnJlc29sdXRpb24pO1xuICAgIHJldHVybiB0aGlzLmN0eC5idWlsZGVyLm1vZGlmaWVyKGNhbGxQYXJ0cywgdGhpcy5jdHgubG9jKG0ubG9jKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaGFuZGxlcyBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgYXJlIGN1cmxpZXMsIGFzIHdlbGwgYXMgY3VybGllcyBuZXN0ZWQgaW5zaWRlIG9mXG4gICAqIGludGVycG9sYXRpb25zOlxuICAgKlxuICAgKiBgYGBoYnNcbiAgICogPGEgaHJlZj17e3VybH19IC8+XG4gICAqIDxhIGhyZWY9XCJ7e3VybH19Lmh0bWxcIiAvPlxuICAgKiBgYGBcbiAgICovXG4gIHByaXZhdGUgbXVzdGFjaGVBdHRyKG11c3RhY2hlOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHtcbiAgICAvLyBOb3JtYWxpemUgdGhlIGNhbGwgcGFydHMgaW4gQXR0clZhbHVlU3ludGF4Q29udGV4dFxuICAgIGxldCBzZXhwID0gdGhpcy5jdHguYnVpbGRlci5zZXhwKFxuICAgICAgdGhpcy5leHByLmNhbGxQYXJ0cyhtdXN0YWNoZSwgQXR0clZhbHVlU3ludGF4Q29udGV4dChtdXN0YWNoZSkpLFxuICAgICAgdGhpcy5jdHgubG9jKG11c3RhY2hlLmxvYylcbiAgICApO1xuXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIHBhcmFtcyBvciBoYXNoLCBqdXN0IHJldHVybiB0aGUgZnVuY3Rpb24gcGFydCBhcyBpdHMgb3duIGV4cHJlc3Npb25cbiAgICBpZiAoc2V4cC5hcmdzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHNleHAuY2FsbGVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2V4cDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogYXR0clBhcnQgaXMgdGhlIG5hcnJvd2VkIGRvd24gbGlzdCBvZiB2YWxpZCBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgYXJlIGFsc29cbiAgICogYWxsb3dlZCBhcyBhIGNvbmNhdCBwYXJ0ICh5b3UgY2FuJ3QgbmVzdCBjb25jYXRzKS5cbiAgICovXG4gIHByaXZhdGUgYXR0clBhcnQoXG4gICAgcGFydDogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZVxuICApOiB7IGV4cHI6IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyB0cnVzdGluZzogYm9vbGVhbiB9IHtcbiAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgY2FzZSAnTXVzdGFjaGVTdGF0ZW1lbnQnOlxuICAgICAgICByZXR1cm4geyBleHByOiB0aGlzLm11c3RhY2hlQXR0cihwYXJ0KSwgdHJ1c3Rpbmc6ICFwYXJ0LmVzY2FwZWQgfTtcbiAgICAgIGNhc2UgJ1RleHROb2RlJzpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHByOiB0aGlzLmN0eC5idWlsZGVyLmxpdGVyYWwocGFydC5jaGFycywgdGhpcy5jdHgubG9jKHBhcnQubG9jKSksXG4gICAgICAgICAgdHJ1c3Rpbmc6IHRydWUsXG4gICAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhdHRyVmFsdWUoXG4gICAgcGFydDogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZSB8IEFTVHYxLkNvbmNhdFN0YXRlbWVudFxuICApOiB7IGV4cHI6IEFTVHYyLkV4cHJlc3Npb25Ob2RlOyB0cnVzdGluZzogYm9vbGVhbiB9IHtcbiAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgY2FzZSAnQ29uY2F0U3RhdGVtZW50Jzoge1xuICAgICAgICBsZXQgcGFydHMgPSBwYXJ0LnBhcnRzLm1hcCgocCkgPT4gdGhpcy5hdHRyUGFydChwKS5leHByKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHByOiB0aGlzLmN0eC5idWlsZGVyLmludGVycG9sYXRlKHBhcnRzLCB0aGlzLmN0eC5sb2MocGFydC5sb2MpKSxcbiAgICAgICAgICB0cnVzdGluZzogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyUGFydChwYXJ0KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGF0dHIobTogQVNUdjEuQXR0ck5vZGUpOiBBU1R2Mi5IdG1sT3JTcGxhdEF0dHIge1xuICAgIGFzc2VydChtLm5hbWVbMF0gIT09ICdAJywgJ0FuIGF0dHIgbmFtZSBtdXN0IG5vdCBzdGFydCB3aXRoIGBAYCcpO1xuXG4gICAgaWYgKG0ubmFtZSA9PT0gJy4uLmF0dHJpYnV0ZXMnKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdHguYnVpbGRlci5zcGxhdEF0dHIodGhpcy5jdHgudGFibGUuYWxsb2NhdGVCbG9jaygnYXR0cnMnKSwgdGhpcy5jdHgubG9jKG0ubG9jKSk7XG4gICAgfVxuXG4gICAgbGV0IG9mZnNldHMgPSB0aGlzLmN0eC5sb2MobS5sb2MpO1xuICAgIGxldCBuYW1lU2xpY2UgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBtLm5hbWUubGVuZ3RoIH0pLnRvU2xpY2UobS5uYW1lKTtcblxuICAgIGxldCB2YWx1ZSA9IHRoaXMuYXR0clZhbHVlKG0udmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmN0eC5idWlsZGVyLmF0dHIoXG4gICAgICB7IG5hbWU6IG5hbWVTbGljZSwgdmFsdWU6IHZhbHVlLmV4cHIsIHRydXN0aW5nOiB2YWx1ZS50cnVzdGluZyB9LFxuICAgICAgb2Zmc2V0c1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGFyZyhhcmc6IEFTVHYxLkF0dHJOb2RlKTogQVNUdjIuQ29tcG9uZW50QXJnIHtcbiAgICBhc3NlcnQoYXJnLm5hbWVbMF0gPT09ICdAJywgJ0FuIGFyZyBuYW1lIG11c3Qgc3RhcnQgd2l0aCBgQGAnKTtcblxuICAgIGxldCBvZmZzZXRzID0gdGhpcy5jdHgubG9jKGFyZy5sb2MpO1xuICAgIGxldCBuYW1lU2xpY2UgPSBvZmZzZXRzLnNsaWNlU3RhcnRDaGFycyh7IGNoYXJzOiBhcmcubmFtZS5sZW5ndGggfSkudG9TbGljZShhcmcubmFtZSk7XG5cbiAgICBsZXQgdmFsdWUgPSB0aGlzLmF0dHJWYWx1ZShhcmcudmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmN0eC5idWlsZGVyLmFyZyhcbiAgICAgIHsgbmFtZTogbmFtZVNsaWNlLCB2YWx1ZTogdmFsdWUuZXhwciwgdHJ1c3Rpbmc6IHZhbHVlLnRydXN0aW5nIH0sXG4gICAgICBvZmZzZXRzXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGNsYXNzaWZpZXMgdGhlIGhlYWQgb2YgYW4gQVNUdjEuRWxlbWVudCBpbnRvIGFuIEFTVHYyLlBhdGhIZWFkIChpZiB0aGVcbiAgICogZWxlbWVudCBpcyBhIGNvbXBvbmVudCkgb3IgYCdFbGVtZW50SGVhZCdgIChpZiB0aGUgZWxlbWVudCBpcyBhIHNpbXBsZSBlbGVtZW50KS5cbiAgICpcbiAgICogUnVsZXM6XG4gICAqXG4gICAqIDEuIElmIHRoZSB2YXJpYWJsZSBpcyBhbiBgQGFyZ2AsIHJldHVybiBhbiBgQXRIZWFkYFxuICAgKiAyLiBJZiB0aGUgdmFyaWFibGUgaXMgYHRoaXNgLCByZXR1cm4gYSBgVGhpc0hlYWRgXG4gICAqIDMuIElmIHRoZSB2YXJpYWJsZSBpcyBpbiB0aGUgY3VycmVudCBzY29wZTpcbiAgICogICBhLiBJZiB0aGUgc2NvcGUgaXMgdGhlIHJvb3Qgc2NvcGUsIHRoZW4gcmV0dXJuIGEgRnJlZSBgTG9jYWxWYXJIZWFkYFxuICAgKiAgIGIuIEVsc2UsIHJldHVybiBhIHN0YW5kYXJkIGBMb2NhbFZhckhlYWRgXG4gICAqIDQuIElmIHRoZSB0YWcgbmFtZSBpcyBhIHBhdGggYW5kIHRoZSB2YXJpYWJsZSBpcyBub3QgaW4gdGhlIGN1cnJlbnQgc2NvcGUsIFN5bnRheCBFcnJvclxuICAgKiA1LiBJZiB0aGUgdmFyaWFibGUgaXMgdXBwZXJjYXNlIHJldHVybiBhIEZyZWVWYXIoUmVzb2x2ZUFzQ29tcG9uZW50SGVhZClcbiAgICogNi4gT3RoZXJ3aXNlLCByZXR1cm4gYCdFbGVtZW50SGVhZCdgXG4gICAqL1xuICBwcml2YXRlIGNsYXNzaWZ5VGFnKFxuICAgIHZhcmlhYmxlOiBzdHJpbmcsXG4gICAgdGFpbDogc3RyaW5nW10sXG4gICAgbG9jOiBTb3VyY2VTcGFuXG4gICk6IEFTVHYyLkV4cHJlc3Npb25Ob2RlIHwgJ0VsZW1lbnRIZWFkJyB7XG4gICAgbGV0IHVwcGVyY2FzZSA9IGlzVXBwZXJDYXNlKHZhcmlhYmxlKTtcbiAgICBsZXQgaW5TY29wZSA9IHRoaXMuY3R4Lmhhc0JpbmRpbmcodmFyaWFibGUpO1xuXG4gICAgLy8gU2luY2UgdGhlIHBhcnNlciBoYW5kZWQgdXMgdGhlIEhUTUwgZWxlbWVudCBuYW1lIGFzIGEgc3RyaW5nLCB3ZSBuZWVkXG4gICAgLy8gdG8gY29udmVydCBpdCBpbnRvIGFuIEFTVHYxIHBhdGggc28gaXQgY2FuIGJlIHByb2Nlc3NlZCB1c2luZyB0aGVcbiAgICAvLyBleHByZXNzaW9uIG5vcm1hbGl6ZXIuXG4gICAgbGV0IGlzQ29tcG9uZW50ID0gdmFyaWFibGVbMF0gPT09ICdAJyB8fCB2YXJpYWJsZSA9PT0gJ3RoaXMnIHx8IGluU2NvcGUgfHwgdXBwZXJjYXNlO1xuXG4gICAgbGV0IHZhcmlhYmxlTG9jID0gbG9jLnNsaWNlU3RhcnRDaGFycyh7IHNraXBTdGFydDogMSwgY2hhcnM6IHZhcmlhYmxlLmxlbmd0aCB9KTtcblxuICAgIGxldCB0YWlsTGVuZ3RoID0gdGFpbC5yZWR1Y2UoKGFjY3VtLCBwYXJ0KSA9PiBhY2N1bSArIDEgKyBwYXJ0Lmxlbmd0aCwgMCk7XG4gICAgbGV0IHBhdGhFbmQgPSB2YXJpYWJsZUxvYy5nZXRFbmQoKS5tb3ZlKHRhaWxMZW5ndGgpO1xuICAgIGxldCBwYXRoTG9jID0gdmFyaWFibGVMb2Mud2l0aEVuZChwYXRoRW5kKTtcblxuICAgIGlmIChpc0NvbXBvbmVudCkge1xuICAgICAgLy8gSWYgdGhlIGNvbXBvbmVudCBuYW1lIGlzIHVwcGVyY2FzZSwgdGhlIHZhcmlhYmxlIGlzIG5vdCBpbiBzY29wZSxcbiAgICAgIC8vIGFuZCB0aGUgdGVtcGxhdGUgaXMgbm90IGluIHN0cmljdCBtb2RlLCBydW4gdGhlIG9wdGlvbmFsXG4gICAgICAvLyBgY3VzdG9taXplQ29tcG9uZW50TmFtZWAgZnVuY3Rpb24gcHJvdmlkZWQgYXMgYW4gb3B0aW9uIHRvIHRoZVxuICAgICAgLy8gcHJlY29tcGlsZXIuXG4gICAgICBpZiAoIXRoaXMuY3R4LnN0cmljdCAmJiB1cHBlcmNhc2UgJiYgIWluU2NvcGUpIHtcbiAgICAgICAgdmFyaWFibGUgPSB0aGlzLmN0eC5jdXN0b21pemVDb21wb25lbnROYW1lKHZhcmlhYmxlKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdGggPSBiLnBhdGgoe1xuICAgICAgICBoZWFkOiBiLmhlYWQodmFyaWFibGUsIHZhcmlhYmxlTG9jKSxcbiAgICAgICAgdGFpbCxcbiAgICAgICAgbG9jOiBwYXRoTG9jLFxuICAgICAgfSk7XG5cbiAgICAgIGxldCByZXNvbHV0aW9uID0gdGhpcy5jdHgucmVzb2x1dGlvbkZvcihwYXRoLCBDb21wb25lbnRTeW50YXhDb250ZXh0KTtcblxuICAgICAgaWYgKHJlc29sdXRpb24ucmVzb2x1dGlvbiA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBZb3UgYXR0ZW1wdGVkIHRvIGludm9rZSBhIHBhdGggKFxcYDwke3Jlc29sdXRpb24ucGF0aH0+XFxgKSBidXQgJHtyZXNvbHV0aW9uLmhlYWR9IHdhcyBub3QgaW4gc2NvcGVgLFxuICAgICAgICAgIGxvY1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IEV4cHJlc3Npb25Ob3JtYWxpemVyKHRoaXMuY3R4KS5ub3JtYWxpemUocGF0aCwgcmVzb2x1dGlvbi5yZXNvbHV0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdGFnIG5hbWUgd2Fzbid0IGEgdmFsaWQgY29tcG9uZW50IGJ1dCBjb250YWluZWQgYSBgLmAsIGl0J3NcbiAgICAvLyBhIHN5bnRheCBlcnJvci5cbiAgICBpZiAodGFpbC5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgWW91IHVzZWQgJHt2YXJpYWJsZX0uJHt0YWlsLmpvaW4oJy4nKX0gYXMgYSB0YWcgbmFtZSwgYnV0ICR7dmFyaWFibGV9IGlzIG5vdCBpbiBzY29wZWAsXG4gICAgICAgIGxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ0VsZW1lbnRIZWFkJztcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGV4cHIoKTogRXhwcmVzc2lvbk5vcm1hbGl6ZXIge1xuICAgIHJldHVybiBuZXcgRXhwcmVzc2lvbk5vcm1hbGl6ZXIodGhpcy5jdHgpO1xuICB9XG59XG5cbmNsYXNzIENoaWxkcmVuIHtcbiAgcmVhZG9ubHkgbmFtZWRCbG9ja3M6IEFTVHYyLk5hbWVkQmxvY2tbXTtcbiAgcmVhZG9ubHkgaGFzU2VtYW50aWNDb250ZW50OiBib29sZWFuO1xuICByZWFkb25seSBub25CbG9ja0NoaWxkcmVuOiBBU1R2Mi5Db250ZW50Tm9kZVtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGxvYzogU291cmNlU3BhbixcbiAgICByZWFkb25seSBjaGlsZHJlbjogKEFTVHYyLkNvbnRlbnROb2RlIHwgQVNUdjIuTmFtZWRCbG9jaylbXSxcbiAgICByZWFkb25seSBibG9jazogQmxvY2tDb250ZXh0XG4gICkge1xuICAgIHRoaXMubmFtZWRCbG9ja3MgPSBjaGlsZHJlbi5maWx0ZXIoKGMpOiBjIGlzIEFTVHYyLk5hbWVkQmxvY2sgPT4gYyBpbnN0YW5jZW9mIEFTVHYyLk5hbWVkQmxvY2spO1xuICAgIHRoaXMuaGFzU2VtYW50aWNDb250ZW50ID0gQm9vbGVhbihcbiAgICAgIGNoaWxkcmVuLmZpbHRlcigoYyk6IGMgaXMgQVNUdjIuQ29udGVudE5vZGUgPT4ge1xuICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIEFTVHYyLk5hbWVkQmxvY2spIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdHbGltbWVyQ29tbWVudCc6XG4gICAgICAgICAgY2FzZSAnSHRtbENvbW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNhc2UgJ0h0bWxUZXh0JzpcbiAgICAgICAgICAgIHJldHVybiAhL15cXHMqJC8uZXhlYyhjLmNoYXJzKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pLmxlbmd0aFxuICAgICk7XG4gICAgdGhpcy5ub25CbG9ja0NoaWxkcmVuID0gY2hpbGRyZW4uZmlsdGVyKFxuICAgICAgKGMpOiBjIGlzIEFTVHYyLkNvbnRlbnROb2RlID0+ICEoYyBpbnN0YW5jZW9mIEFTVHYyLk5hbWVkQmxvY2spXG4gICAgKTtcbiAgfVxufVxuXG5jbGFzcyBUZW1wbGF0ZUNoaWxkcmVuIGV4dGVuZHMgQ2hpbGRyZW4ge1xuICBhc3NlcnRUZW1wbGF0ZSh0YWJsZTogUHJvZ3JhbVN5bWJvbFRhYmxlKTogQVNUdjIuVGVtcGxhdGUge1xuICAgIGlmIChpc1ByZXNlbnQodGhpcy5uYW1lZEJsb2NrcykpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgbmFtZWQgYmxvY2sgYXQgdGhlIHRvcC1sZXZlbCBvZiBhIHRlbXBsYXRlYCwgdGhpcy5sb2MpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmJsb2NrLmJ1aWxkZXIudGVtcGxhdGUodGFibGUsIHRoaXMubm9uQmxvY2tDaGlsZHJlbiwgdGhpcy5ibG9jay5sb2ModGhpcy5sb2MpKTtcbiAgfVxufVxuXG5jbGFzcyBCbG9ja0NoaWxkcmVuIGV4dGVuZHMgQ2hpbGRyZW4ge1xuICBhc3NlcnRCbG9jayh0YWJsZTogQmxvY2tTeW1ib2xUYWJsZSk6IEFTVHYyLkJsb2NrIHtcbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKGBVbmV4cGVjdGVkIG5hbWVkIGJsb2NrIG5lc3RlZCBpbiBhIG5vcm1hbCBibG9ja2AsIHRoaXMubG9jKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLmJsb2NrKHRhYmxlLCB0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIHRoaXMubG9jKTtcbiAgfVxufVxuXG5jbGFzcyBFbGVtZW50Q2hpbGRyZW4gZXh0ZW5kcyBDaGlsZHJlbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZWw6IEJ1aWxkRWxlbWVudCxcbiAgICBsb2M6IFNvdXJjZVNwYW4sXG4gICAgY2hpbGRyZW46IChBU1R2Mi5Db250ZW50Tm9kZSB8IEFTVHYyLk5hbWVkQmxvY2spW10sXG4gICAgYmxvY2s6IEJsb2NrQ29udGV4dFxuICApIHtcbiAgICBzdXBlcihsb2MsIGNoaWxkcmVuLCBibG9jayk7XG4gIH1cblxuICBhc3NlcnROYW1lZEJsb2NrKG5hbWU6IFNvdXJjZVNsaWNlLCB0YWJsZTogQmxvY2tTeW1ib2xUYWJsZSk6IEFTVHYyLk5hbWVkQmxvY2sge1xuICAgIGlmICh0aGlzLmVsLmJhc2Uuc2VsZkNsb3NpbmcpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIGA8OiR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIG5hbWVkIGJsb2NrOiBuYW1lZCBibG9ja3MgY2Fubm90IGJlIHNlbGYtY2xvc2luZ2AsXG4gICAgICAgIHRoaXMubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChpc1ByZXNlbnQodGhpcy5uYW1lZEJsb2NrcykpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIGBVbmV4cGVjdGVkIG5hbWVkIGJsb2NrIGluc2lkZSA8OiR7bmFtZX0+IG5hbWVkIGJsb2NrOiBuYW1lZCBibG9ja3MgY2Fubm90IGNvbnRhaW4gbmVzdGVkIG5hbWVkIGJsb2Nrc2AsXG4gICAgICAgIHRoaXMubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNMb3dlckNhc2UobmFtZS5jaGFycykpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIGA8OiR7bmFtZX0+IGlzIG5vdCBhIHZhbGlkIG5hbWVkIGJsb2NrOiBcXGAke25hbWV9XFxgIGlzIHVwcGVyY2FzZSwgYW5kIG5hbWVkIGJsb2NrcyBtdXN0IGJlIGxvd2VyY2FzZWAsXG4gICAgICAgIHRoaXMubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBvZmZzZXRzID0gU3Bhbkxpc3QucmFuZ2UodGhpcy5ub25CbG9ja0NoaWxkcmVuLCB0aGlzLmxvYyk7XG5cbiAgICByZXR1cm4gdGhpcy5ibG9jay5idWlsZGVyLm5hbWVkQmxvY2soXG4gICAgICBuYW1lLFxuICAgICAgdGhpcy5ibG9jay5idWlsZGVyLmJsb2NrKHRhYmxlLCB0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIG9mZnNldHMpLFxuICAgICAgdGhpcy5sb2NcbiAgICApO1xuICB9XG5cbiAgYXNzZXJ0RWxlbWVudChuYW1lOiBTb3VyY2VTbGljZSwgaGFzQmxvY2tQYXJhbXM6IGJvb2xlYW4pOiBBU1R2Mi5TaW1wbGVFbGVtZW50IHtcbiAgICBpZiAoaGFzQmxvY2tQYXJhbXMpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIGBVbmV4cGVjdGVkIGJsb2NrIHBhcmFtcyBpbiA8JHtuYW1lfT46IHNpbXBsZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSBibG9jayBwYXJhbXNgLFxuICAgICAgICB0aGlzLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpKSB7XG4gICAgICBsZXQgbmFtZXMgPSB0aGlzLm5hbWVkQmxvY2tzLm1hcCgoYikgPT4gYi5uYW1lKTtcblxuICAgICAgaWYgKG5hbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBTeW50YXggRXJyb3I6IFVuZXhwZWN0ZWQgbmFtZWQgYmxvY2sgPDpmb28+IGluc2lkZSA8JHtuYW1lfT4gSFRNTCBlbGVtZW50YCxcbiAgICAgICAgICB0aGlzLmxvY1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHByaW50ZWROYW1lcyA9IG5hbWVzLm1hcCgobikgPT4gYDw6JHtuLmNoYXJzfT5gKS5qb2luKCcsICcpO1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBTeW50YXggRXJyb3I6IFVuZXhwZWN0ZWQgbmFtZWQgYmxvY2tzIGluc2lkZSA8JHtuYW1lfT4gSFRNTCBlbGVtZW50ICgke3ByaW50ZWROYW1lc30pYCxcbiAgICAgICAgICB0aGlzLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVsLnNpbXBsZShuYW1lLCB0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIHRoaXMubG9jKTtcbiAgfVxuXG4gIGFzc2VydENvbXBvbmVudChcbiAgICBuYW1lOiBzdHJpbmcsXG4gICAgdGFibGU6IEJsb2NrU3ltYm9sVGFibGUsXG4gICAgaGFzQmxvY2tQYXJhbXM6IGJvb2xlYW5cbiAgKTogUHJlc2VudEFycmF5PEFTVHYyLk5hbWVkQmxvY2s+IHtcbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpICYmIHRoaXMuaGFzU2VtYW50aWNDb250ZW50KSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZCBjb250ZW50IGluc2lkZSA8JHtuYW1lfT4gY29tcG9uZW50IGludm9jYXRpb246IHdoZW4gdXNpbmcgbmFtZWQgYmxvY2tzLCB0aGUgdGFnIGNhbm5vdCBjb250YWluIG90aGVyIGNvbnRlbnRgLFxuICAgICAgICB0aGlzLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoaXNQcmVzZW50KHRoaXMubmFtZWRCbG9ja3MpKSB7XG4gICAgICBpZiAoaGFzQmxvY2tQYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgVW5leHBlY3RlZCBibG9jayBwYXJhbXMgbGlzdCBvbiA8JHtuYW1lfT4gY29tcG9uZW50IGludm9jYXRpb246IHdoZW4gcGFzc2luZyBuYW1lZCBibG9ja3MsIHRoZSBpbnZvY2F0aW9uIHRhZyBjYW5ub3QgdGFrZSBibG9jayBwYXJhbXNgLFxuICAgICAgICAgIHRoaXMubG9jXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5uYW1lZEJsb2NrcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5ibG9jay5idWlsZGVyLm5hbWVkQmxvY2soXG4gICAgICAgICAgU291cmNlU2xpY2Uuc3ludGhldGljKCdkZWZhdWx0JyksXG4gICAgICAgICAgdGhpcy5ibG9jay5idWlsZGVyLmJsb2NrKHRhYmxlLCB0aGlzLm5vbkJsb2NrQ2hpbGRyZW4sIHRoaXMubG9jKSxcbiAgICAgICAgICB0aGlzLmxvY1xuICAgICAgICApLFxuICAgICAgXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVcHBlckNhc2UodGFnOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRhZ1swXSA9PT0gdGFnWzBdLnRvVXBwZXJDYXNlKCkgJiYgdGFnWzBdICE9PSB0YWdbMF0udG9Mb3dlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gaXNMb3dlckNhc2UodGFnOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRhZ1swXSA9PT0gdGFnWzBdLnRvTG93ZXJDYXNlKCkgJiYgdGFnWzBdICE9PSB0YWdbMF0udG9VcHBlckNhc2UoKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRQYXRoKG5vZGU6IEFTVHYxLlBhdGhFeHByZXNzaW9uIHwgQVNUdjEuQ2FsbE5vZGUpOiBzdHJpbmcge1xuICBpZiAobm9kZS50eXBlICE9PSAnUGF0aEV4cHJlc3Npb24nICYmIG5vZGUucGF0aC50eXBlID09PSAnUGF0aEV4cHJlc3Npb24nKSB7XG4gICAgcmV0dXJuIHByaW50UGF0aChub2RlLnBhdGgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgUHJpbnRlcih7IGVudGl0eUVuY29kaW5nOiAncmF3JyB9KS5wcmludChub2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludEhlYWQobm9kZTogQVNUdjEuUGF0aEV4cHJlc3Npb24gfCBBU1R2MS5DYWxsTm9kZSk6IHN0cmluZyB7XG4gIGlmIChub2RlLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICBzd2l0Y2ggKG5vZGUuaGVhZC50eXBlKSB7XG4gICAgICBjYXNlICdBdEhlYWQnOlxuICAgICAgY2FzZSAnVmFySGVhZCc6XG4gICAgICAgIHJldHVybiBub2RlLmhlYWQubmFtZTtcbiAgICAgIGNhc2UgJ1RoaXNIZWFkJzpcbiAgICAgICAgcmV0dXJuICd0aGlzJztcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZS5wYXRoLnR5cGUgPT09ICdQYXRoRXhwcmVzc2lvbicpIHtcbiAgICByZXR1cm4gcHJpbnRIZWFkKG5vZGUucGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBQcmludGVyKHsgZW50aXR5RW5jb2Rpbmc6ICdyYXcnIH0pLnByaW50KG5vZGUpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9