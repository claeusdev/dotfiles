"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HandlebarsNodeVisitors = void 0;

var _parser = require("../parser");

var _location = require("../source/location");

var _syntaxError = require("../syntax-error");

var _utils = require("../utils");

var _legacyInterop = require("../v1/legacy-interop");

var _parserBuilders = _interopRequireDefault(require("../v1/parser-builders"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var HandlebarsNodeVisitors = /*#__PURE__*/function (_Parser) {
  _inheritsLoose(HandlebarsNodeVisitors, _Parser);

  function HandlebarsNodeVisitors() {
    return _Parser.apply(this, arguments) || this;
  }

  var _proto = HandlebarsNodeVisitors.prototype;

  _proto.Program = function Program(program) {
    var body = [];
    var node;

    if (this.isTopLevel) {
      node = _parserBuilders.default.template({
        body: body,
        blockParams: program.blockParams,
        loc: this.source.spanFor(program.loc)
      });
    } else {
      node = _parserBuilders.default.blockItself({
        body: body,
        blockParams: program.blockParams,
        chained: program.chained,
        loc: this.source.spanFor(program.loc)
      });
    }

    var i,
        l = program.body.length;
    this.elementStack.push(node);

    if (l === 0) {
      return this.elementStack.pop();
    }

    for (i = 0; i < l; i++) {
      this.acceptNode(program.body[i]);
    } // Ensure that that the element stack is balanced properly.


    var poppedNode = this.elementStack.pop();

    if (poppedNode !== node) {
      var elementNode = poppedNode;
      throw (0, _syntaxError.generateSyntaxError)("Unclosed element `" + elementNode.tag + "`", elementNode.loc);
    }

    return node;
  };

  _proto.BlockStatement = function BlockStatement(block) {
    if (this.tokenizer.state === "comment"
    /* comment */
    ) {
        this.appendToCommentData(this.sourceForNode(block));
        return;
      }

    if (this.tokenizer.state !== "data"
    /* data */
    && this.tokenizer.state !== "beforeData"
    /* beforeData */
    ) {
        throw (0, _syntaxError.generateSyntaxError)('A block may only be used inside an HTML element or another block.', this.source.spanFor(block.loc));
      }

    var _acceptCallNodes = acceptCallNodes(this, block),
        path = _acceptCallNodes.path,
        params = _acceptCallNodes.params,
        hash = _acceptCallNodes.hash; // These are bugs in Handlebars upstream


    if (!block.program.loc) {
      block.program.loc = _location.NON_EXISTENT_LOCATION;
    }

    if (block.inverse && !block.inverse.loc) {
      block.inverse.loc = _location.NON_EXISTENT_LOCATION;
    }

    var program = this.Program(block.program);
    var inverse = block.inverse ? this.Program(block.inverse) : null;

    var node = _parserBuilders.default.block({
      path: path,
      params: params,
      hash: hash,
      defaultBlock: program,
      elseBlock: inverse,
      loc: this.source.spanFor(block.loc),
      openStrip: block.openStrip,
      inverseStrip: block.inverseStrip,
      closeStrip: block.closeStrip
    });

    var parentProgram = this.currentElement();
    (0, _utils.appendChild)(parentProgram, node);
  };

  _proto.MustacheStatement = function MustacheStatement(rawMustache) {
    var tokenizer = this.tokenizer;

    if (tokenizer.state === 'comment') {
      this.appendToCommentData(this.sourceForNode(rawMustache));
      return;
    }

    var mustache;
    var escaped = rawMustache.escaped,
        loc = rawMustache.loc,
        strip = rawMustache.strip;

    if ((0, _utils.isHBSLiteral)(rawMustache.path)) {
      mustache = _parserBuilders.default.mustache({
        path: this.acceptNode(rawMustache.path),
        params: [],
        hash: _parserBuilders.default.hash([], this.source.spanFor(rawMustache.path.loc).collapse('end')),
        trusting: !escaped,
        loc: this.source.spanFor(loc),
        strip: strip
      });
    } else {
      var _acceptCallNodes2 = acceptCallNodes(this, rawMustache),
          path = _acceptCallNodes2.path,
          params = _acceptCallNodes2.params,
          hash = _acceptCallNodes2.hash;

      mustache = _parserBuilders.default.mustache({
        path: path,
        params: params,
        hash: hash,
        trusting: !escaped,
        loc: this.source.spanFor(loc),
        strip: strip
      });
    }

    switch (tokenizer.state) {
      // Tag helpers
      case "tagOpen"
      /* tagOpen */
      :
      case "tagName"
      /* tagName */
      :
        throw (0, _syntaxError.generateSyntaxError)("Cannot use mustaches in an elements tagname", mustache.loc);

      case "beforeAttributeName"
      /* beforeAttributeName */
      :
        addElementModifier(this.currentStartTag, mustache);
        break;

      case "attributeName"
      /* attributeName */
      :
      case "afterAttributeName"
      /* afterAttributeName */
      :
        this.beginAttributeValue(false);
        this.finishAttributeValue();
        addElementModifier(this.currentStartTag, mustache);
        tokenizer.transitionTo("beforeAttributeName"
        /* beforeAttributeName */
        );
        break;

      case "afterAttributeValueQuoted"
      /* afterAttributeValueQuoted */
      :
        addElementModifier(this.currentStartTag, mustache);
        tokenizer.transitionTo("beforeAttributeName"
        /* beforeAttributeName */
        );
        break;
      // Attribute values

      case "beforeAttributeValue"
      /* beforeAttributeValue */
      :
        this.beginAttributeValue(false);
        this.appendDynamicAttributeValuePart(mustache);
        tokenizer.transitionTo("attributeValueUnquoted"
        /* attributeValueUnquoted */
        );
        break;

      case "attributeValueDoubleQuoted"
      /* attributeValueDoubleQuoted */
      :
      case "attributeValueSingleQuoted"
      /* attributeValueSingleQuoted */
      :
      case "attributeValueUnquoted"
      /* attributeValueUnquoted */
      :
        this.appendDynamicAttributeValuePart(mustache);
        break;
      // TODO: Only append child when the tokenizer state makes
      // sense to do so, otherwise throw an error.

      default:
        (0, _utils.appendChild)(this.currentElement(), mustache);
    }

    return mustache;
  };

  _proto.appendDynamicAttributeValuePart = function appendDynamicAttributeValuePart(part) {
    this.finalizeTextPart();
    var attr = this.currentAttr;
    attr.isDynamic = true;
    attr.parts.push(part);
  };

  _proto.finalizeTextPart = function finalizeTextPart() {
    var attr = this.currentAttr;
    var text = attr.currentPart;

    if (text !== null) {
      this.currentAttr.parts.push(text);
      this.startTextPart();
    }
  };

  _proto.startTextPart = function startTextPart() {
    this.currentAttr.currentPart = null;
  };

  _proto.ContentStatement = function ContentStatement(content) {
    updateTokenizerLocation(this.tokenizer, content);
    this.tokenizer.tokenizePart(content.value);
    this.tokenizer.flushData();
  };

  _proto.CommentStatement = function CommentStatement(rawComment) {
    var tokenizer = this.tokenizer;

    if (tokenizer.state === "comment"
    /* comment */
    ) {
        this.appendToCommentData(this.sourceForNode(rawComment));
        return null;
      }

    var value = rawComment.value,
        loc = rawComment.loc;

    var comment = _parserBuilders.default.mustacheComment(value, this.source.spanFor(loc));

    switch (tokenizer.state) {
      case "beforeAttributeName"
      /* beforeAttributeName */
      :
        this.currentStartTag.comments.push(comment);
        break;

      case "beforeData"
      /* beforeData */
      :
      case "data"
      /* data */
      :
        (0, _utils.appendChild)(this.currentElement(), comment);
        break;

      default:
        throw (0, _syntaxError.generateSyntaxError)("Using a Handlebars comment when in the `" + tokenizer['state'] + "` state is not supported", this.source.spanFor(rawComment.loc));
    }

    return comment;
  };

  _proto.PartialStatement = function PartialStatement(partial) {
    throw (0, _syntaxError.generateSyntaxError)("Handlebars partials are not supported", this.source.spanFor(partial.loc));
  };

  _proto.PartialBlockStatement = function PartialBlockStatement(partialBlock) {
    throw (0, _syntaxError.generateSyntaxError)("Handlebars partial blocks are not supported", this.source.spanFor(partialBlock.loc));
  };

  _proto.Decorator = function Decorator(decorator) {
    throw (0, _syntaxError.generateSyntaxError)("Handlebars decorators are not supported", this.source.spanFor(decorator.loc));
  };

  _proto.DecoratorBlock = function DecoratorBlock(decoratorBlock) {
    throw (0, _syntaxError.generateSyntaxError)("Handlebars decorator blocks are not supported", this.source.spanFor(decoratorBlock.loc));
  };

  _proto.SubExpression = function SubExpression(sexpr) {
    var _acceptCallNodes3 = acceptCallNodes(this, sexpr),
        path = _acceptCallNodes3.path,
        params = _acceptCallNodes3.params,
        hash = _acceptCallNodes3.hash;

    return _parserBuilders.default.sexpr({
      path: path,
      params: params,
      hash: hash,
      loc: this.source.spanFor(sexpr.loc)
    });
  };

  _proto.PathExpression = function PathExpression(path) {
    var original = path.original;
    var parts;

    if (original.indexOf('/') !== -1) {
      if (original.slice(0, 2) === './') {
        throw (0, _syntaxError.generateSyntaxError)("Using \"./\" is not supported in Glimmer and unnecessary", this.source.spanFor(path.loc));
      }

      if (original.slice(0, 3) === '../') {
        throw (0, _syntaxError.generateSyntaxError)("Changing context using \"../\" is not supported in Glimmer", this.source.spanFor(path.loc));
      }

      if (original.indexOf('.') !== -1) {
        throw (0, _syntaxError.generateSyntaxError)("Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths", this.source.spanFor(path.loc));
      }

      parts = [path.parts.join('/')];
    } else if (original === '.') {
      throw (0, _syntaxError.generateSyntaxError)("'.' is not a supported path in Glimmer; check for a path with a trailing '.'", this.source.spanFor(path.loc));
    } else {
      parts = path.parts;
    }

    var thisHead = false; // This is to fix a bug in the Handlebars AST where the path expressions in
    // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
    // are simply turned into `{{foo}}`. The fix is to push it back onto the
    // parts array and let the runtime see the difference. However, we cannot
    // simply use the string `this` as it means literally the property called
    // "this" in the current context (it can be expressed in the syntax as
    // `{{[this]}}`, where the square bracket are generally for this kind of
    // escaping – such as `{{foo.["bar.baz"]}}` would mean lookup a property
    // named literally "bar.baz" on `this.foo`). By convention, we use `null`
    // for this purpose.

    if (original.match(/^this(\..+)?$/)) {
      thisHead = true;
    }

    var pathHead;

    if (thisHead) {
      pathHead = {
        type: 'ThisHead',
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + 4
          }
        }
      };
    } else if (path.data) {
      var head = parts.shift();

      if (head === undefined) {
        throw (0, _syntaxError.generateSyntaxError)("Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.", this.source.spanFor(path.loc));
      }

      pathHead = {
        type: 'AtHead',
        name: "@" + head,
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + head.length + 1
          }
        }
      };
    } else {
      var _head = parts.shift();

      if (_head === undefined) {
        throw (0, _syntaxError.generateSyntaxError)("Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.", this.source.spanFor(path.loc));
      }

      pathHead = {
        type: 'VarHead',
        name: _head,
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + _head.length
          }
        }
      };
    }

    return new _legacyInterop.PathExpressionImplV1(path.original, pathHead, parts, this.source.spanFor(path.loc));
  };

  _proto.Hash = function Hash(hash) {
    var pairs = [];

    for (var i = 0; i < hash.pairs.length; i++) {
      var pair = hash.pairs[i];
      pairs.push(_parserBuilders.default.pair({
        key: pair.key,
        value: this.acceptNode(pair.value),
        loc: this.source.spanFor(pair.loc)
      }));
    }

    return _parserBuilders.default.hash(pairs, this.source.spanFor(hash.loc));
  };

  _proto.StringLiteral = function StringLiteral(string) {
    return _parserBuilders.default.literal({
      type: 'StringLiteral',
      value: string.value,
      loc: string.loc
    });
  };

  _proto.BooleanLiteral = function BooleanLiteral(_boolean) {
    return _parserBuilders.default.literal({
      type: 'BooleanLiteral',
      value: _boolean.value,
      loc: _boolean.loc
    });
  };

  _proto.NumberLiteral = function NumberLiteral(number) {
    return _parserBuilders.default.literal({
      type: 'NumberLiteral',
      value: number.value,
      loc: number.loc
    });
  };

  _proto.UndefinedLiteral = function UndefinedLiteral(undef) {
    return _parserBuilders.default.literal({
      type: 'UndefinedLiteral',
      value: undefined,
      loc: undef.loc
    });
  };

  _proto.NullLiteral = function NullLiteral(nul) {
    return _parserBuilders.default.literal({
      type: 'NullLiteral',
      value: null,
      loc: nul.loc
    });
  };

  _createClass(HandlebarsNodeVisitors, [{
    key: "isTopLevel",
    get: function get() {
      return this.elementStack.length === 0;
    }
  }]);

  return HandlebarsNodeVisitors;
}(_parser.Parser);

exports.HandlebarsNodeVisitors = HandlebarsNodeVisitors;

function calculateRightStrippedOffsets(original, value) {
  if (value === '') {
    // if it is empty, just return the count of newlines
    // in original
    return {
      lines: original.split('\n').length - 1,
      columns: 0
    };
  } // otherwise, return the number of newlines prior to
  // `value`


  var difference = original.split(value)[0];
  var lines = difference.split(/\n/);
  var lineCount = lines.length - 1;
  return {
    lines: lineCount,
    columns: lines[lineCount].length
  };
}

function updateTokenizerLocation(tokenizer, content) {
  var line = content.loc.start.line;
  var column = content.loc.start.column;
  var offsets = calculateRightStrippedOffsets(content.original, content.value);
  line = line + offsets.lines;

  if (offsets.lines) {
    column = offsets.columns;
  } else {
    column = column + offsets.columns;
  }

  tokenizer.line = line;
  tokenizer.column = column;
}

function acceptCallNodes(compiler, node) {
  var path = compiler.PathExpression(node.path);
  var params = node.params ? node.params.map(function (e) {
    return compiler.acceptNode(e);
  }) : []; // if there is no hash, position it as a collapsed node immediately after the last param (or the
  // path, if there are also no params)

  var end = params.length > 0 ? params[params.length - 1].loc : path.loc;
  var hash = node.hash ? compiler.Hash(node.hash) : {
    type: 'Hash',
    pairs: [],
    loc: compiler.source.spanFor(end).collapse('end')
  };
  return {
    path: path,
    params: params,
    hash: hash
  };
}

function addElementModifier(element, mustache) {
  var path = mustache.path,
      params = mustache.params,
      hash = mustache.hash,
      loc = mustache.loc;

  if ((0, _utils.isHBSLiteral)(path)) {
    var _modifier = "{{" + (0, _utils.printLiteral)(path) + "}}";

    var tag = "<" + element.name + " ... " + _modifier + " ...";
    throw (0, _syntaxError.generateSyntaxError)("In " + tag + ", " + _modifier + " is not a valid modifier", mustache.loc);
  }

  var modifier = _parserBuilders.default.elementModifier({
    path: path,
    params: params,
    hash: hash,
    loc: loc
  });

  element.modifiers.push(modifier);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL2hhbmRsZWJhcnMtbm9kZS12aXNpdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTSxzQkFBTixHQUFBLGFBQUEsVUFBQSxPQUFBLEVBQUE7QUFBQSxFQUFBLGNBQUEsQ0FBQSxzQkFBQSxFQUFBLE9BQUEsQ0FBQTs7QUFBQSxXQUFBLHNCQUFBLEdBQUE7QUFBQSxXQUFBLE9BQUEsQ0FBQSxLQUFBLENBQUEsSUFBQSxFQUFBLFNBQUEsS0FBQSxJQUFBO0FBQUE7O0FBQUEsTUFBQSxNQUFBLEdBQUEsc0JBQUEsQ0FBQSxTQUFBOztBQUFBLEVBQUEsTUFBQSxDQUFBLE9BQUEsR0FZRSxTQUFBLE9BQUEsQ0FBQSxPQUFBLEVBQTRCO0FBQzFCLFFBQUksSUFBSSxHQUFSLEVBQUE7QUFDQSxRQUFBLElBQUE7O0FBRUEsUUFBSSxLQUFKLFVBQUEsRUFBcUI7QUFDbkIsTUFBQSxJQUFJLEdBQUcsd0JBQUEsUUFBQSxDQUFXO0FBQ2hCLFFBQUEsSUFEZ0IsRUFBQSxJQUFBO0FBRWhCLFFBQUEsV0FBVyxFQUFFLE9BQU8sQ0FGSixXQUFBO0FBR2hCLFFBQUEsR0FBRyxFQUFFLEtBQUEsTUFBQSxDQUFBLE9BQUEsQ0FBb0IsT0FBTyxDQUEzQixHQUFBO0FBSFcsT0FBWCxDQUFQO0FBREYsS0FBQSxNQU1PO0FBQ0wsTUFBQSxJQUFJLEdBQUcsd0JBQUEsV0FBQSxDQUFjO0FBQ25CLFFBQUEsSUFEbUIsRUFBQSxJQUFBO0FBRW5CLFFBQUEsV0FBVyxFQUFFLE9BQU8sQ0FGRCxXQUFBO0FBR25CLFFBQUEsT0FBTyxFQUFFLE9BQU8sQ0FIRyxPQUFBO0FBSW5CLFFBQUEsR0FBRyxFQUFFLEtBQUEsTUFBQSxDQUFBLE9BQUEsQ0FBb0IsT0FB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QUFQLE1BQUE7QUFFQSxVQUFNLHNDQUFtQixRQUFBLEdBQUEsR0FBQSxJQUFBLEdBQUEsU0FBQSxHQUFBLDBCQUFuQixFQUFzRSxRQUFRLENBQXBGLEdBQU0sQ0FBTjtBQUNEOztBQUVELE1BQUksUUFBUSxHQUFHLHdCQUFBLGVBQUEsQ0FBa0I7QUFBRSxJQUFBLElBQUYsRUFBQSxJQUFBO0FBQVEsSUFBQSxNQUFSLEVBQUEsTUFBQTtBQUFnQixJQUFBLElBQWhCLEVBQUEsSUFBQTtBQUFzQixJQUFBLEdBQUEsRUFBQTtBQUF0QixHQUFsQixDQUFmOztBQUNBLEVBQUEsT0FBTyxDQUFQLFNBQUEsQ0FBQSxJQUFBLENBQUEsUUFBQTtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3B0aW9uLCBSZWNhc3QgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFRva2VuaXplclN0YXRlIH0gZnJvbSAnc2ltcGxlLWh0bWwtdG9rZW5pemVyJztcblxuaW1wb3J0IHsgUGFyc2VyLCBQYXJzZXJOb2RlQnVpbGRlciwgVGFnIH0gZnJvbSAnLi4vcGFyc2VyJztcbmltcG9ydCB7IE5PTl9FWElTVEVOVF9MT0NBVElPTiB9IGZyb20gJy4uL3NvdXJjZS9sb2NhdGlvbic7XG5pbXBvcnQgeyBnZW5lcmF0ZVN5bnRheEVycm9yIH0gZnJvbSAnLi4vc3ludGF4LWVycm9yJztcbmltcG9ydCB7IGFwcGVuZENoaWxkLCBpc0hCU0xpdGVyYWwsIHByaW50TGl0ZXJhbCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIEFTVHYxIGZyb20gJy4uL3YxL2FwaSc7XG5pbXBvcnQgKiBhcyBIQlMgZnJvbSAnLi4vdjEvaGFuZGxlYmFycy1hc3QnO1xuaW1wb3J0IHsgUGF0aEV4cHJlc3Npb25JbXBsVjEgfSBmcm9tICcuLi92MS9sZWdhY3ktaW50ZXJvcCc7XG5pbXBvcnQgYiBmcm9tICcuLi92MS9wYXJzZXItYnVpbGRlcnMnO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSGFuZGxlYmFyc05vZGVWaXNpdG9ycyBleHRlbmRzIFBhcnNlciB7XG4gIGFic3RyYWN0IGFwcGVuZFRvQ29tbWVudERhdGEoczogc3RyaW5nKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5BdHRyaWJ1dGVWYWx1ZShxdW90ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hBdHRyaWJ1dGVWYWx1ZSgpOiB2b2lkO1xuXG4gIHByaXZhdGUgZ2V0IGlzVG9wTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YWNrLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIFByb2dyYW0ocHJvZ3JhbTogSEJTLlByb2dyYW0pOiBBU1R2MS5CbG9jaztcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVHYxLlRlbXBsYXRlO1xuICBQcm9ncmFtKHByb2dyYW06IEhCUy5Qcm9ncmFtKTogQVNUdjEuVGVtcGxhdGUgfCBBU1R2MS5CbG9jaztcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVHYxLkJsb2NrIHwgQVNUdjEuVGVtcGxhdGUge1xuICAgIGxldCBib2R5OiBBU1R2MS5TdGF0ZW1lbnRbXSA9IFtdO1xuICAgIGxldCBub2RlO1xuXG4gICAgaWYgKHRoaXMuaXNUb3BMZXZlbCkge1xuICAgICAgbm9kZSA9IGIudGVtcGxhdGUoe1xuICAgICAgICBib2R5LFxuICAgICAgICBibG9ja1BhcmFtczogcHJvZ3JhbS5ibG9ja1BhcmFtcyxcbiAgICAgICAgbG9jOiB0aGlzLnNvdXJjZS5zcGFuRm9yKHByb2dyYW0ubG9jKSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gYi5ibG9ja0l0c2VsZih7XG4gICAgICAgIGJvZHksXG4gICAgICAgIGJsb2NrUGFyYW1zOiBwcm9ncmFtLmJsb2NrUGFyYW1zLFxuICAgICAgICBjaGFpbmVkOiBwcm9ncmFtLmNoYWluZWQsXG4gICAgICAgIGxvYzogdGhpcy5zb3VyY2Uuc3BhbkZvcihwcm9ncmFtLmxvYyksXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgaSxcbiAgICAgIGwgPSBwcm9ncmFtLmJvZHkubGVuZ3RoO1xuXG4gICAgdGhpcy5lbGVtZW50U3RhY2sucHVzaChub2RlKTtcblxuICAgIGlmIChsID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50U3RhY2sucG9wKCkgYXMgQVNUdjEuQmxvY2sgfCBBU1R2MS5UZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLmFjY2VwdE5vZGUocHJvZ3JhbS5ib2R5W2ldKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGF0IHRoZSBlbGVtZW50IHN0YWNrIGlzIGJhbGFuY2VkIHByb3Blcmx5LlxuICAgIGxldCBwb3BwZWROb2RlID0gdGhpcy5lbGVtZW50U3RhY2sucG9wKCk7XG4gICAgaWYgKHBvcHBlZE5vZGUgIT09IG5vZGUpIHtcbiAgICAgIGxldCBlbGVtZW50Tm9kZSA9IHBvcHBlZE5vZGUgYXMgQVNUdjEuRWxlbWVudE5vZGU7XG5cbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoYFVuY2xvc2VkIGVsZW1lbnQgXFxgJHtlbGVtZW50Tm9kZS50YWd9XFxgYCwgZWxlbWVudE5vZGUubG9jKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIEJsb2NrU3RhdGVtZW50KGJsb2NrOiBIQlMuQmxvY2tTdGF0ZW1lbnQpOiBBU1R2MS5CbG9ja1N0YXRlbWVudCB8IHZvaWQge1xuICAgIGlmICh0aGlzLnRva2VuaXplci5zdGF0ZSA9PT0gVG9rZW5pemVyU3RhdGUuY29tbWVudCkge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShibG9jaykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHRoaXMudG9rZW5pemVyLnN0YXRlICE9PSBUb2tlbml6ZXJTdGF0ZS5kYXRhICYmXG4gICAgICB0aGlzLnRva2VuaXplci5zdGF0ZSAhPT0gVG9rZW5pemVyU3RhdGUuYmVmb3JlRGF0YVxuICAgICkge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgJ0EgYmxvY2sgbWF5IG9ubHkgYmUgdXNlZCBpbnNpZGUgYW4gSFRNTCBlbGVtZW50IG9yIGFub3RoZXIgYmxvY2suJyxcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcihibG9jay5sb2MpXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIGJsb2NrKTtcblxuICAgIC8vIFRoZXNlIGFyZSBidWdzIGluIEhhbmRsZWJhcnMgdXBzdHJlYW1cbiAgICBpZiAoIWJsb2NrLnByb2dyYW0ubG9jKSB7XG4gICAgICBibG9jay5wcm9ncmFtLmxvYyA9IE5PTl9FWElTVEVOVF9MT0NBVElPTjtcbiAgICB9XG5cbiAgICBpZiAoYmxvY2suaW52ZXJzZSAmJiAhYmxvY2suaW52ZXJzZS5sb2MpIHtcbiAgICAgIGJsb2NrLmludmVyc2UubG9jID0gTk9OX0VYSVNURU5UX0xPQ0FUSU9OO1xuICAgIH1cblxuICAgIGxldCBwcm9ncmFtID0gdGhpcy5Qcm9ncmFtKGJsb2NrLnByb2dyYW0pO1xuICAgIGxldCBpbnZlcnNlID0gYmxvY2suaW52ZXJzZSA/IHRoaXMuUHJvZ3JhbShibG9jay5pbnZlcnNlKSA6IG51bGw7XG5cbiAgICBsZXQgbm9kZSA9IGIuYmxvY2soe1xuICAgICAgcGF0aCxcbiAgICAgIHBhcmFtcyxcbiAgICAgIGhhc2gsXG4gICAgICBkZWZhdWx0QmxvY2s6IHByb2dyYW0sXG4gICAgICBlbHNlQmxvY2s6IGludmVyc2UsXG4gICAgICBsb2M6IHRoaXMuc291cmNlLnNwYW5Gb3IoYmxvY2subG9jKSxcbiAgICAgIG9wZW5TdHJpcDogYmxvY2sub3BlblN0cmlwLFxuICAgICAgaW52ZXJzZVN0cmlwOiBibG9jay5pbnZlcnNlU3RyaXAsXG4gICAgICBjbG9zZVN0cmlwOiBibG9jay5jbG9zZVN0cmlwLFxuICAgIH0pO1xuXG4gICAgbGV0IHBhcmVudFByb2dyYW0gPSB0aGlzLmN1cnJlbnRFbGVtZW50KCk7XG5cbiAgICBhcHBlbmRDaGlsZChwYXJlbnRQcm9ncmFtLCBub2RlKTtcbiAgfVxuXG4gIE11c3RhY2hlU3RhdGVtZW50KHJhd011c3RhY2hlOiBIQlMuTXVzdGFjaGVTdGF0ZW1lbnQpOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCB8IHZvaWQge1xuICAgIGxldCB7IHRva2VuaXplciB9ID0gdGhpcztcblxuICAgIGlmICh0b2tlbml6ZXIuc3RhdGUgPT09ICdjb21tZW50Jykge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShyYXdNdXN0YWNoZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBtdXN0YWNoZTogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQ7XG4gICAgbGV0IHsgZXNjYXBlZCwgbG9jLCBzdHJpcCB9ID0gcmF3TXVzdGFjaGU7XG5cbiAgICBpZiAoaXNIQlNMaXRlcmFsKHJhd011c3RhY2hlLnBhdGgpKSB7XG4gICAgICBtdXN0YWNoZSA9IGIubXVzdGFjaGUoe1xuICAgICAgICBwYXRoOiB0aGlzLmFjY2VwdE5vZGU8QVNUdjEuTGl0ZXJhbD4ocmF3TXVzdGFjaGUucGF0aCksXG4gICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIGhhc2g6IGIuaGFzaChbXSwgdGhpcy5zb3VyY2Uuc3BhbkZvcihyYXdNdXN0YWNoZS5wYXRoLmxvYykuY29sbGFwc2UoJ2VuZCcpKSxcbiAgICAgICAgdHJ1c3Rpbmc6ICFlc2NhcGVkLFxuICAgICAgICBsb2M6IHRoaXMuc291cmNlLnNwYW5Gb3IobG9jKSxcbiAgICAgICAgc3RyaXAsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoIH0gPSBhY2NlcHRDYWxsTm9kZXMoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHJhd011c3RhY2hlIGFzIEhCUy5NdXN0YWNoZVN0YXRlbWVudCAmIHtcbiAgICAgICAgICBwYXRoOiBIQlMuUGF0aEV4cHJlc3Npb247XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICBtdXN0YWNoZSA9IGIubXVzdGFjaGUoe1xuICAgICAgICBwYXRoLFxuICAgICAgICBwYXJhbXMsXG4gICAgICAgIGhhc2gsXG4gICAgICAgIHRydXN0aW5nOiAhZXNjYXBlZCxcbiAgICAgICAgbG9jOiB0aGlzLnNvdXJjZS5zcGFuRm9yKGxvYyksXG4gICAgICAgIHN0cmlwLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0b2tlbml6ZXIuc3RhdGUpIHtcbiAgICAgIC8vIFRhZyBoZWxwZXJzXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLnRhZ09wZW46XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLnRhZ05hbWU6XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoYENhbm5vdCB1c2UgbXVzdGFjaGVzIGluIGFuIGVsZW1lbnRzIHRhZ25hbWVgLCBtdXN0YWNoZS5sb2MpO1xuXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWU6XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlTmFtZTpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYWZ0ZXJBdHRyaWJ1dGVOYW1lOlxuICAgICAgICB0aGlzLmJlZ2luQXR0cmlidXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICB0aGlzLmZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk7XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYWZ0ZXJBdHRyaWJ1dGVWYWx1ZVF1b3RlZDpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBBdHRyaWJ1dGUgdmFsdWVzXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZVZhbHVlOlxuICAgICAgICB0aGlzLmJlZ2luQXR0cmlidXRlVmFsdWUoZmFsc2UpO1xuICAgICAgICB0aGlzLmFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQobXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlVW5xdW90ZWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZWQ6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVkOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVVucXVvdGVkOlxuICAgICAgICB0aGlzLmFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQobXVzdGFjaGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gVE9ETzogT25seSBhcHBlbmQgY2hpbGQgd2hlbiB0aGUgdG9rZW5pemVyIHN0YXRlIG1ha2VzXG4gICAgICAvLyBzZW5zZSB0byBkbyBzbywgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBtdXN0YWNoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG11c3RhY2hlO1xuICB9XG5cbiAgYXBwZW5kRHluYW1pY0F0dHJpYnV0ZVZhbHVlUGFydChwYXJ0OiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCk6IHZvaWQge1xuICAgIHRoaXMuZmluYWxpemVUZXh0UGFydCgpO1xuICAgIGxldCBhdHRyID0gdGhpcy5jdXJyZW50QXR0cjtcbiAgICBhdHRyLmlzRHluYW1pYyA9IHRydWU7XG4gICAgYXR0ci5wYXJ0cy5wdXNoKHBhcnQpO1xuICB9XG5cbiAgZmluYWxpemVUZXh0UGFydCgpOiB2b2lkIHtcbiAgICBsZXQgYXR0ciA9IHRoaXMuY3VycmVudEF0dHI7XG4gICAgbGV0IHRleHQgPSBhdHRyLmN1cnJlbnRQYXJ0O1xuICAgIGlmICh0ZXh0ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmN1cnJlbnRBdHRyLnBhcnRzLnB1c2godGV4dCk7XG4gICAgICB0aGlzLnN0YXJ0VGV4dFBhcnQoKTtcbiAgICB9XG4gIH1cblxuICBzdGFydFRleHRQYXJ0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudEF0dHIuY3VycmVudFBhcnQgPSBudWxsO1xuICB9XG5cbiAgQ29udGVudFN0YXRlbWVudChjb250ZW50OiBIQlMuQ29udGVudFN0YXRlbWVudCk6IHZvaWQge1xuICAgIHVwZGF0ZVRva2VuaXplckxvY2F0aW9uKHRoaXMudG9rZW5pemVyLCBjb250ZW50KTtcblxuICAgIHRoaXMudG9rZW5pemVyLnRva2VuaXplUGFydChjb250ZW50LnZhbHVlKTtcbiAgICB0aGlzLnRva2VuaXplci5mbHVzaERhdGEoKTtcbiAgfVxuXG4gIENvbW1lbnRTdGF0ZW1lbnQocmF3Q29tbWVudDogSEJTLkNvbW1lbnRTdGF0ZW1lbnQpOiBPcHRpb248QVNUdjEuTXVzdGFjaGVDb21tZW50U3RhdGVtZW50PiB7XG4gICAgbGV0IHsgdG9rZW5pemVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRva2VuaXplci5zdGF0ZSA9PT0gVG9rZW5pemVyU3RhdGUuY29tbWVudCkge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShyYXdDb21tZW50KSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgeyB2YWx1ZSwgbG9jIH0gPSByYXdDb21tZW50O1xuICAgIGxldCBjb21tZW50ID0gYi5tdXN0YWNoZUNvbW1lbnQodmFsdWUsIHRoaXMuc291cmNlLnNwYW5Gb3IobG9jKSk7XG5cbiAgICBzd2l0Y2ggKHRva2VuaXplci5zdGF0ZSkge1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lOlxuICAgICAgICB0aGlzLmN1cnJlbnRTdGFydFRhZy5jb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVEYXRhOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5kYXRhOlxuICAgICAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIGNvbW1lbnQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgVXNpbmcgYSBIYW5kbGViYXJzIGNvbW1lbnQgd2hlbiBpbiB0aGUgXFxgJHt0b2tlbml6ZXJbJ3N0YXRlJ119XFxgIHN0YXRlIGlzIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocmF3Q29tbWVudC5sb2MpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbW1lbnQ7XG4gIH1cblxuICBQYXJ0aWFsU3RhdGVtZW50KHBhcnRpYWw6IEhCUy5QYXJ0aWFsU3RhdGVtZW50KTogbmV2ZXIge1xuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBwYXJ0aWFscyBhcmUgbm90IHN1cHBvcnRlZGAsXG4gICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhcnRpYWwubG9jKVxuICAgICk7XG4gIH1cblxuICBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQocGFydGlhbEJsb2NrOiBIQlMuUGFydGlhbEJsb2NrU3RhdGVtZW50KTogbmV2ZXIge1xuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBwYXJ0aWFsIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZGAsXG4gICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhcnRpYWxCbG9jay5sb2MpXG4gICAgKTtcbiAgfVxuXG4gIERlY29yYXRvcihkZWNvcmF0b3I6IEhCUy5EZWNvcmF0b3IpOiBuZXZlciB7XG4gICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgIGBIYW5kbGViYXJzIGRlY29yYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcihkZWNvcmF0b3IubG9jKVxuICAgICk7XG4gIH1cblxuICBEZWNvcmF0b3JCbG9jayhkZWNvcmF0b3JCbG9jazogSEJTLkRlY29yYXRvckJsb2NrKTogbmV2ZXIge1xuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBkZWNvcmF0b3IgYmxvY2tzIGFyZSBub3Qgc3VwcG9ydGVkYCxcbiAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IoZGVjb3JhdG9yQmxvY2subG9jKVxuICAgICk7XG4gIH1cblxuICBTdWJFeHByZXNzaW9uKHNleHByOiBIQlMuU3ViRXhwcmVzc2lvbik6IEFTVHYxLlN1YkV4cHJlc3Npb24ge1xuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIHNleHByKTtcbiAgICByZXR1cm4gYi5zZXhwcih7IHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jOiB0aGlzLnNvdXJjZS5zcGFuRm9yKHNleHByLmxvYykgfSk7XG4gIH1cblxuICBQYXRoRXhwcmVzc2lvbihwYXRoOiBIQlMuUGF0aEV4cHJlc3Npb24pOiBBU1R2MS5QYXRoRXhwcmVzc2lvbiB7XG4gICAgbGV0IHsgb3JpZ2luYWwgfSA9IHBhdGg7XG4gICAgbGV0IHBhcnRzOiBzdHJpbmdbXTtcblxuICAgIGlmIChvcmlnaW5hbC5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICBpZiAob3JpZ2luYWwuc2xpY2UoMCwgMikgPT09ICcuLycpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgVXNpbmcgXCIuL1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lciBhbmQgdW5uZWNlc3NhcnlgLFxuICAgICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWwuc2xpY2UoMCwgMykgPT09ICcuLi8nKSB7XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYENoYW5naW5nIGNvbnRleHQgdXNpbmcgXCIuLi9cIiBpcyBub3Qgc3VwcG9ydGVkIGluIEdsaW1tZXJgLFxuICAgICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWwuaW5kZXhPZignLicpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBNaXhpbmcgJy4nIGFuZCAnLycgaW4gcGF0aHMgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOyB1c2Ugb25seSAnLicgdG8gc2VwYXJhdGUgcHJvcGVydHkgcGF0aHNgLFxuICAgICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwYXJ0cyA9IFtwYXRoLnBhcnRzLmpvaW4oJy8nKV07XG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbCA9PT0gJy4nKSB7XG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICBgJy4nIGlzIG5vdCBhIHN1cHBvcnRlZCBwYXRoIGluIEdsaW1tZXI7IGNoZWNrIGZvciBhIHBhdGggd2l0aCBhIHRyYWlsaW5nICcuJ2AsXG4gICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cyA9IHBhdGgucGFydHM7XG4gICAgfVxuXG4gICAgbGV0IHRoaXNIZWFkID0gZmFsc2U7XG5cbiAgICAvLyBUaGlzIGlzIHRvIGZpeCBhIGJ1ZyBpbiB0aGUgSGFuZGxlYmFycyBBU1Qgd2hlcmUgdGhlIHBhdGggZXhwcmVzc2lvbnMgaW5cbiAgICAvLyBge3t0aGlzLmZvb319YCAoYW5kIHNpbWlsYXJseSBge3tmb28tYmFyIHRoaXMuZm9vIG5hbWVkPXRoaXMuZm9vfX1gIGV0YylcbiAgICAvLyBhcmUgc2ltcGx5IHR1cm5lZCBpbnRvIGB7e2Zvb319YC4gVGhlIGZpeCBpcyB0byBwdXNoIGl0IGJhY2sgb250byB0aGVcbiAgICAvLyBwYXJ0cyBhcnJheSBhbmQgbGV0IHRoZSBydW50aW1lIHNlZSB0aGUgZGlmZmVyZW5jZS4gSG93ZXZlciwgd2UgY2Fubm90XG4gICAgLy8gc2ltcGx5IHVzZSB0aGUgc3RyaW5nIGB0aGlzYCBhcyBpdCBtZWFucyBsaXRlcmFsbHkgdGhlIHByb3BlcnR5IGNhbGxlZFxuICAgIC8vIFwidGhpc1wiIGluIHRoZSBjdXJyZW50IGNvbnRleHQgKGl0IGNhbiBiZSBleHByZXNzZWQgaW4gdGhlIHN5bnRheCBhc1xuICAgIC8vIGB7e1t0aGlzXX19YCwgd2hlcmUgdGhlIHNxdWFyZSBicmFja2V0IGFyZSBnZW5lcmFsbHkgZm9yIHRoaXMga2luZCBvZlxuICAgIC8vIGVzY2FwaW5nIOKAkyBzdWNoIGFzIGB7e2Zvby5bXCJiYXIuYmF6XCJdfX1gIHdvdWxkIG1lYW4gbG9va3VwIGEgcHJvcGVydHlcbiAgICAvLyBuYW1lZCBsaXRlcmFsbHkgXCJiYXIuYmF6XCIgb24gYHRoaXMuZm9vYCkuIEJ5IGNvbnZlbnRpb24sIHdlIHVzZSBgbnVsbGBcbiAgICAvLyBmb3IgdGhpcyBwdXJwb3NlLlxuICAgIGlmIChvcmlnaW5hbC5tYXRjaCgvXnRoaXMoXFwuLispPyQvKSkge1xuICAgICAgdGhpc0hlYWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGxldCBwYXRoSGVhZDogQVNUdjEuUGF0aEhlYWQ7XG4gICAgaWYgKHRoaXNIZWFkKSB7XG4gICAgICBwYXRoSGVhZCA9IHtcbiAgICAgICAgdHlwZTogJ1RoaXNIZWFkJyxcbiAgICAgICAgbG9jOiB7XG4gICAgICAgICAgc3RhcnQ6IHBhdGgubG9jLnN0YXJ0LFxuICAgICAgICAgIGVuZDogeyBsaW5lOiBwYXRoLmxvYy5zdGFydC5saW5lLCBjb2x1bW46IHBhdGgubG9jLnN0YXJ0LmNvbHVtbiArIDQgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwYXRoLmRhdGEpIHtcbiAgICAgIGxldCBoZWFkID0gcGFydHMuc2hpZnQoKTtcblxuICAgICAgaWYgKGhlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcGFyc2UgYSBwYXRoIGV4cHJlc3Npb24sIGJ1dCBpdCB3YXMgbm90IHZhbGlkLiBQYXRocyBiZWdpbm5pbmcgd2l0aCBAIG11c3Qgc3RhcnQgd2l0aCBhLXouYCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBwYXRoSGVhZCA9IHtcbiAgICAgICAgdHlwZTogJ0F0SGVhZCcsXG4gICAgICAgIG5hbWU6IGBAJHtoZWFkfWAsXG4gICAgICAgIGxvYzoge1xuICAgICAgICAgIHN0YXJ0OiBwYXRoLmxvYy5zdGFydCxcbiAgICAgICAgICBlbmQ6IHsgbGluZTogcGF0aC5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoLmxvYy5zdGFydC5jb2x1bW4gKyBoZWFkLmxlbmd0aCArIDEgfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBoZWFkID0gcGFydHMuc2hpZnQoKTtcblxuICAgICAgaWYgKGhlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBBdHRlbXB0ZWQgdG8gcGFyc2UgYSBwYXRoIGV4cHJlc3Npb24sIGJ1dCBpdCB3YXMgbm90IHZhbGlkLiBQYXRocyBtdXN0IHN0YXJ0IHdpdGggYS16IG9yIEEtWi5gLFxuICAgICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHBhdGhIZWFkID0ge1xuICAgICAgICB0eXBlOiAnVmFySGVhZCcsXG4gICAgICAgIG5hbWU6IGhlYWQsXG4gICAgICAgIGxvYzoge1xuICAgICAgICAgIHN0YXJ0OiBwYXRoLmxvYy5zdGFydCxcbiAgICAgICAgICBlbmQ6IHsgbGluZTogcGF0aC5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoLmxvYy5zdGFydC5jb2x1bW4gKyBoZWFkLmxlbmd0aCB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBhdGhFeHByZXNzaW9uSW1wbFYxKHBhdGgub3JpZ2luYWwsIHBhdGhIZWFkLCBwYXJ0cywgdGhpcy5zb3VyY2Uuc3BhbkZvcihwYXRoLmxvYykpO1xuICB9XG5cbiAgSGFzaChoYXNoOiBIQlMuSGFzaCk6IEFTVHYxLkhhc2gge1xuICAgIGxldCBwYWlyczogQVNUdjEuSGFzaFBhaXJbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYXNoLnBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcGFpciA9IGhhc2gucGFpcnNbaV07XG4gICAgICBwYWlycy5wdXNoKFxuICAgICAgICBiLnBhaXIoe1xuICAgICAgICAgIGtleTogcGFpci5rZXksXG4gICAgICAgICAgdmFsdWU6IHRoaXMuYWNjZXB0Tm9kZShwYWlyLnZhbHVlKSxcbiAgICAgICAgICBsb2M6IHRoaXMuc291cmNlLnNwYW5Gb3IocGFpci5sb2MpLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYi5oYXNoKHBhaXJzLCB0aGlzLnNvdXJjZS5zcGFuRm9yKGhhc2gubG9jKSk7XG4gIH1cblxuICBTdHJpbmdMaXRlcmFsKHN0cmluZzogSEJTLlN0cmluZ0xpdGVyYWwpOiBBU1R2MS5TdHJpbmdMaXRlcmFsIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKHsgdHlwZTogJ1N0cmluZ0xpdGVyYWwnLCB2YWx1ZTogc3RyaW5nLnZhbHVlLCBsb2M6IHN0cmluZy5sb2MgfSk7XG4gIH1cblxuICBCb29sZWFuTGl0ZXJhbChib29sZWFuOiBIQlMuQm9vbGVhbkxpdGVyYWwpOiBBU1R2MS5Cb29sZWFuTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCh7IHR5cGU6ICdCb29sZWFuTGl0ZXJhbCcsIHZhbHVlOiBib29sZWFuLnZhbHVlLCBsb2M6IGJvb2xlYW4ubG9jIH0pO1xuICB9XG5cbiAgTnVtYmVyTGl0ZXJhbChudW1iZXI6IEhCUy5OdW1iZXJMaXRlcmFsKTogQVNUdjEuTnVtYmVyTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCh7IHR5cGU6ICdOdW1iZXJMaXRlcmFsJywgdmFsdWU6IG51bWJlci52YWx1ZSwgbG9jOiBudW1iZXIubG9jIH0pO1xuICB9XG5cbiAgVW5kZWZpbmVkTGl0ZXJhbCh1bmRlZjogSEJTLlVuZGVmaW5lZExpdGVyYWwpOiBBU1R2MS5VbmRlZmluZWRMaXRlcmFsIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKHsgdHlwZTogJ1VuZGVmaW5lZExpdGVyYWwnLCB2YWx1ZTogdW5kZWZpbmVkLCBsb2M6IHVuZGVmLmxvYyB9KTtcbiAgfVxuXG4gIE51bGxMaXRlcmFsKG51bDogSEJTLk51bGxMaXRlcmFsKTogQVNUdjEuTnVsbExpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoeyB0eXBlOiAnTnVsbExpdGVyYWwnLCB2YWx1ZTogbnVsbCwgbG9jOiBudWwubG9jIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJpZ2h0U3RyaXBwZWRPZmZzZXRzKG9yaWdpbmFsOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlID09PSAnJykge1xuICAgIC8vIGlmIGl0IGlzIGVtcHR5LCBqdXN0IHJldHVybiB0aGUgY291bnQgb2YgbmV3bGluZXNcbiAgICAvLyBpbiBvcmlnaW5hbFxuICAgIHJldHVybiB7XG4gICAgICBsaW5lczogb3JpZ2luYWwuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDEsXG4gICAgICBjb2x1bW5zOiAwLFxuICAgIH07XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIG5ld2xpbmVzIHByaW9yIHRvXG4gIC8vIGB2YWx1ZWBcbiAgbGV0IGRpZmZlcmVuY2UgPSBvcmlnaW5hbC5zcGxpdCh2YWx1ZSlbMF07XG4gIGxldCBsaW5lcyA9IGRpZmZlcmVuY2Uuc3BsaXQoL1xcbi8pO1xuICBsZXQgbGluZUNvdW50ID0gbGluZXMubGVuZ3RoIC0gMTtcblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lQ291bnQsXG4gICAgY29sdW1uczogbGluZXNbbGluZUNvdW50XS5sZW5ndGgsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRva2VuaXplckxvY2F0aW9uKHRva2VuaXplcjogUGFyc2VyWyd0b2tlbml6ZXInXSwgY29udGVudDogSEJTLkNvbnRlbnRTdGF0ZW1lbnQpIHtcbiAgbGV0IGxpbmUgPSBjb250ZW50LmxvYy5zdGFydC5saW5lO1xuICBsZXQgY29sdW1uID0gY29udGVudC5sb2Muc3RhcnQuY29sdW1uO1xuXG4gIGxldCBvZmZzZXRzID0gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMoXG4gICAgY29udGVudC5vcmlnaW5hbCBhcyBSZWNhc3Q8SEJTLlN0cmlwRmxhZ3MsIHN0cmluZz4sXG4gICAgY29udGVudC52YWx1ZVxuICApO1xuXG4gIGxpbmUgPSBsaW5lICsgb2Zmc2V0cy5saW5lcztcbiAgaWYgKG9mZnNldHMubGluZXMpIHtcbiAgICBjb2x1bW4gPSBvZmZzZXRzLmNvbHVtbnM7XG4gIH0gZWxzZSB7XG4gICAgY29sdW1uID0gY29sdW1uICsgb2Zmc2V0cy5jb2x1bW5zO1xuICB9XG5cbiAgdG9rZW5pemVyLmxpbmUgPSBsaW5lO1xuICB0b2tlbml6ZXIuY29sdW1uID0gY29sdW1uO1xufVxuXG5mdW5jdGlvbiBhY2NlcHRDYWxsTm9kZXMoXG4gIGNvbXBpbGVyOiBIYW5kbGViYXJzTm9kZVZpc2l0b3JzLFxuICBub2RlOiB7XG4gICAgcGF0aDogSEJTLlBhdGhFeHByZXNzaW9uO1xuICAgIHBhcmFtczogSEJTLkV4cHJlc3Npb25bXTtcbiAgICBoYXNoOiBIQlMuSGFzaDtcbiAgfVxuKTogeyBwYXRoOiBBU1R2MS5QYXRoRXhwcmVzc2lvbjsgcGFyYW1zOiBBU1R2MS5FeHByZXNzaW9uW107IGhhc2g6IEFTVHYxLkhhc2ggfSB7XG4gIGxldCBwYXRoID0gY29tcGlsZXIuUGF0aEV4cHJlc3Npb24obm9kZS5wYXRoKTtcbiAgbGV0IHBhcmFtcyA9IG5vZGUucGFyYW1zID8gbm9kZS5wYXJhbXMubWFwKChlKSA9PiBjb21waWxlci5hY2NlcHROb2RlPEFTVHYxLkV4cHJlc3Npb24+KGUpKSA6IFtdO1xuXG4gIC8vIGlmIHRoZXJlIGlzIG5vIGhhc2gsIHBvc2l0aW9uIGl0IGFzIGEgY29sbGFwc2VkIG5vZGUgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGxhc3QgcGFyYW0gKG9yIHRoZVxuICAvLyBwYXRoLCBpZiB0aGVyZSBhcmUgYWxzbyBubyBwYXJhbXMpXG4gIGxldCBlbmQgPSBwYXJhbXMubGVuZ3RoID4gMCA/IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV0ubG9jIDogcGF0aC5sb2M7XG5cbiAgbGV0IGhhc2ggPSBub2RlLmhhc2hcbiAgICA/IGNvbXBpbGVyLkhhc2gobm9kZS5oYXNoKVxuICAgIDogKHtcbiAgICAgICAgdHlwZTogJ0hhc2gnLFxuICAgICAgICBwYWlyczogW10gYXMgQVNUdjEuSGFzaFBhaXJbXSxcbiAgICAgICAgbG9jOiBjb21waWxlci5zb3VyY2Uuc3BhbkZvcihlbmQpLmNvbGxhcHNlKCdlbmQnKSxcbiAgICAgIH0gYXMgY29uc3QpO1xuXG4gIHJldHVybiB7IHBhdGgsIHBhcmFtcywgaGFzaCB9O1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50TW9kaWZpZXIoXG4gIGVsZW1lbnQ6IFBhcnNlck5vZGVCdWlsZGVyPFRhZzwnU3RhcnRUYWcnPj4sXG4gIG11c3RhY2hlOiBBU1R2MS5NdXN0YWNoZVN0YXRlbWVudFxuKSB7XG4gIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jIH0gPSBtdXN0YWNoZTtcblxuICBpZiAoaXNIQlNMaXRlcmFsKHBhdGgpKSB7XG4gICAgbGV0IG1vZGlmaWVyID0gYHt7JHtwcmludExpdGVyYWwocGF0aCl9fX1gO1xuICAgIGxldCB0YWcgPSBgPCR7ZWxlbWVudC5uYW1lfSAuLi4gJHttb2RpZmllcn0gLi4uYDtcblxuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoYEluICR7dGFnfSwgJHttb2RpZmllcn0gaXMgbm90IGEgdmFsaWQgbW9kaWZpZXJgLCBtdXN0YWNoZS5sb2MpO1xuICB9XG5cbiAgbGV0IG1vZGlmaWVyID0gYi5lbGVtZW50TW9kaWZpZXIoeyBwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyB9KTtcbiAgZWxlbWVudC5tb2RpZmllcnMucHVzaChtb2RpZmllcik7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9