"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.span = exports.HbsSpan = exports.SourceSpan = void 0;

var _env = require("@glimmer/env");

var _util = require("@glimmer/util");

var _location = require("../location");

var _slice = require("../slice");

var _match = require("./match");

var _offset = require("./offset");

var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function (receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return privateMap.get(receiver);
};

var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function (receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  privateMap.set(receiver, value);
  return value;
};

var _locPosSpan, _charPosSpan, _providedHbsLoc; // eslint-disable-next-line import/no-extraneous-dependencies


/**
 * A `SourceSpan` object represents a span of characters inside of a template source.
 *
 * There are three kinds of `SourceSpan` objects:
 *
 * - `ConcreteSourceSpan`, which contains byte offsets
 * - `LazySourceSpan`, which contains `SourceLocation`s from the Handlebars AST, which can be
 *   converted to byte offsets on demand.
 * - `InvisibleSourceSpan`, which represent source strings that aren't present in the source,
 *   because:
 *     - they were created synthetically
 *     - their location is nonsensical (the span is broken)
 *     - they represent nothing in the source (this currently happens only when a bug in the
 *       upstream Handlebars parser fails to assign a location to empty blocks)
 *
 * At a high level, all `SourceSpan` objects provide:
 *
 * - byte offsets
 * - source in column and line format
 *
 * And you can do these operations on `SourceSpan`s:
 *
 * - collapse it to a `SourceSpan` representing its starting or ending position
 * - slice out some characters, optionally skipping some characters at the beginning or end
 * - create a new `SourceSpan` with a different starting or ending offset
 *
 * All SourceSpan objects implement `SourceLocation`, for compatibility. All SourceSpan
 * objects have a `toJSON` that emits `SourceLocation`, also for compatibility.
 *
 * For compatibility, subclasses of `AbstractSourceSpan` must implement `locDidUpdate`, which
 * happens when an AST plugin attempts to modify the `start` or `end` of a span directly.
 *
 * The goal is to avoid creating any problems for use-cases like AST Explorer.
 */
class SourceSpan {
  constructor(data) {
    this.data = data;
    this.isInvisible = data.kind !== "CharPosition"
    /* CharPosition */
    && data.kind !== "HbsPosition"
    /* HbsPosition */
    ;
  }

  static get NON_EXISTENT() {
    return new InvisibleSpan("NonExistent"
    /* NonExistent */
    , _location.NON_EXISTENT_LOCATION).wrap();
  }

  static load(source, serialized) {
    if (typeof serialized === 'number') {
      return SourceSpan.forCharPositions(source, serialized, serialized);
    } else if (typeof serialized === 'string') {
      return SourceSpan.synthetic(serialized);
    } else if (Array.isArray(serialized)) {
      return SourceSpan.forCharPositions(source, serialized[0], serialized[1]);
    } else if (serialized === "NonExistent"
    /* NonExistent */
    ) {
        return SourceSpan.NON_EXISTENT;
      } else if (serialized === "Broken"
    /* Broken */
    ) {
        return SourceSpan.broken(_location.BROKEN_LOCATION);
      }

    (0, _util.assertNever)(serialized);
  }

  static forHbsLoc(source, loc) {
    let start = new _offset.HbsPosition(source, loc.start);
    let end = new _offset.HbsPosition(source, loc.end);
    return new HbsSpan(source, {
      start,
      end
    }, loc).wrap();
  }

  static forCharPositions(source, startPos, endPos) {
    let start = new _offset.CharPosition(source, startPos);
    let end = new _offset.CharPosition(source, endPos);
    return new CharPositionSpan(source, {
      start,
      end
    }).wrap();
  }

  static synthetic(chars) {
    return new InvisibleSpan("InternalsSynthetic"
    /* InternalsSynthetic */
    , _location.NON_EXISTENT_LOCATION, chars).wrap();
  }

  static broken(pos = _location.BROKEN_LOCATION) {
    return new InvisibleSpan("Broken"
    /* Broken */
    , pos).wrap();
  }

  getStart() {
    return this.data.getStart().wrap();
  }

  getEnd() {
    return this.data.getEnd().wrap();
  }

  get loc() {
    let span = this.data.toHbsSpan();
    return span === null ? _location.BROKEN_LOCATION : span.toHbsLoc();
  }

  get module() {
    return this.data.getModule();
  }
  /**
   * Get the starting `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
   */


  get startPosition() {
    return this.loc.start;
  }
  /**
   * Get the ending `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
   */


  get endPosition() {
    return this.loc.end;
  }
  /**
   * Support converting ASTv1 nodes into a serialized format using JSON.stringify.
   */


  toJSON() {
    return this.loc;
  }
  /**
   * Create a new span with the current span's end and a new beginning.
   */


  withStart(other) {
    return span(other.data, this.data.getEnd());
  }
  /**
   * Create a new span with the current span's beginning and a new ending.
   */


  withEnd(other) {
    return span(this.data.getStart(), other.data);
  }

  asString() {
    return this.data.asString();
  }
  /**
   * Convert this `SourceSpan` into a `SourceSlice`. In debug mode, this method optionally checks
   * that the byte offsets represented by this `SourceSpan` actually correspond to the expected
   * string.
   */


  toSlice(expected) {
    let chars = this.data.asString();

    if (_env.DEBUG) {
      if (expected !== undefined && chars !== expected) {
        // eslint-disable-next-line no-console
        console.warn(`unexpectedly found ${JSON.stringify(chars)} when slicing source, but expected ${JSON.stringify(expected)}`);
      }
    }

    return new _slice.SourceSlice({
      loc: this,
      chars: expected || chars
    });
  }
  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use startPosition instead
   */


  get start() {
    return this.loc.start;
  }
  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use withStart instead
   */


  set start(position) {
    this.data.locDidUpdate({
      start: position
    });
  }
  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use endPosition instead
   */


  get end() {
    return this.loc.end;
  }
  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use withEnd instead
   */


  set end(position) {
    this.data.locDidUpdate({
      end: position
    });
  }
  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use module instead
   */


  get source() {
    return this.module;
  }

  collapse(where) {
    switch (where) {
      case 'start':
        return this.getStart().collapsed();

      case 'end':
        return this.getEnd().collapsed();
    }
  }

  extend(other) {
    return span(this.data.getStart(), other.data.getEnd());
  }

  serialize() {
    return this.data.serialize();
  }

  slice({
    skipStart = 0,
    skipEnd = 0
  }) {
    return span(this.getStart().move(skipStart).data, this.getEnd().move(-skipEnd).data);
  }

  sliceStartChars({
    skipStart = 0,
    chars
  }) {
    return span(this.getStart().move(skipStart).data, this.getStart().move(skipStart + chars).data);
  }

  sliceEndChars({
    skipEnd = 0,
    chars
  }) {
    return span(this.getEnd().move(skipEnd - chars).data, this.getStart().move(-skipEnd).data);
  }

}

exports.SourceSpan = SourceSpan;

class CharPositionSpan {
  constructor(source, charPositions) {
    this.source = source;
    this.charPositions = charPositions;
    this.kind = "CharPosition"
    /* CharPosition */
    ;

    _locPosSpan.set(this, null);
  }

  wrap() {
    return new SourceSpan(this);
  }

  asString() {
    return this.source.slice(this.charPositions.start.charPos, this.charPositions.end.charPos);
  }

  getModule() {
    return this.source.module;
  }

  getStart() {
    return this.charPositions.start;
  }

  getEnd() {
    return this.charPositions.end;
  }

  locDidUpdate() {
    if (false
    /* LOCAL_DEBUG */
    ) {
        // eslint-disable-next-line no-console
        console.warn(`updating a location that came from a CharPosition span doesn't work reliably. Don't try to update locations after the plugin phase`);
      }
  }

  toHbsSpan() {
    let locPosSpan = __classPrivateFieldGet(this, _locPosSpan);

    if (locPosSpan === null) {
      let start = this.charPositions.start.toHbsPos();
      let end = this.charPositions.end.toHbsPos();

      if (start === null || end === null) {
        locPosSpan = __classPrivateFieldSet(this, _locPosSpan, _offset.BROKEN);
      } else {
        locPosSpan = __classPrivateFieldSet(this, _locPosSpan, new HbsSpan(this.source, {
          start,
          end
        }));
      }
    }

    return locPosSpan === _offset.BROKEN ? null : locPosSpan;
  }

  serialize() {
    let {
      start: {
        charPos: start
      },
      end: {
        charPos: end
      }
    } = this.charPositions;

    if (start === end) {
      return start;
    } else {
      return [start, end];
    }
  }

  toCharPosSpan() {
    return this;
  }

}

_locPosSpan = new WeakMap();

class HbsSpan {
  constructor(source, hbsPositions, providedHbsLoc = null) {
    this.source = source;
    this.hbsPositions = hbsPositions;
    this.kind = "HbsPosition"
    /* HbsPosition */
    ;

    _charPosSpan.set(this, null); // the source location from Handlebars + AST Plugins -- could be wrong


    _providedHbsLoc.set(this, void 0);

    __classPrivateFieldSet(this, _providedHbsLoc, providedHbsLoc);
  }

  serialize() {
    let charPos = this.toCharPosSpan();
    return charPos === null ? "Broken"
    /* Broken */
    : charPos.wrap().serialize();
  }

  wrap() {
    return new SourceSpan(this);
  }

  updateProvided(pos, edge) {
    if (__classPrivateFieldGet(this, _providedHbsLoc)) {
      __classPrivateFieldGet(this, _providedHbsLoc)[edge] = pos;
    } // invalidate computed character offsets


    __classPrivateFieldSet(this, _charPosSpan, null);

    __classPrivateFieldSet(this, _providedHbsLoc, {
      start: pos,
      end: pos
    });
  }

  locDidUpdate({
    start,
    end
  }) {
    if (start !== undefined) {
      this.updateProvided(start, 'start');
      this.hbsPositions.start = new _offset.HbsPosition(this.source, start, null);
    }

    if (end !== undefined) {
      this.updateProvided(end, 'end');
      this.hbsPositions.end = new _offset.HbsPosition(this.source, end, null);
    }
  }

  asString() {
    let span = this.toCharPosSpan();
    return span === null ? '' : span.asString();
  }

  getModule() {
    return this.source.module;
  }

  getStart() {
    return this.hbsPositions.start;
  }

  getEnd() {
    return this.hbsPositions.end;
  }

  toHbsLoc() {
    return {
      start: this.hbsPositions.start.hbsPos,
      end: this.hbsPositions.end.hbsPos
    };
  }

  toHbsSpan() {
    return this;
  }

  toCharPosSpan() {
    let charPosSpan = __classPrivateFieldGet(this, _charPosSpan);

    if (charPosSpan === null) {
      let start = this.hbsPositions.start.toCharPos();
      let end = this.hbsPositions.end.toCharPos();

      if (start && end) {
        charPosSpan = __classPrivateFieldSet(this, _charPosSpan, new CharPositionSpan(this.source, {
          start,
          end
        }));
      } else {
        charPosSpan = __classPrivateFieldSet(this, _charPosSpan, _offset.BROKEN);
        return null;
      }
    }

    return charPosSpan === _offset.BROKEN ? null : charPosSpan;
  }

}

exports.HbsSpan = HbsSpan;
_charPosSpan = new WeakMap(), _providedHbsLoc = new WeakMap();

class InvisibleSpan {
  constructor(kind, // whatever was provided, possibly broken
  loc, // if the span represents a synthetic string
  string = null) {
    this.kind = kind;
    this.loc = loc;
    this.string = string;
  }

  serialize() {
    switch (this.kind) {
      case "Broken"
      /* Broken */
      :
      case "NonExistent"
      /* NonExistent */
      :
        return this.kind;

      case "InternalsSynthetic"
      /* InternalsSynthetic */
      :
        return this.string || '';
    }
  }

  wrap() {
    return new SourceSpan(this);
  }

  asString() {
    return this.string || '';
  }

  locDidUpdate({
    start,
    end
  }) {
    if (start !== undefined) {
      this.loc.start = start;
    }

    if (end !== undefined) {
      this.loc.end = end;
    }
  }

  getModule() {
    // TODO: Make this reflect the actual module this span originated from
    return 'an unknown module';
  }

  getStart() {
    return new _offset.InvisiblePosition(this.kind, this.loc.start);
  }

  getEnd() {
    return new _offset.InvisiblePosition(this.kind, this.loc.end);
  }

  toCharPosSpan() {
    return this;
  }

  toHbsSpan() {
    return null;
  }

  toHbsLoc() {
    return _location.BROKEN_LOCATION;
  }

}

const span = (0, _match.match)(m => m.when("HbsPosition"
/* HbsPosition */
, "HbsPosition"
/* HbsPosition */
, (left, right) => new HbsSpan(left.source, {
  start: left,
  end: right
}).wrap()).when("CharPosition"
/* CharPosition */
, "CharPosition"
/* CharPosition */
, (left, right) => new CharPositionSpan(left.source, {
  start: left,
  end: right
}).wrap()).when("CharPosition"
/* CharPosition */
, "HbsPosition"
/* HbsPosition */
, (left, right) => {
  let rightCharPos = right.toCharPos();

  if (rightCharPos === null) {
    return new InvisibleSpan("Broken"
    /* Broken */
    , _location.BROKEN_LOCATION).wrap();
  } else {
    return span(left, rightCharPos);
  }
}).when("HbsPosition"
/* HbsPosition */
, "CharPosition"
/* CharPosition */
, (left, right) => {
  let leftCharPos = left.toCharPos();

  if (leftCharPos === null) {
    return new InvisibleSpan("Broken"
    /* Broken */
    , _location.BROKEN_LOCATION).wrap();
  } else {
    return span(leftCharPos, right);
  }
}).when(_match.IsInvisible, _match.MatchAny, left => new InvisibleSpan(left.kind, _location.BROKEN_LOCATION).wrap()).when(_match.MatchAny, _match.IsInvisible, (_, right) => new InvisibleSpan(right.kind, _location.BROKEN_LOCATION).wrap()));
exports.span = span;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvc291cmNlL2xvYy9zcGFuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQTs7QUFFQTs7QUFFQTs7QUFNQTs7QUFFQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnREFkQTs7O0FBdUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NNLE1BQUEsVUFBQSxDQUFpQjtBQTRDckIsRUFBQSxXQUFBLENBQUEsSUFBQSxFQUE0QztBQUF4QixTQUFBLElBQUEsR0FBQSxJQUFBO0FBQ2xCLFNBQUEsV0FBQSxHQUNFLElBQUksQ0FBSixJQUFBLEtBQVM7QUFBQTtBQUFULE9BQXlDLElBQUksQ0FBSixJQUFBLEtBQVM7QUFBQTtBQURwRDtBQUVEOztBQTlDRCxhQUFBLFlBQUEsR0FBdUI7QUFDckIsV0FBTyxJQUFBLGFBQUEsQ0FBaUI7QUFBQTtBQUFqQixNQUFBLCtCQUFBLEVBQVAsSUFBTyxFQUFQO0FBQ0Q7O0FBRUQsU0FBQSxJQUFBLENBQUEsTUFBQSxFQUFBLFVBQUEsRUFBNEQ7QUFDMUQsUUFBSSxPQUFBLFVBQUEsS0FBSixRQUFBLEVBQW9DO0FBQ2xDLGFBQU8sVUFBVSxDQUFWLGdCQUFBLENBQUEsTUFBQSxFQUFBLFVBQUEsRUFBUCxVQUFPLENBQVA7QUFERixLQUFBLE1BRU8sSUFBSSxPQUFBLFVBQUEsS0FBSixRQUFBLEVBQW9DO0FBQ3pDLGFBQU8sVUFBVSxDQUFWLFNBQUEsQ0FBUCxVQUFPLENBQVA7QUFESyxLQUFBLE1BRUEsSUFBSSxLQUFLLENBQUwsT0FBQSxDQUFKLFVBQUksQ0FBSixFQUErQjtBQUNwQyxhQUFPLFVBQVUsQ0FBVixnQkFBQSxDQUFBLE1BQUEsRUFBb0MsVUFBVSxDQUE5QyxDQUE4QyxDQUE5QyxFQUFtRCxVQUFVLENBQXBFLENBQW9FLENBQTdELENBQVA7QUFESyxLQUFBLE1BRUEsSUFBSSxVQUFVLEtB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QUVPO0FBQ0wsV0FBTyxJQUFJLENBQUEsSUFBQSxFQUFYLFlBQVcsQ0FBWDtBQUNEO0FBcEJMLENBQUEsRUFBQSxJQUFBLENBc0JPO0FBQUE7QUF0QlAsRUFzQk87QUFBQTtBQXRCUCxFQXNCeUQsQ0FBQSxJQUFBLEVBQUEsS0FBQSxLQUFnQjtBQUNyRSxNQUFJLFdBQVcsR0FBRyxJQUFJLENBQXRCLFNBQWtCLEVBQWxCOztBQUVBLE1BQUksV0FBVyxLQUFmLElBQUEsRUFBMEI7QUFDeEIsV0FBTyxJQUFBLGFBQUEsQ0FBaUI7QUFBQTtBQUFqQixNQUFBLHlCQUFBLEVBQVAsSUFBTyxFQUFQO0FBREYsR0FBQSxNQUVPO0FBQ0wsV0FBTyxJQUFJLENBQUEsV0FBQSxFQUFYLEtBQVcsQ0FBWDtBQUNEO0FBN0JMLENBQUEsRUFBQSxJQUFBLENBQUEsa0JBQUEsRUFBQSxlQUFBLEVBK0JnQyxJQUFELElBQVUsSUFBQSxhQUFBLENBQWtCLElBQUksQ0FBdEIsSUFBQSxFQUFBLHlCQUFBLEVBL0J6QyxJQStCeUMsRUEvQnpDLEVBQUEsSUFBQSxDQUFBLGVBQUEsRUFBQSxrQkFBQSxFQWdDK0IsQ0FBQSxDQUFBLEVBQUEsS0FBQSxLQUMzQixJQUFBLGFBQUEsQ0FBa0IsS0FBSyxDQUF2QixJQUFBLEVBQUEseUJBQUEsRUFsQ0MsSUFrQ0QsRUFqQ0osQ0FEdUMsQ0FBbEMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG5pbXBvcnQgeyBERUJVRyB9IGZyb20gJ0BnbGltbWVyL2Vudic7XG5pbXBvcnQgeyBMT0NBTF9ERUJVRyB9IGZyb20gJ0BnbGltbWVyL2xvY2FsLWRlYnVnLWZsYWdzJztcbmltcG9ydCB7IGFzc2VydE5ldmVyIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCB7XG4gIEJST0tFTl9MT0NBVElPTixcbiAgTk9OX0VYSVNURU5UX0xPQ0FUSU9OLFxuICBTb3VyY2VMb2NhdGlvbixcbiAgU291cmNlUG9zaXRpb24sXG59IGZyb20gJy4uL2xvY2F0aW9uJztcbmltcG9ydCB7IFNvdXJjZVNsaWNlIH0gZnJvbSAnLi4vc2xpY2UnO1xuaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi4vc291cmNlJztcbmltcG9ydCB7IElzSW52aXNpYmxlLCBtYXRjaCwgTWF0Y2hBbnksIE1hdGNoRm4gfSBmcm9tICcuL21hdGNoJztcbmltcG9ydCB7XG4gIEFueVBvc2l0aW9uLFxuICBCUk9LRU4sXG4gIENoYXJQb3NpdGlvbixcbiAgSGJzUG9zaXRpb24sXG4gIEludmlzaWJsZVBvc2l0aW9uLFxuICBPZmZzZXRLaW5kLFxuICBTb3VyY2VPZmZzZXQsXG59IGZyb20gJy4vb2Zmc2V0JztcblxuLyoqXG4gKiBBbGwgc3BhbnMgaGF2ZSB0aGVzZSBkZXRhaWxzIGluIGNvbW1vbi5cbiAqL1xuaW50ZXJmYWNlIFNwYW5EYXRhIHtcbiAgcmVhZG9ubHkga2luZDogT2Zmc2V0S2luZDtcblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIHNwYW4gaW50byBhIHN0cmluZy4gSWYgdGhlIHNwYW4gaXMgYnJva2VuLCByZXR1cm4gYCcnYC5cbiAgICovXG4gIGFzU3RyaW5nKCk6IHN0cmluZztcblxuICAvKipcbiAgICogR2V0cyB0aGUgbW9kdWxlIHRoZSBzcGFuIHdhcyBsb2NhdGVkIGluLlxuICAgKi9cbiAgZ2V0TW9kdWxlKCk6IHN0cmluZztcblxuICAvKipcbiAgICogR2V0IHRoZSBzdGFydGluZyBwb3NpdGlvbiBmb3IgdGhpcyBzcGFuLiBUcnkgdG8gYXZvaWQgY3JlYXRpbmcgbmV3IHBvc2l0aW9uIG9iamVjdHMsIGFzIHRoZXlcbiAgICogY2FjaGUgY29tcHV0YXRpb25zLlxuICAgKi9cbiAgZ2V0U3RhcnQoKTogQW55UG9zaXRpb247XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW5kaW5nIHBvc2l0aW9uIGZvciB0aGlzIHNwYW4uIFRyeSB0byBhdm9pZCBjcmVhdGluZyBuZXcgcG9zaXRpb24gb2JqZWN0cywgYXMgdGhleVxuICAgKiBjYWNoZSBjb21wdXRhdGlvbnMuXG4gICAqL1xuICBnZXRFbmQoKTogQW55UG9zaXRpb247XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIGBTb3VyY2VMb2NhdGlvbmAgZm9yIHRoaXMgc3BhbiwgcmV0dXJuZWQgYXMgYW4gaW5zdGFuY2Ugb2YgYEhic1NwYW5gLlxuICAgKi9cbiAgdG9IYnNTcGFuKCk6IEhic1NwYW4gfCBudWxsO1xuXG4gIC8qKlxuICAgKiBGb3IgY29tcGF0aWJpbGl0eSwgd2hlbmV2ZXIgdGhlIGBzdGFydGAgb3IgYGVuZGAgb2YgYSB7QHNlZSBTb3VyY2VPZmZzZXR9IGNoYW5nZXMsIHNwYW5zIGFyZVxuICAgKiBub3RpZmllZCBvZiB0aGUgY2hhbmdlIHNvIHRoZXkgY2FuIHVwZGF0ZSB0aGVtc2VsdmVzLiBUaGlzIHNob3VsZG4ndCBoYXBwZW4gb3V0c2lkZSBvZiBBU1RcbiAgICogcGx1Z2lucy5cbiAgICovXG4gIGxvY0RpZFVwZGF0ZShjaGFuZ2VzOiB7IHN0YXJ0PzogU291cmNlUG9zaXRpb247IGVuZD86IFNvdXJjZVBvc2l0aW9uIH0pOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgaW50byBhIHtAc2VlIFNlcmlhbGl6ZWRTb3VyY2VTcGFufSwgd2hpY2ggaXMgY29tcGFjdCBhbmQgZGVzaWduZWQgZm9yIHJlYWRhYmlsaXR5IGluXG4gICAqIGNvbnRleHQgbGlrZSBBU1QgRXhwbG9yZXIuIElmIHlvdSBuZWVkIGEge0BzZWUgU291cmNlTG9jYXRpb259LCB1c2Uge0BzZWUgdG9KU09OfS5cbiAgICovXG4gIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemVkU291cmNlU3Bhbjtcbn1cblxuLyoqXG4gKiBBIGBTb3VyY2VTcGFuYCBvYmplY3QgcmVwcmVzZW50cyBhIHNwYW4gb2YgY2hhcmFjdGVycyBpbnNpZGUgb2YgYSB0ZW1wbGF0ZSBzb3VyY2UuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIGtpbmRzIG9mIGBTb3VyY2VTcGFuYCBvYmplY3RzOlxuICpcbiAqIC0gYENvbmNyZXRlU291cmNlU3BhbmAsIHdoaWNoIGNvbnRhaW5zIGJ5dGUgb2Zmc2V0c1xuICogLSBgTGF6eVNvdXJjZVNwYW5gLCB3aGljaCBjb250YWlucyBgU291cmNlTG9jYXRpb25gcyBmcm9tIHRoZSBIYW5kbGViYXJzIEFTVCwgd2hpY2ggY2FuIGJlXG4gKiAgIGNvbnZlcnRlZCB0byBieXRlIG9mZnNldHMgb24gZGVtYW5kLlxuICogLSBgSW52aXNpYmxlU291cmNlU3BhbmAsIHdoaWNoIHJlcHJlc2VudCBzb3VyY2Ugc3RyaW5ncyB0aGF0IGFyZW4ndCBwcmVzZW50IGluIHRoZSBzb3VyY2UsXG4gKiAgIGJlY2F1c2U6XG4gKiAgICAgLSB0aGV5IHdlcmUgY3JlYXRlZCBzeW50aGV0aWNhbGx5XG4gKiAgICAgLSB0aGVpciBsb2NhdGlvbiBpcyBub25zZW5zaWNhbCAodGhlIHNwYW4gaXMgYnJva2VuKVxuICogICAgIC0gdGhleSByZXByZXNlbnQgbm90aGluZyBpbiB0aGUgc291cmNlICh0aGlzIGN1cnJlbnRseSBoYXBwZW5zIG9ubHkgd2hlbiBhIGJ1ZyBpbiB0aGVcbiAqICAgICAgIHVwc3RyZWFtIEhhbmRsZWJhcnMgcGFyc2VyIGZhaWxzIHRvIGFzc2lnbiBhIGxvY2F0aW9uIHRvIGVtcHR5IGJsb2NrcylcbiAqXG4gKiBBdCBhIGhpZ2ggbGV2ZWwsIGFsbCBgU291cmNlU3BhbmAgb2JqZWN0cyBwcm92aWRlOlxuICpcbiAqIC0gYnl0ZSBvZmZzZXRzXG4gKiAtIHNvdXJjZSBpbiBjb2x1bW4gYW5kIGxpbmUgZm9ybWF0XG4gKlxuICogQW5kIHlvdSBjYW4gZG8gdGhlc2Ugb3BlcmF0aW9ucyBvbiBgU291cmNlU3BhbmBzOlxuICpcbiAqIC0gY29sbGFwc2UgaXQgdG8gYSBgU291cmNlU3BhbmAgcmVwcmVzZW50aW5nIGl0cyBzdGFydGluZyBvciBlbmRpbmcgcG9zaXRpb25cbiAqIC0gc2xpY2Ugb3V0IHNvbWUgY2hhcmFjdGVycywgb3B0aW9uYWxseSBza2lwcGluZyBzb21lIGNoYXJhY3RlcnMgYXQgdGhlIGJlZ2lubmluZyBvciBlbmRcbiAqIC0gY3JlYXRlIGEgbmV3IGBTb3VyY2VTcGFuYCB3aXRoIGEgZGlmZmVyZW50IHN0YXJ0aW5nIG9yIGVuZGluZyBvZmZzZXRcbiAqXG4gKiBBbGwgU291cmNlU3BhbiBvYmplY3RzIGltcGxlbWVudCBgU291cmNlTG9jYXRpb25gLCBmb3IgY29tcGF0aWJpbGl0eS4gQWxsIFNvdXJjZVNwYW5cbiAqIG9iamVjdHMgaGF2ZSBhIGB0b0pTT05gIHRoYXQgZW1pdHMgYFNvdXJjZUxvY2F0aW9uYCwgYWxzbyBmb3IgY29tcGF0aWJpbGl0eS5cbiAqXG4gKiBGb3IgY29tcGF0aWJpbGl0eSwgc3ViY2xhc3NlcyBvZiBgQWJzdHJhY3RTb3VyY2VTcGFuYCBtdXN0IGltcGxlbWVudCBgbG9jRGlkVXBkYXRlYCwgd2hpY2hcbiAqIGhhcHBlbnMgd2hlbiBhbiBBU1QgcGx1Z2luIGF0dGVtcHRzIHRvIG1vZGlmeSB0aGUgYHN0YXJ0YCBvciBgZW5kYCBvZiBhIHNwYW4gZGlyZWN0bHkuXG4gKlxuICogVGhlIGdvYWwgaXMgdG8gYXZvaWQgY3JlYXRpbmcgYW55IHByb2JsZW1zIGZvciB1c2UtY2FzZXMgbGlrZSBBU1QgRXhwbG9yZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBTb3VyY2VTcGFuIGltcGxlbWVudHMgU291cmNlTG9jYXRpb24ge1xuICBzdGF0aWMgZ2V0IE5PTl9FWElTVEVOVCgpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gbmV3IEludmlzaWJsZVNwYW4oT2Zmc2V0S2luZC5Ob25FeGlzdGVudCwgTk9OX0VYSVNURU5UX0xPQ0FUSU9OKS53cmFwKCk7XG4gIH1cblxuICBzdGF0aWMgbG9hZChzb3VyY2U6IFNvdXJjZSwgc2VyaWFsaXplZDogU2VyaWFsaXplZFNvdXJjZVNwYW4pOiBTb3VyY2VTcGFuIHtcbiAgICBpZiAodHlwZW9mIHNlcmlhbGl6ZWQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gU291cmNlU3Bhbi5mb3JDaGFyUG9zaXRpb25zKHNvdXJjZSwgc2VyaWFsaXplZCwgc2VyaWFsaXplZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VyaWFsaXplZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBTb3VyY2VTcGFuLnN5bnRoZXRpYyhzZXJpYWxpemVkKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VyaWFsaXplZCkpIHtcbiAgICAgIHJldHVybiBTb3VyY2VTcGFuLmZvckNoYXJQb3NpdGlvbnMoc291cmNlLCBzZXJpYWxpemVkWzBdLCBzZXJpYWxpemVkWzFdKTtcbiAgICB9IGVsc2UgaWYgKHNlcmlhbGl6ZWQgPT09IE9mZnNldEtpbmQuTm9uRXhpc3RlbnQpIHtcbiAgICAgIHJldHVybiBTb3VyY2VTcGFuLk5PTl9FWElTVEVOVDtcbiAgICB9IGVsc2UgaWYgKHNlcmlhbGl6ZWQgPT09IE9mZnNldEtpbmQuQnJva2VuKSB7XG4gICAgICByZXR1cm4gU291cmNlU3Bhbi5icm9rZW4oQlJPS0VOX0xPQ0FUSU9OKTtcbiAgICB9XG5cbiAgICBhc3NlcnROZXZlcihzZXJpYWxpemVkKTtcbiAgfVxuXG4gIHN0YXRpYyBmb3JIYnNMb2Moc291cmNlOiBTb3VyY2UsIGxvYzogU291cmNlTG9jYXRpb24pOiBTb3VyY2VTcGFuIHtcbiAgICBsZXQgc3RhcnQgPSBuZXcgSGJzUG9zaXRpb24oc291cmNlLCBsb2Muc3RhcnQpO1xuICAgIGxldCBlbmQgPSBuZXcgSGJzUG9zaXRpb24oc291cmNlLCBsb2MuZW5kKTtcbiAgICByZXR1cm4gbmV3IEhic1NwYW4oc291cmNlLCB7IHN0YXJ0LCBlbmQgfSwgbG9jKS53cmFwKCk7XG4gIH1cblxuICBzdGF0aWMgZm9yQ2hhclBvc2l0aW9ucyhzb3VyY2U6IFNvdXJjZSwgc3RhcnRQb3M6IG51bWJlciwgZW5kUG9zOiBudW1iZXIpOiBTb3VyY2VTcGFuIHtcbiAgICBsZXQgc3RhcnQgPSBuZXcgQ2hhclBvc2l0aW9uKHNvdXJjZSwgc3RhcnRQb3MpO1xuICAgIGxldCBlbmQgPSBuZXcgQ2hhclBvc2l0aW9uKHNvdXJjZSwgZW5kUG9zKTtcblxuICAgIHJldHVybiBuZXcgQ2hhclBvc2l0aW9uU3Bhbihzb3VyY2UsIHsgc3RhcnQsIGVuZCB9KS53cmFwKCk7XG4gIH1cblxuICBzdGF0aWMgc3ludGhldGljKGNoYXJzOiBzdHJpbmcpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gbmV3IEludmlzaWJsZVNwYW4oT2Zmc2V0S2luZC5JbnRlcm5hbHNTeW50aGV0aWMsIE5PTl9FWElTVEVOVF9MT0NBVElPTiwgY2hhcnMpLndyYXAoKTtcbiAgfVxuXG4gIHN0YXRpYyBicm9rZW4ocG9zOiBTb3VyY2VMb2NhdGlvbiA9IEJST0tFTl9MT0NBVElPTik6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiBuZXcgSW52aXNpYmxlU3BhbihPZmZzZXRLaW5kLkJyb2tlbiwgcG9zKS53cmFwKCk7XG4gIH1cblxuICByZWFkb25seSBpc0ludmlzaWJsZTogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGE6IFNwYW5EYXRhICYgQW55U3Bhbikge1xuICAgIHRoaXMuaXNJbnZpc2libGUgPVxuICAgICAgZGF0YS5raW5kICE9PSBPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbiAmJiBkYXRhLmtpbmQgIT09IE9mZnNldEtpbmQuSGJzUG9zaXRpb247XG4gIH1cblxuICBnZXRTdGFydCgpOiBTb3VyY2VPZmZzZXQge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0U3RhcnQoKS53cmFwKCk7XG4gIH1cblxuICBnZXRFbmQoKTogU291cmNlT2Zmc2V0IHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmdldEVuZCgpLndyYXAoKTtcbiAgfVxuXG4gIGdldCBsb2MoKTogU291cmNlTG9jYXRpb24ge1xuICAgIGxldCBzcGFuID0gdGhpcy5kYXRhLnRvSGJzU3BhbigpO1xuICAgIHJldHVybiBzcGFuID09PSBudWxsID8gQlJPS0VOX0xPQ0FUSU9OIDogc3Bhbi50b0hic0xvYygpO1xuICB9XG5cbiAgZ2V0IG1vZHVsZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0TW9kdWxlKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGFydGluZyBgU291cmNlUG9zaXRpb25gIGZvciB0aGlzIGBTb3VyY2VTcGFuYCwgbGF6aWx5IGNvbXB1dGluZyBpdCBpZiBuZWVkZWQuXG4gICAqL1xuICBnZXQgc3RhcnRQb3NpdGlvbigpOiBTb3VyY2VQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMubG9jLnN0YXJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW5kaW5nIGBTb3VyY2VQb3NpdGlvbmAgZm9yIHRoaXMgYFNvdXJjZVNwYW5gLCBsYXppbHkgY29tcHV0aW5nIGl0IGlmIG5lZWRlZC5cbiAgICovXG4gIGdldCBlbmRQb3NpdGlvbigpOiBTb3VyY2VQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMubG9jLmVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdXBwb3J0IGNvbnZlcnRpbmcgQVNUdjEgbm9kZXMgaW50byBhIHNlcmlhbGl6ZWQgZm9ybWF0IHVzaW5nIEpTT04uc3RyaW5naWZ5LlxuICAgKi9cbiAgdG9KU09OKCk6IFNvdXJjZUxvY2F0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5sb2M7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHNwYW4gd2l0aCB0aGUgY3VycmVudCBzcGFuJ3MgZW5kIGFuZCBhIG5ldyBiZWdpbm5pbmcuXG4gICAqL1xuICB3aXRoU3RhcnQob3RoZXI6IFNvdXJjZU9mZnNldCk6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiBzcGFuKG90aGVyLmRhdGEsIHRoaXMuZGF0YS5nZXRFbmQoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IHNwYW4gd2l0aCB0aGUgY3VycmVudCBzcGFuJ3MgYmVnaW5uaW5nIGFuZCBhIG5ldyBlbmRpbmcuXG4gICAqL1xuICB3aXRoRW5kKHRoaXM6IFNvdXJjZVNwYW4sIG90aGVyOiBTb3VyY2VPZmZzZXQpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gc3Bhbih0aGlzLmRhdGEuZ2V0U3RhcnQoKSwgb3RoZXIuZGF0YSk7XG4gIH1cblxuICBhc1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmRhdGEuYXNTdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoaXMgYFNvdXJjZVNwYW5gIGludG8gYSBgU291cmNlU2xpY2VgLiBJbiBkZWJ1ZyBtb2RlLCB0aGlzIG1ldGhvZCBvcHRpb25hbGx5IGNoZWNrc1xuICAgKiB0aGF0IHRoZSBieXRlIG9mZnNldHMgcmVwcmVzZW50ZWQgYnkgdGhpcyBgU291cmNlU3BhbmAgYWN0dWFsbHkgY29ycmVzcG9uZCB0byB0aGUgZXhwZWN0ZWRcbiAgICogc3RyaW5nLlxuICAgKi9cbiAgdG9TbGljZShleHBlY3RlZD86IHN0cmluZyk6IFNvdXJjZVNsaWNlIHtcbiAgICBsZXQgY2hhcnMgPSB0aGlzLmRhdGEuYXNTdHJpbmcoKTtcblxuICAgIGlmIChERUJVRykge1xuICAgICAgaWYgKGV4cGVjdGVkICE9PSB1bmRlZmluZWQgJiYgY2hhcnMgIT09IGV4cGVjdGVkKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgdW5leHBlY3RlZGx5IGZvdW5kICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBjaGFyc1xuICAgICAgICAgICl9IHdoZW4gc2xpY2luZyBzb3VyY2UsIGJ1dCBleHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KGV4cGVjdGVkKX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTb3VyY2VTbGljZSh7XG4gICAgICBsb2M6IHRoaXMsXG4gICAgICBjaGFyczogZXhwZWN0ZWQgfHwgY2hhcnMsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTb3VyY2VMb2NhdGlvbiBpbiBBU1QgcGx1Z2luc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2Ugc3RhcnRQb3NpdGlvbiBpbnN0ZWFkXG4gICAqL1xuICBnZXQgc3RhcnQoKTogU291cmNlUG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmxvYy5zdGFydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgY29tcGF0aWJpbGl0eSB3aXRoIFNvdXJjZUxvY2F0aW9uIGluIEFTVCBwbHVnaW5zXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB3aXRoU3RhcnQgaW5zdGVhZFxuICAgKi9cbiAgc2V0IHN0YXJ0KHBvc2l0aW9uOiBTb3VyY2VQb3NpdGlvbikge1xuICAgIHRoaXMuZGF0YS5sb2NEaWRVcGRhdGUoeyBzdGFydDogcG9zaXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTb3VyY2VMb2NhdGlvbiBpbiBBU1QgcGx1Z2luc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgZW5kUG9zaXRpb24gaW5zdGVhZFxuICAgKi9cbiAgZ2V0IGVuZCgpOiBTb3VyY2VQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMubG9jLmVuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgY29tcGF0aWJpbGl0eSB3aXRoIFNvdXJjZUxvY2F0aW9uIGluIEFTVCBwbHVnaW5zXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIHVzZSB3aXRoRW5kIGluc3RlYWRcbiAgICovXG4gIHNldCBlbmQocG9zaXRpb246IFNvdXJjZVBvc2l0aW9uKSB7XG4gICAgdGhpcy5kYXRhLmxvY0RpZFVwZGF0ZSh7IGVuZDogcG9zaXRpb24gfSk7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTb3VyY2VMb2NhdGlvbiBpbiBBU1QgcGx1Z2luc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgbW9kdWxlIGluc3RlYWRcbiAgICovXG4gIGdldCBzb3VyY2UoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGU7XG4gIH1cblxuICBjb2xsYXBzZSh3aGVyZTogJ3N0YXJ0JyB8ICdlbmQnKTogU291cmNlU3BhbiB7XG4gICAgc3dpdGNoICh3aGVyZSkge1xuICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFydCgpLmNvbGxhcHNlZCgpO1xuICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5kKCkuY29sbGFwc2VkKCk7XG4gICAgfVxuICB9XG5cbiAgZXh0ZW5kKG90aGVyOiBTb3VyY2VTcGFuKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIHNwYW4odGhpcy5kYXRhLmdldFN0YXJ0KCksIG90aGVyLmRhdGEuZ2V0RW5kKCkpO1xuICB9XG5cbiAgc2VyaWFsaXplKCk6IFNlcmlhbGl6ZWRTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLnNlcmlhbGl6ZSgpO1xuICB9XG5cbiAgc2xpY2UoeyBza2lwU3RhcnQgPSAwLCBza2lwRW5kID0gMCB9OiB7IHNraXBTdGFydD86IG51bWJlcjsgc2tpcEVuZD86IG51bWJlciB9KTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIHNwYW4odGhpcy5nZXRTdGFydCgpLm1vdmUoc2tpcFN0YXJ0KS5kYXRhLCB0aGlzLmdldEVuZCgpLm1vdmUoLXNraXBFbmQpLmRhdGEpO1xuICB9XG5cbiAgc2xpY2VTdGFydENoYXJzKHsgc2tpcFN0YXJ0ID0gMCwgY2hhcnMgfTogeyBza2lwU3RhcnQ/OiBudW1iZXI7IGNoYXJzOiBudW1iZXIgfSk6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiBzcGFuKHRoaXMuZ2V0U3RhcnQoKS5tb3ZlKHNraXBTdGFydCkuZGF0YSwgdGhpcy5nZXRTdGFydCgpLm1vdmUoc2tpcFN0YXJ0ICsgY2hhcnMpLmRhdGEpO1xuICB9XG5cbiAgc2xpY2VFbmRDaGFycyh7IHNraXBFbmQgPSAwLCBjaGFycyB9OiB7IHNraXBFbmQ/OiBudW1iZXI7IGNoYXJzOiBudW1iZXIgfSk6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiBzcGFuKHRoaXMuZ2V0RW5kKCkubW92ZShza2lwRW5kIC0gY2hhcnMpLmRhdGEsIHRoaXMuZ2V0U3RhcnQoKS5tb3ZlKC1za2lwRW5kKS5kYXRhKTtcbiAgfVxufVxuXG50eXBlIEFueVNwYW4gPSBIYnNTcGFuIHwgQ2hhclBvc2l0aW9uU3BhbiB8IEludmlzaWJsZVNwYW47XG5cbmNsYXNzIENoYXJQb3NpdGlvblNwYW4gaW1wbGVtZW50cyBTcGFuRGF0YSB7XG4gIHJlYWRvbmx5IGtpbmQgPSBPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbjtcblxuICAjbG9jUG9zU3BhbjogSGJzU3BhbiB8IEJST0tFTiB8IG51bGwgPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IHNvdXJjZTogU291cmNlLFxuICAgIHJlYWRvbmx5IGNoYXJQb3NpdGlvbnM6IHsgc3RhcnQ6IENoYXJQb3NpdGlvbjsgZW5kOiBDaGFyUG9zaXRpb24gfVxuICApIHt9XG5cbiAgd3JhcCgpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gbmV3IFNvdXJjZVNwYW4odGhpcyk7XG4gIH1cblxuICBhc1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5zbGljZSh0aGlzLmNoYXJQb3NpdGlvbnMuc3RhcnQuY2hhclBvcywgdGhpcy5jaGFyUG9zaXRpb25zLmVuZC5jaGFyUG9zKTtcbiAgfVxuXG4gIGdldE1vZHVsZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5tb2R1bGU7XG4gIH1cblxuICBnZXRTdGFydCgpOiBBbnlQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hhclBvc2l0aW9ucy5zdGFydDtcbiAgfVxuXG4gIGdldEVuZCgpOiBBbnlQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuY2hhclBvc2l0aW9ucy5lbmQ7XG4gIH1cblxuICBsb2NEaWRVcGRhdGUoKSB7XG4gICAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgdXBkYXRpbmcgYSBsb2NhdGlvbiB0aGF0IGNhbWUgZnJvbSBhIENoYXJQb3NpdGlvbiBzcGFuIGRvZXNuJ3Qgd29yayByZWxpYWJseS4gRG9uJ3QgdHJ5IHRvIHVwZGF0ZSBsb2NhdGlvbnMgYWZ0ZXIgdGhlIHBsdWdpbiBwaGFzZWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgdG9IYnNTcGFuKCk6IEhic1NwYW4gfCBudWxsIHtcbiAgICBsZXQgbG9jUG9zU3BhbiA9IHRoaXMuI2xvY1Bvc1NwYW47XG5cbiAgICBpZiAobG9jUG9zU3BhbiA9PT0gbnVsbCkge1xuICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jaGFyUG9zaXRpb25zLnN0YXJ0LnRvSGJzUG9zKCk7XG4gICAgICBsZXQgZW5kID0gdGhpcy5jaGFyUG9zaXRpb25zLmVuZC50b0hic1BvcygpO1xuXG4gICAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsKSB7XG4gICAgICAgIGxvY1Bvc1NwYW4gPSB0aGlzLiNsb2NQb3NTcGFuID0gQlJPS0VOO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jUG9zU3BhbiA9IHRoaXMuI2xvY1Bvc1NwYW4gPSBuZXcgSGJzU3Bhbih0aGlzLnNvdXJjZSwge1xuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxvY1Bvc1NwYW4gPT09IEJST0tFTiA/IG51bGwgOiBsb2NQb3NTcGFuO1xuICB9XG5cbiAgc2VyaWFsaXplKCk6IFNlcmlhbGl6ZWRTb3VyY2VTcGFuIHtcbiAgICBsZXQge1xuICAgICAgc3RhcnQ6IHsgY2hhclBvczogc3RhcnQgfSxcbiAgICAgIGVuZDogeyBjaGFyUG9zOiBlbmQgfSxcbiAgICB9ID0gdGhpcy5jaGFyUG9zaXRpb25zO1xuXG4gICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgIHJldHVybiBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtzdGFydCwgZW5kXTtcbiAgICB9XG4gIH1cblxuICB0b0NoYXJQb3NTcGFuKCk6IENoYXJQb3NpdGlvblNwYW4ge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBIYnNTcGFuIGltcGxlbWVudHMgU3BhbkRhdGEge1xuICByZWFkb25seSBraW5kID0gT2Zmc2V0S2luZC5IYnNQb3NpdGlvbjtcblxuICAjY2hhclBvc1NwYW46IENoYXJQb3NpdGlvblNwYW4gfCBCUk9LRU4gfCBudWxsID0gbnVsbDtcblxuICAvLyB0aGUgc291cmNlIGxvY2F0aW9uIGZyb20gSGFuZGxlYmFycyArIEFTVCBQbHVnaW5zIC0tIGNvdWxkIGJlIHdyb25nXG4gICNwcm92aWRlZEhic0xvYzogU291cmNlTG9jYXRpb24gfCBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IHNvdXJjZTogU291cmNlLFxuICAgIHJlYWRvbmx5IGhic1Bvc2l0aW9uczogeyBzdGFydDogSGJzUG9zaXRpb247IGVuZDogSGJzUG9zaXRpb24gfSxcbiAgICBwcm92aWRlZEhic0xvYzogU291cmNlTG9jYXRpb24gfCBudWxsID0gbnVsbFxuICApIHtcbiAgICB0aGlzLiNwcm92aWRlZEhic0xvYyA9IHByb3ZpZGVkSGJzTG9jO1xuICB9XG5cbiAgc2VyaWFsaXplKCk6IFNlcmlhbGl6ZWRDb25jcmV0ZVNvdXJjZVNwYW4ge1xuICAgIGxldCBjaGFyUG9zID0gdGhpcy50b0NoYXJQb3NTcGFuKCk7XG4gICAgcmV0dXJuIGNoYXJQb3MgPT09IG51bGwgPyBPZmZzZXRLaW5kLkJyb2tlbiA6IGNoYXJQb3Mud3JhcCgpLnNlcmlhbGl6ZSgpO1xuICB9XG5cbiAgd3JhcCgpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gbmV3IFNvdXJjZVNwYW4odGhpcyk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVByb3ZpZGVkKHBvczogU291cmNlUG9zaXRpb24sIGVkZ2U6ICdzdGFydCcgfCAnZW5kJykge1xuICAgIGlmICh0aGlzLiNwcm92aWRlZEhic0xvYykge1xuICAgICAgdGhpcy4jcHJvdmlkZWRIYnNMb2NbZWRnZV0gPSBwb3M7XG4gICAgfVxuXG4gICAgLy8gaW52YWxpZGF0ZSBjb21wdXRlZCBjaGFyYWN0ZXIgb2Zmc2V0c1xuICAgIHRoaXMuI2NoYXJQb3NTcGFuID0gbnVsbDtcbiAgICB0aGlzLiNwcm92aWRlZEhic0xvYyA9IHtcbiAgICAgIHN0YXJ0OiBwb3MsXG4gICAgICBlbmQ6IHBvcyxcbiAgICB9O1xuICB9XG5cbiAgbG9jRGlkVXBkYXRlKHsgc3RhcnQsIGVuZCB9OiB7IHN0YXJ0PzogU291cmNlUG9zaXRpb247IGVuZD86IFNvdXJjZVBvc2l0aW9uIH0pOiB2b2lkIHtcbiAgICBpZiAoc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVQcm92aWRlZChzdGFydCwgJ3N0YXJ0Jyk7XG4gICAgICB0aGlzLmhic1Bvc2l0aW9ucy5zdGFydCA9IG5ldyBIYnNQb3NpdGlvbih0aGlzLnNvdXJjZSwgc3RhcnQsIG51bGwpO1xuICAgIH1cblxuICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy51cGRhdGVQcm92aWRlZChlbmQsICdlbmQnKTtcbiAgICAgIHRoaXMuaGJzUG9zaXRpb25zLmVuZCA9IG5ldyBIYnNQb3NpdGlvbih0aGlzLnNvdXJjZSwgZW5kLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBhc1N0cmluZygpOiBzdHJpbmcge1xuICAgIGxldCBzcGFuID0gdGhpcy50b0NoYXJQb3NTcGFuKCk7XG4gICAgcmV0dXJuIHNwYW4gPT09IG51bGwgPyAnJyA6IHNwYW4uYXNTdHJpbmcoKTtcbiAgfVxuXG4gIGdldE1vZHVsZSgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnNvdXJjZS5tb2R1bGU7XG4gIH1cblxuICBnZXRTdGFydCgpOiBBbnlQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuaGJzUG9zaXRpb25zLnN0YXJ0O1xuICB9XG5cbiAgZ2V0RW5kKCk6IEFueVBvc2l0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5oYnNQb3NpdGlvbnMuZW5kO1xuICB9XG5cbiAgdG9IYnNMb2MoKTogU291cmNlTG9jYXRpb24ge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogdGhpcy5oYnNQb3NpdGlvbnMuc3RhcnQuaGJzUG9zLFxuICAgICAgZW5kOiB0aGlzLmhic1Bvc2l0aW9ucy5lbmQuaGJzUG9zLFxuICAgIH07XG4gIH1cblxuICB0b0hic1NwYW4oKTogSGJzU3BhbiB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b0NoYXJQb3NTcGFuKCk6IENoYXJQb3NpdGlvblNwYW4gfCBudWxsIHtcbiAgICBsZXQgY2hhclBvc1NwYW4gPSB0aGlzLiNjaGFyUG9zU3BhbjtcblxuICAgIGlmIChjaGFyUG9zU3BhbiA9PT0gbnVsbCkge1xuICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5oYnNQb3NpdGlvbnMuc3RhcnQudG9DaGFyUG9zKCk7XG4gICAgICBsZXQgZW5kID0gdGhpcy5oYnNQb3NpdGlvbnMuZW5kLnRvQ2hhclBvcygpO1xuXG4gICAgICBpZiAoc3RhcnQgJiYgZW5kKSB7XG4gICAgICAgIGNoYXJQb3NTcGFuID0gdGhpcy4jY2hhclBvc1NwYW4gPSBuZXcgQ2hhclBvc2l0aW9uU3Bhbih0aGlzLnNvdXJjZSwge1xuICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgIGVuZCxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFyUG9zU3BhbiA9IHRoaXMuI2NoYXJQb3NTcGFuID0gQlJPS0VOO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hhclBvc1NwYW4gPT09IEJST0tFTiA/IG51bGwgOiBjaGFyUG9zU3BhbjtcbiAgfVxufVxuXG5jbGFzcyBJbnZpc2libGVTcGFuIGltcGxlbWVudHMgU3BhbkRhdGEge1xuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBraW5kOiBPZmZzZXRLaW5kLkJyb2tlbiB8IE9mZnNldEtpbmQuSW50ZXJuYWxzU3ludGhldGljIHwgT2Zmc2V0S2luZC5Ob25FeGlzdGVudCxcbiAgICAvLyB3aGF0ZXZlciB3YXMgcHJvdmlkZWQsIHBvc3NpYmx5IGJyb2tlblxuICAgIHJlYWRvbmx5IGxvYzogU291cmNlTG9jYXRpb24sXG4gICAgLy8gaWYgdGhlIHNwYW4gcmVwcmVzZW50cyBhIHN5bnRoZXRpYyBzdHJpbmdcbiAgICByZWFkb25seSBzdHJpbmc6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICkge31cblxuICBzZXJpYWxpemUoKTogU2VyaWFsaXplZENvbmNyZXRlU291cmNlU3BhbiB7XG4gICAgc3dpdGNoICh0aGlzLmtpbmQpIHtcbiAgICAgIGNhc2UgT2Zmc2V0S2luZC5Ccm9rZW46XG4gICAgICBjYXNlIE9mZnNldEtpbmQuTm9uRXhpc3RlbnQ6XG4gICAgICAgIHJldHVybiB0aGlzLmtpbmQ7XG4gICAgICBjYXNlIE9mZnNldEtpbmQuSW50ZXJuYWxzU3ludGhldGljOlxuICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcgfHwgJyc7XG4gICAgfVxuICB9XG5cbiAgd3JhcCgpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gbmV3IFNvdXJjZVNwYW4odGhpcyk7XG4gIH1cblxuICBhc1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0cmluZyB8fCAnJztcbiAgfVxuXG4gIGxvY0RpZFVwZGF0ZSh7IHN0YXJ0LCBlbmQgfTogeyBzdGFydD86IFNvdXJjZVBvc2l0aW9uOyBlbmQ/OiBTb3VyY2VQb3NpdGlvbiB9KSB7XG4gICAgaWYgKHN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9jLnN0YXJ0ID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvYy5lbmQgPSBlbmQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0TW9kdWxlKCk6IHN0cmluZyB7XG4gICAgLy8gVE9ETzogTWFrZSB0aGlzIHJlZmxlY3QgdGhlIGFjdHVhbCBtb2R1bGUgdGhpcyBzcGFuIG9yaWdpbmF0ZWQgZnJvbVxuICAgIHJldHVybiAnYW4gdW5rbm93biBtb2R1bGUnO1xuICB9XG5cbiAgZ2V0U3RhcnQoKTogQW55UG9zaXRpb24ge1xuICAgIHJldHVybiBuZXcgSW52aXNpYmxlUG9zaXRpb24odGhpcy5raW5kLCB0aGlzLmxvYy5zdGFydCk7XG4gIH1cblxuICBnZXRFbmQoKTogQW55UG9zaXRpb24ge1xuICAgIHJldHVybiBuZXcgSW52aXNpYmxlUG9zaXRpb24odGhpcy5raW5kLCB0aGlzLmxvYy5lbmQpO1xuICB9XG5cbiAgdG9DaGFyUG9zU3BhbigpOiBJbnZpc2libGVTcGFuIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRvSGJzU3BhbigpOiBudWxsIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRvSGJzTG9jKCk6IFNvdXJjZUxvY2F0aW9uIHtcbiAgICByZXR1cm4gQlJPS0VOX0xPQ0FUSU9OO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzcGFuOiBNYXRjaEZuPFNvdXJjZVNwYW4+ID0gbWF0Y2goKG0pID0+XG4gIG1cbiAgICAud2hlbihPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLCBPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLCAobGVmdCwgcmlnaHQpID0+XG4gICAgICBuZXcgSGJzU3BhbihsZWZ0LnNvdXJjZSwge1xuICAgICAgICBzdGFydDogbGVmdCxcbiAgICAgICAgZW5kOiByaWdodCxcbiAgICAgIH0pLndyYXAoKVxuICAgIClcbiAgICAud2hlbihPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbiwgT2Zmc2V0S2luZC5DaGFyUG9zaXRpb24sIChsZWZ0LCByaWdodCkgPT5cbiAgICAgIG5ldyBDaGFyUG9zaXRpb25TcGFuKGxlZnQuc291cmNlLCB7XG4gICAgICAgIHN0YXJ0OiBsZWZ0LFxuICAgICAgICBlbmQ6IHJpZ2h0LFxuICAgICAgfSkud3JhcCgpXG4gICAgKVxuICAgIC53aGVuKE9mZnNldEtpbmQuQ2hhclBvc2l0aW9uLCBPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLCAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGxldCByaWdodENoYXJQb3MgPSByaWdodC50b0NoYXJQb3MoKTtcblxuICAgICAgaWYgKHJpZ2h0Q2hhclBvcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IEludmlzaWJsZVNwYW4oT2Zmc2V0S2luZC5Ccm9rZW4sIEJST0tFTl9MT0NBVElPTikud3JhcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNwYW4obGVmdCwgcmlnaHRDaGFyUG9zKTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC53aGVuKE9mZnNldEtpbmQuSGJzUG9zaXRpb24sIE9mZnNldEtpbmQuQ2hhclBvc2l0aW9uLCAobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgIGxldCBsZWZ0Q2hhclBvcyA9IGxlZnQudG9DaGFyUG9zKCk7XG5cbiAgICAgIGlmIChsZWZ0Q2hhclBvcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbmV3IEludmlzaWJsZVNwYW4oT2Zmc2V0S2luZC5Ccm9rZW4sIEJST0tFTl9MT0NBVElPTikud3JhcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNwYW4obGVmdENoYXJQb3MsIHJpZ2h0KTtcbiAgICAgIH1cbiAgICB9KVxuICAgIC53aGVuKElzSW52aXNpYmxlLCBNYXRjaEFueSwgKGxlZnQpID0+IG5ldyBJbnZpc2libGVTcGFuKGxlZnQua2luZCwgQlJPS0VOX0xPQ0FUSU9OKS53cmFwKCkpXG4gICAgLndoZW4oTWF0Y2hBbnksIElzSW52aXNpYmxlLCAoXywgcmlnaHQpID0+XG4gICAgICBuZXcgSW52aXNpYmxlU3BhbihyaWdodC5raW5kLCBCUk9LRU5fTE9DQVRJT04pLndyYXAoKVxuICAgIClcbik7XG5cbmV4cG9ydCB0eXBlIFNlcmlhbGl6ZWRDb25jcmV0ZVNvdXJjZVNwYW4gPVxuICB8IC8qKiBjb2xsYXBzZWQgKi8gbnVtYmVyXG4gIHwgLyoqIG5vcm1hbCAqLyBbc3RhcnQ6IG51bWJlciwgc2l6ZTogbnVtYmVyXVxuICB8IC8qKiBzeW50aGV0aWMgKi8gc3RyaW5nO1xuXG5leHBvcnQgdHlwZSBTZXJpYWxpemVkU291cmNlU3BhbiA9XG4gIHwgU2VyaWFsaXplZENvbmNyZXRlU291cmNlU3BhblxuICB8IE9mZnNldEtpbmQuTm9uRXhpc3RlbnRcbiAgfCBPZmZzZXRLaW5kLkJyb2tlbjtcbiJdLCJzb3VyY2VSb290IjoiIn0=