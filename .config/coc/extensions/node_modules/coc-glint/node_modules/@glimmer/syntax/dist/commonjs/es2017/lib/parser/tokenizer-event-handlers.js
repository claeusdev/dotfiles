"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.preprocess = preprocess;
exports.TokenizerEventHandlers = void 0;

var _util = require("@glimmer/util");

var _parser = require("@handlebars/parser");

var _simpleHtmlTokenizer = require("simple-html-tokenizer");

var _print = _interopRequireDefault(require("../generation/print"));

var _printer = require("../generation/printer");

var _source = require("../source/source");

var _span = require("../source/span");

var _syntaxError = require("../syntax-error");

var _traverse = _interopRequireDefault(require("../traversal/traverse"));

var _walker = _interopRequireDefault(require("../traversal/walker"));

var _utils = require("../utils");

var _parserBuilders = _interopRequireDefault(require("../v1/parser-builders"));

var _publicBuilders = _interopRequireDefault(require("../v1/public-builders"));

var _handlebarsNodeVisitors = require("./handlebars-node-visitors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class TokenizerEventHandlers extends _handlebarsNodeVisitors.HandlebarsNodeVisitors {
  constructor() {
    super(...arguments);
    this.tagOpenLine = 0;
    this.tagOpenColumn = 0;
  }

  reset() {
    this.currentNode = null;
  } // Comment


  beginComment() {
    this.currentNode = _parserBuilders.default.comment('', this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn));
  }

  appendToCommentData(char) {
    this.currentComment.value += char;
  }

  finishComment() {
    (0, _utils.appendChild)(this.currentElement(), this.finish(this.currentComment));
  } // Data


  beginData() {
    this.currentNode = _parserBuilders.default.text({
      chars: '',
      loc: this.offset().collapsed()
    });
  }

  appendToData(char) {
    this.currentData.chars += char;
  }

  finishData() {
    this.currentData.loc = this.currentData.loc.withEnd(this.offset());
    (0, _utils.appendChild)(this.currentElement(), this.currentData);
  } // Tags - basic


  tagOpen() {
    this.tagOpenLine = this.tokenizer.line;
    this.tagOpenColumn = this.tokenizer.column;
  }

  beginStartTag() {
    this.currentNode = {
      type: 'StartTag',
      name: '',
      attributes: [],
      modifiers: [],
      comments: [],
      selfClosing: false,
      loc: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn)
    };
  }

  beginEndTag() {
    this.currentNode = {
      type: 'EndTag',
      name: '',
      attributes: [],
      modifiers: [],
      comments: [],
      selfClosing: false,
      loc: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn)
    };
  }

  finishTag() {
    let tag = this.finish(this.currentTag);

    if (tag.type === 'StartTag') {
      this.finishStartTag();

      if (_printer.voidMap[tag.name] || tag.selfClosing) {
        this.finishEndTag(true);
      }
    } else if (tag.type === 'EndTag') {
      this.finishEndTag(false);
    }
  }

  finishStartTag() {
    let {
      name,
      attributes: attrs,
      modifiers,
      comments,
      selfClosing,
      loc
    } = this.finish(this.currentStartTag);

    let element = _parserBuilders.default.element({
      tag: name,
      selfClosing,
      attrs,
      modifiers,
      comments,
      children: [],
      blockParams: [],
      loc
    });

    this.elementStack.push(element);
  }

  finishEndTag(isVoid) {
    let tag = this.finish(this.currentTag);
    let element = this.elementStack.pop();
    let parent = this.currentElement();
    this.validateEndTag(tag, element, isVoid);
    element.loc = element.loc.withEnd(this.offset());
    (0, _utils.parseElementBlockParams)(element);
    (0, _utils.appendChild)(parent, element);
  }

  markTagAsSelfClosing() {
    this.currentTag.selfClosing = true;
  } // Tags - name


  appendToTagName(char) {
    this.currentTag.name += char;
  } // Tags - attributes


  beginAttribute() {
    let offset = this.offset();
    this.currentAttribute = {
      name: '',
      parts: [],
      currentPart: null,
      isQuoted: false,
      isDynamic: false,
      start: offset,
      valueSpan: offset.collapsed()
    };
  }

  appendToAttributeName(char) {
    this.currentAttr.name += char;
  }

  beginAttributeValue(isQuoted) {
    this.currentAttr.isQuoted = isQuoted;
    this.startTextPart();
    this.currentAttr.valueSpan = this.offset().collapsed();
  }

  appendToAttributeValue(char) {
    let parts = this.currentAttr.parts;
    let lastPart = parts[parts.length - 1];
    let current = this.currentAttr.currentPart;

    if (current) {
      current.chars += char; // update end location for each added char

      current.loc = current.loc.withEnd(this.offset());
    } else {
      // initially assume the text node is a single char
      let loc = this.offset(); // the tokenizer line/column have already been advanced, correct location info

      if (char === '\n') {
        loc = lastPart ? lastPart.loc.getEnd() : this.currentAttr.valueSpan.getStart();
      } else {
        loc = loc.move(-1);
      }

      this.currentAttr.currentPart = _parserBuilders.default.text({
        chars: char,
        loc: loc.collapsed()
      });
    }
  }

  finishAttributeValue() {
    this.finalizeTextPart();
    let tag = this.currentTag;
    let tokenizerPos = this.offset();

    if (tag.type === 'EndTag') {
      throw (0, _syntaxError.generateSyntaxError)(`Invalid end tag: closing tag must not have attributes`, this.source.spanFor({
        start: tag.loc.toJSON(),
        end: tokenizerPos.toJSON()
      }));
    }

    let {
      name,
      parts,
      start,
      isQuoted,
      isDynamic,
      valueSpan
    } = this.currentAttr;
    let value = this.assembleAttributeValue(parts, isQuoted, isDynamic, start.until(tokenizerPos));
    value.loc = valueSpan.withEnd(tokenizerPos);

    let attribute = _parserBuilders.default.attr({
      name,
      value,
      loc: start.until(tokenizerPos)
    });

    this.currentStartTag.attributes.push(attribute);
  }

  reportSyntaxError(message) {
    throw (0, _syntaxError.generateSyntaxError)(message, this.offset().collapsed());
  }

  assembleConcatenatedValue(parts) {
    for (let i = 0; i < parts.length; i++) {
      let part = parts[i];

      if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {
        throw (0, _syntaxError.generateSyntaxError)('Unsupported node in quoted attribute value: ' + part['type'], part.loc);
      }
    }

    (0, _util.assertPresent)(parts, `the concatenation parts of an element should not be empty`);
    let first = parts[0];
    let last = parts[parts.length - 1];
    return _parserBuilders.default.concat(parts, this.source.spanFor(first.loc).extend(this.source.spanFor(last.loc)));
  }

  validateEndTag(tag, element, selfClosing) {
    let error;

    if (_printer.voidMap[tag.name] && !selfClosing) {
      // EngTag is also called by StartTag for void and self-closing tags (i.e.
      // <input> or <br />, so we need to check for that here. Otherwise, we would
      // throw an error for those cases.
      error = `<${tag.name}> elements do not need end tags. You should remove it`;
    } else if (element.tag === undefined) {
      error = `Closing tag </${tag.name}> without an open tag`;
    } else if (element.tag !== tag.name) {
      error = `Closing tag </${tag.name}> did not match last open tag <${element.tag}> (on line ${element.loc.startPosition.line})`;
    }

    if (error) {
      throw (0, _syntaxError.generateSyntaxError)(error, tag.loc);
    }
  }

  assembleAttributeValue(parts, isQuoted, isDynamic, span) {
    if (isDynamic) {
      if (isQuoted) {
        return this.assembleConcatenatedValue(parts);
      } else {
        if (parts.length === 1 || parts.length === 2 && parts[1].type === 'TextNode' && parts[1].chars === '/') {
          return parts[0];
        } else {
          throw (0, _syntaxError.generateSyntaxError)(`An unquoted attribute value must be a string or a mustache, ` + `preceded by whitespace or a '=' character, and ` + `followed by whitespace, a '>' character, or '/>'`, span);
        }
      }
    } else {
      return parts.length > 0 ? parts[0] : _parserBuilders.default.text({
        chars: '',
        loc: span
      });
    }
  }

}

exports.TokenizerEventHandlers = TokenizerEventHandlers;
const syntax = {
  parse: preprocess,
  builders: _publicBuilders.default,
  print: _print.default,
  traverse: _traverse.default,
  Walker: _walker.default
};

function preprocess(input, options = {}) {
  var _a, _b, _c;

  let mode = options.mode || 'precompile';
  let source;
  let ast;

  if (typeof input === 'string') {
    source = new _source.Source(input, (_a = options.meta) === null || _a === void 0 ? void 0 : _a.moduleName);

    if (mode === 'codemod') {
      ast = (0, _parser.parseWithoutProcessing)(input, options.parseOptions);
    } else {
      ast = (0, _parser.parse)(input, options.parseOptions);
    }
  } else if (input instanceof _source.Source) {
    source = input;

    if (mode === 'codemod') {
      ast = (0, _parser.parseWithoutProcessing)(input.source, options.parseOptions);
    } else {
      ast = (0, _parser.parse)(input.source, options.parseOptions);
    }
  } else {
    source = new _source.Source('', (_b = options.meta) === null || _b === void 0 ? void 0 : _b.moduleName);
    ast = input;
  }

  let entityParser = undefined;

  if (mode === 'codemod') {
    entityParser = new _simpleHtmlTokenizer.EntityParser({});
  }

  let offsets = _span.SourceSpan.forCharPositions(source, 0, source.source.length);

  ast.loc = {
    source: '(program)',
    start: offsets.startPosition,
    end: offsets.endPosition
  };
  let program = new TokenizerEventHandlers(source, entityParser, mode).acceptTemplate(ast);

  if (options.strictMode) {
    program.blockParams = (_c = options.locals) !== null && _c !== void 0 ? _c : [];
  }

  if (options && options.plugins && options.plugins.ast) {
    for (let i = 0, l = options.plugins.ast.length; i < l; i++) {
      let transform = options.plugins.ast[i];
      let env = (0, _util.assign)({}, options, {
        syntax
      }, {
        plugins: undefined
      });
      let pluginResult = transform(env);
      (0, _traverse.default)(program, pluginResult.visitor);
    }
  }

  return program;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL3Rva2VuaXplci1ldmVudC1oYW5kbGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUVBOztBQUNBOztBQUdBOztBQUNBOztBQUNBOzs7O0FBRU0sTUFBQSxzQkFBQSxTQUFBLDhDQUFBLENBQTREO0FBQWxFLEVBQUEsV0FBQSxHQUFBOztBQUNVLFNBQUEsV0FBQSxHQUFBLENBQUE7QUFDQSxTQUFBLGFBQUEsR0FBQSxDQUFBO0FBc1JUOztBQXBSQyxFQUFBLEtBQUssR0FBQTtBQUNILFNBQUEsV0FBQSxHQUFBLElBQUE7QUFMOEQsR0FBQSxDQVFoRTs7O0FBRUEsRUFBQSxZQUFZLEdBQUE7QUFDVixTQUFBLFdBQUEsR0FBbUIsd0JBQUEsT0FBQSxDQUFBLEVBQUEsRUFBYyxLQUFBLE1BQUEsQ0FBQSxTQUFBLENBQXNCLEtBQXRCLFdBQUEsRUFBd0MsS0FBekUsYUFBaUMsQ0FBZCxDQUFuQjtBQUNEOztBQUVELEVBQUEsbUJBQW1CLENBQUEsSUFBQSxFQUFhO0FBQzlCLFNBQUEsY0FBQSxDQUFBLEtBQUEsSUFBQSxJQUFBO0FBQ0Q7O0FBRUQsRUFBQSxhQUFhLEdBQUE7QUFDWCw0QkFBWSxLQUFELGNBQUMsRUFBWixFQUFtQyxLQUFBLE1BQUEsQ0FBWSxLQUEvQyxjQUFtQyxDQUFuQztBQW5COEQsR0FBQSxDQXNCaEU7OztBQUVBLEVBQUEsU0FBUyxHQUFBO0FBQ1AsU0FBQSxXQUFBLEdBQW1CLHdCQUFBLElBQUEsQ0FBTztBQUN4QixNQUFBLEtBQUssRUFEbUIsRUFBQTtBQUV4QixNQUFBLEdBQUcsRUFBRSxLQUFBLE1BQUEsR0FBQSxTQUFBO0FBRm1CLEtBQVAsQ0FBbkI7QUFJRDs7QUFFRCxFQUFBLFlBQVksQ0FBQSxJQUFBLEVBQWE7QUFD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QUU7QUFBWCxPQUFoQyxDQUFoQztBQUVBLFVBQUksWUFBWSxHQUFHLFNBQVMsQ0FBNUIsR0FBNEIsQ0FBNUI7QUFFQSw2QkFBUSxPQUFSLEVBQWtCLFlBQVksQ0FBOUIsT0FBQTtBQUNEO0FBQ0Y7O0FBRUQsU0FBQSxPQUFBO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IGFzc2VydFByZXNlbnQsIGFzc2lnbiB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuaW1wb3J0IHsgcGFyc2UsIHBhcnNlV2l0aG91dFByb2Nlc3NpbmcgfSBmcm9tICdAaGFuZGxlYmFycy9wYXJzZXInO1xuaW1wb3J0IHsgRW50aXR5UGFyc2VyIH0gZnJvbSAnc2ltcGxlLWh0bWwtdG9rZW5pemVyJztcblxuaW1wb3J0IHByaW50IGZyb20gJy4uL2dlbmVyYXRpb24vcHJpbnQnO1xuaW1wb3J0IHsgdm9pZE1hcCB9IGZyb20gJy4uL2dlbmVyYXRpb24vcHJpbnRlcic7XG5pbXBvcnQgeyBUYWcgfSBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IHsgU291cmNlIH0gZnJvbSAnLi4vc291cmNlL3NvdXJjZSc7XG5pbXBvcnQgeyBTb3VyY2VPZmZzZXQsIFNvdXJjZVNwYW4gfSBmcm9tICcuLi9zb3VyY2Uvc3Bhbic7XG5pbXBvcnQgeyBnZW5lcmF0ZVN5bnRheEVycm9yIH0gZnJvbSAnLi4vc3ludGF4LWVycm9yJztcbmltcG9ydCB0cmF2ZXJzZSBmcm9tICcuLi90cmF2ZXJzYWwvdHJhdmVyc2UnO1xuaW1wb3J0IHsgTm9kZVZpc2l0b3IgfSBmcm9tICcuLi90cmF2ZXJzYWwvdmlzaXRvcic7XG5pbXBvcnQgV2Fsa2VyIGZyb20gJy4uL3RyYXZlcnNhbC93YWxrZXInO1xuaW1wb3J0IHsgYXBwZW5kQ2hpbGQsIHBhcnNlRWxlbWVudEJsb2NrUGFyYW1zIH0gZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0ICogYXMgQVNUdjEgZnJvbSAnLi4vdjEvYXBpJztcbmltcG9ydCAqIGFzIEhCUyBmcm9tICcuLi92MS9oYW5kbGViYXJzLWFzdCc7XG5pbXBvcnQgYiBmcm9tICcuLi92MS9wYXJzZXItYnVpbGRlcnMnO1xuaW1wb3J0IHB1YmxpY0J1aWxkZXIgZnJvbSAnLi4vdjEvcHVibGljLWJ1aWxkZXJzJztcbmltcG9ydCB7IEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMgfSBmcm9tICcuL2hhbmRsZWJhcnMtbm9kZS12aXNpdG9ycyc7XG5cbmV4cG9ydCBjbGFzcyBUb2tlbml6ZXJFdmVudEhhbmRsZXJzIGV4dGVuZHMgSGFuZGxlYmFyc05vZGVWaXNpdG9ycyB7XG4gIHByaXZhdGUgdGFnT3BlbkxpbmUgPSAwO1xuICBwcml2YXRlIHRhZ09wZW5Db2x1bW4gPSAwO1xuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBudWxsO1xuICB9XG5cbiAgLy8gQ29tbWVudFxuXG4gIGJlZ2luQ29tbWVudCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnROb2RlID0gYi5jb21tZW50KCcnLCB0aGlzLnNvdXJjZS5vZmZzZXRGb3IodGhpcy50YWdPcGVuTGluZSwgdGhpcy50YWdPcGVuQ29sdW1uKSk7XG4gIH1cblxuICBhcHBlbmRUb0NvbW1lbnREYXRhKGNoYXI6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudENvbW1lbnQudmFsdWUgKz0gY2hhcjtcbiAgfVxuXG4gIGZpbmlzaENvbW1lbnQoKTogdm9pZCB7XG4gICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCB0aGlzLmZpbmlzaCh0aGlzLmN1cnJlbnRDb21tZW50KSk7XG4gIH1cblxuICAvLyBEYXRhXG5cbiAgYmVnaW5EYXRhKCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBiLnRleHQoe1xuICAgICAgY2hhcnM6ICcnLFxuICAgICAgbG9jOiB0aGlzLm9mZnNldCgpLmNvbGxhcHNlZCgpLFxuICAgIH0pO1xuICB9XG5cbiAgYXBwZW5kVG9EYXRhKGNoYXI6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudERhdGEuY2hhcnMgKz0gY2hhcjtcbiAgfVxuXG4gIGZpbmlzaERhdGEoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50RGF0YS5sb2MgPSB0aGlzLmN1cnJlbnREYXRhLmxvYy53aXRoRW5kKHRoaXMub2Zmc2V0KCkpO1xuXG4gICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCB0aGlzLmN1cnJlbnREYXRhKTtcbiAgfVxuXG4gIC8vIFRhZ3MgLSBiYXNpY1xuXG4gIHRhZ09wZW4oKTogdm9pZCB7XG4gICAgdGhpcy50YWdPcGVuTGluZSA9IHRoaXMudG9rZW5pemVyLmxpbmU7XG4gICAgdGhpcy50YWdPcGVuQ29sdW1uID0gdGhpcy50b2tlbml6ZXIuY29sdW1uO1xuICB9XG5cbiAgYmVnaW5TdGFydFRhZygpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnROb2RlID0ge1xuICAgICAgdHlwZTogJ1N0YXJ0VGFnJyxcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICBtb2RpZmllcnM6IFtdLFxuICAgICAgY29tbWVudHM6IFtdLFxuICAgICAgc2VsZkNsb3Npbmc6IGZhbHNlLFxuICAgICAgbG9jOiB0aGlzLnNvdXJjZS5vZmZzZXRGb3IodGhpcy50YWdPcGVuTGluZSwgdGhpcy50YWdPcGVuQ29sdW1uKSxcbiAgICB9O1xuICB9XG5cbiAgYmVnaW5FbmRUYWcoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IHtcbiAgICAgIHR5cGU6ICdFbmRUYWcnLFxuICAgICAgbmFtZTogJycsXG4gICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgIG1vZGlmaWVyczogW10sXG4gICAgICBjb21tZW50czogW10sXG4gICAgICBzZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgICBsb2M6IHRoaXMuc291cmNlLm9mZnNldEZvcih0aGlzLnRhZ09wZW5MaW5lLCB0aGlzLnRhZ09wZW5Db2x1bW4pLFxuICAgIH07XG4gIH1cblxuICBmaW5pc2hUYWcoKTogdm9pZCB7XG4gICAgbGV0IHRhZyA9IHRoaXMuZmluaXNoKHRoaXMuY3VycmVudFRhZyk7XG5cbiAgICBpZiAodGFnLnR5cGUgPT09ICdTdGFydFRhZycpIHtcbiAgICAgIHRoaXMuZmluaXNoU3RhcnRUYWcoKTtcblxuICAgICAgaWYgKHZvaWRNYXBbdGFnLm5hbWVdIHx8IHRhZy5zZWxmQ2xvc2luZykge1xuICAgICAgICB0aGlzLmZpbmlzaEVuZFRhZyh0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRhZy50eXBlID09PSAnRW5kVGFnJykge1xuICAgICAgdGhpcy5maW5pc2hFbmRUYWcoZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGZpbmlzaFN0YXJ0VGFnKCk6IHZvaWQge1xuICAgIGxldCB7IG5hbWUsIGF0dHJpYnV0ZXM6IGF0dHJzLCBtb2RpZmllcnMsIGNvbW1lbnRzLCBzZWxmQ2xvc2luZywgbG9jIH0gPSB0aGlzLmZpbmlzaChcbiAgICAgIHRoaXMuY3VycmVudFN0YXJ0VGFnXG4gICAgKTtcblxuICAgIGxldCBlbGVtZW50ID0gYi5lbGVtZW50KHtcbiAgICAgIHRhZzogbmFtZSxcbiAgICAgIHNlbGZDbG9zaW5nLFxuICAgICAgYXR0cnMsXG4gICAgICBtb2RpZmllcnMsXG4gICAgICBjb21tZW50cyxcbiAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgIGJsb2NrUGFyYW1zOiBbXSxcbiAgICAgIGxvYyxcbiAgICB9KTtcbiAgICB0aGlzLmVsZW1lbnRTdGFjay5wdXNoKGVsZW1lbnQpO1xuICB9XG5cbiAgZmluaXNoRW5kVGFnKGlzVm9pZDogYm9vbGVhbik6IHZvaWQge1xuICAgIGxldCB0YWcgPSB0aGlzLmZpbmlzaCh0aGlzLmN1cnJlbnRUYWcpO1xuXG4gICAgbGV0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKSBhcyBBU1R2MS5FbGVtZW50Tm9kZTtcbiAgICBsZXQgcGFyZW50ID0gdGhpcy5jdXJyZW50RWxlbWVudCgpO1xuXG4gICAgdGhpcy52YWxpZGF0ZUVuZFRhZyh0YWcsIGVsZW1lbnQsIGlzVm9pZCk7XG5cbiAgICBlbGVtZW50LmxvYyA9IGVsZW1lbnQubG9jLndpdGhFbmQodGhpcy5vZmZzZXQoKSk7XG4gICAgcGFyc2VFbGVtZW50QmxvY2tQYXJhbXMoZWxlbWVudCk7XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50LCBlbGVtZW50KTtcbiAgfVxuXG4gIG1hcmtUYWdBc1NlbGZDbG9zaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhZy5zZWxmQ2xvc2luZyA9IHRydWU7XG4gIH1cblxuICAvLyBUYWdzIC0gbmFtZVxuXG4gIGFwcGVuZFRvVGFnTmFtZShjaGFyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRUYWcubmFtZSArPSBjaGFyO1xuICB9XG5cbiAgLy8gVGFncyAtIGF0dHJpYnV0ZXNcblxuICBiZWdpbkF0dHJpYnV0ZSgpOiB2b2lkIHtcbiAgICBsZXQgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZSA9IHtcbiAgICAgIG5hbWU6ICcnLFxuICAgICAgcGFydHM6IFtdLFxuICAgICAgY3VycmVudFBhcnQ6IG51bGwsXG4gICAgICBpc1F1b3RlZDogZmFsc2UsXG4gICAgICBpc0R5bmFtaWM6IGZhbHNlLFxuICAgICAgc3RhcnQ6IG9mZnNldCxcbiAgICAgIHZhbHVlU3Bhbjogb2Zmc2V0LmNvbGxhcHNlZCgpLFxuICAgIH07XG4gIH1cblxuICBhcHBlbmRUb0F0dHJpYnV0ZU5hbWUoY2hhcjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50QXR0ci5uYW1lICs9IGNoYXI7XG4gIH1cblxuICBiZWdpbkF0dHJpYnV0ZVZhbHVlKGlzUXVvdGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50QXR0ci5pc1F1b3RlZCA9IGlzUXVvdGVkO1xuICAgIHRoaXMuc3RhcnRUZXh0UGFydCgpO1xuICAgIHRoaXMuY3VycmVudEF0dHIudmFsdWVTcGFuID0gdGhpcy5vZmZzZXQoKS5jb2xsYXBzZWQoKTtcbiAgfVxuXG4gIGFwcGVuZFRvQXR0cmlidXRlVmFsdWUoY2hhcjogc3RyaW5nKTogdm9pZCB7XG4gICAgbGV0IHBhcnRzID0gdGhpcy5jdXJyZW50QXR0ci5wYXJ0cztcbiAgICBsZXQgbGFzdFBhcnQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcblxuICAgIGxldCBjdXJyZW50ID0gdGhpcy5jdXJyZW50QXR0ci5jdXJyZW50UGFydDtcblxuICAgIGlmIChjdXJyZW50KSB7XG4gICAgICBjdXJyZW50LmNoYXJzICs9IGNoYXI7XG5cbiAgICAgIC8vIHVwZGF0ZSBlbmQgbG9jYXRpb24gZm9yIGVhY2ggYWRkZWQgY2hhclxuICAgICAgY3VycmVudC5sb2MgPSBjdXJyZW50LmxvYy53aXRoRW5kKHRoaXMub2Zmc2V0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbml0aWFsbHkgYXNzdW1lIHRoZSB0ZXh0IG5vZGUgaXMgYSBzaW5nbGUgY2hhclxuICAgICAgbGV0IGxvYzogU291cmNlT2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuICAgICAgLy8gdGhlIHRva2VuaXplciBsaW5lL2NvbHVtbiBoYXZlIGFscmVhZHkgYmVlbiBhZHZhbmNlZCwgY29ycmVjdCBsb2NhdGlvbiBpbmZvXG4gICAgICBpZiAoY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgbG9jID0gbGFzdFBhcnQgPyBsYXN0UGFydC5sb2MuZ2V0RW5kKCkgOiB0aGlzLmN1cnJlbnRBdHRyLnZhbHVlU3Bhbi5nZXRTdGFydCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jID0gbG9jLm1vdmUoLTEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnRBdHRyLmN1cnJlbnRQYXJ0ID0gYi50ZXh0KHsgY2hhcnM6IGNoYXIsIGxvYzogbG9jLmNvbGxhcHNlZCgpIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZpbmlzaEF0dHJpYnV0ZVZhbHVlKCk6IHZvaWQge1xuICAgIHRoaXMuZmluYWxpemVUZXh0UGFydCgpO1xuXG4gICAgbGV0IHRhZyA9IHRoaXMuY3VycmVudFRhZztcbiAgICBsZXQgdG9rZW5pemVyUG9zID0gdGhpcy5vZmZzZXQoKTtcblxuICAgIGlmICh0YWcudHlwZSA9PT0gJ0VuZFRhZycpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGVuZCB0YWc6IGNsb3NpbmcgdGFnIG11c3Qgbm90IGhhdmUgYXR0cmlidXRlc2AsXG4gICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IoeyBzdGFydDogdGFnLmxvYy50b0pTT04oKSwgZW5kOiB0b2tlbml6ZXJQb3MudG9KU09OKCkgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHsgbmFtZSwgcGFydHMsIHN0YXJ0LCBpc1F1b3RlZCwgaXNEeW5hbWljLCB2YWx1ZVNwYW4gfSA9IHRoaXMuY3VycmVudEF0dHI7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5hc3NlbWJsZUF0dHJpYnV0ZVZhbHVlKHBhcnRzLCBpc1F1b3RlZCwgaXNEeW5hbWljLCBzdGFydC51bnRpbCh0b2tlbml6ZXJQb3MpKTtcbiAgICB2YWx1ZS5sb2MgPSB2YWx1ZVNwYW4ud2l0aEVuZCh0b2tlbml6ZXJQb3MpO1xuXG4gICAgbGV0IGF0dHJpYnV0ZSA9IGIuYXR0cih7IG5hbWUsIHZhbHVlLCBsb2M6IHN0YXJ0LnVudGlsKHRva2VuaXplclBvcykgfSk7XG5cbiAgICB0aGlzLmN1cnJlbnRTdGFydFRhZy5hdHRyaWJ1dGVzLnB1c2goYXR0cmlidXRlKTtcbiAgfVxuXG4gIHJlcG9ydFN5bnRheEVycm9yKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IobWVzc2FnZSwgdGhpcy5vZmZzZXQoKS5jb2xsYXBzZWQoKSk7XG4gIH1cblxuICBhc3NlbWJsZUNvbmNhdGVuYXRlZFZhbHVlKFxuICAgIHBhcnRzOiAoQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZSlbXVxuICApOiBBU1R2MS5Db25jYXRTdGF0ZW1lbnQge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBwYXJ0OiBBU1R2MS5CYXNlTm9kZSA9IHBhcnRzW2ldO1xuXG4gICAgICBpZiAocGFydC50eXBlICE9PSAnTXVzdGFjaGVTdGF0ZW1lbnQnICYmIHBhcnQudHlwZSAhPT0gJ1RleHROb2RlJykge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICdVbnN1cHBvcnRlZCBub2RlIGluIHF1b3RlZCBhdHRyaWJ1dGUgdmFsdWU6ICcgKyBwYXJ0Wyd0eXBlJ10sXG4gICAgICAgICAgcGFydC5sb2NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3NlcnRQcmVzZW50KHBhcnRzLCBgdGhlIGNvbmNhdGVuYXRpb24gcGFydHMgb2YgYW4gZWxlbWVudCBzaG91bGQgbm90IGJlIGVtcHR5YCk7XG5cbiAgICBsZXQgZmlyc3QgPSBwYXJ0c1swXTtcbiAgICBsZXQgbGFzdCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgcmV0dXJuIGIuY29uY2F0KHBhcnRzLCB0aGlzLnNvdXJjZS5zcGFuRm9yKGZpcnN0LmxvYykuZXh0ZW5kKHRoaXMuc291cmNlLnNwYW5Gb3IobGFzdC5sb2MpKSk7XG4gIH1cblxuICB2YWxpZGF0ZUVuZFRhZyhcbiAgICB0YWc6IFRhZzwnU3RhcnRUYWcnIHwgJ0VuZFRhZyc+LFxuICAgIGVsZW1lbnQ6IEFTVHYxLkVsZW1lbnROb2RlLFxuICAgIHNlbGZDbG9zaW5nOiBib29sZWFuXG4gICk6IHZvaWQge1xuICAgIGxldCBlcnJvcjtcblxuICAgIGlmICh2b2lkTWFwW3RhZy5uYW1lXSAmJiAhc2VsZkNsb3NpbmcpIHtcbiAgICAgIC8vIEVuZ1RhZyBpcyBhbHNvIGNhbGxlZCBieSBTdGFydFRhZyBmb3Igdm9pZCBhbmQgc2VsZi1jbG9zaW5nIHRhZ3MgKGkuZS5cbiAgICAgIC8vIDxpbnB1dD4gb3IgPGJyIC8+LCBzbyB3ZSBuZWVkIHRvIGNoZWNrIGZvciB0aGF0IGhlcmUuIE90aGVyd2lzZSwgd2Ugd291bGRcbiAgICAgIC8vIHRocm93IGFuIGVycm9yIGZvciB0aG9zZSBjYXNlcy5cbiAgICAgIGVycm9yID0gYDwke3RhZy5uYW1lfT4gZWxlbWVudHMgZG8gbm90IG5lZWQgZW5kIHRhZ3MuIFlvdSBzaG91bGQgcmVtb3ZlIGl0YDtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQudGFnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gYENsb3NpbmcgdGFnIDwvJHt0YWcubmFtZX0+IHdpdGhvdXQgYW4gb3BlbiB0YWdgO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50YWcgIT09IHRhZy5uYW1lKSB7XG4gICAgICBlcnJvciA9IGBDbG9zaW5nIHRhZyA8LyR7dGFnLm5hbWV9PiBkaWQgbm90IG1hdGNoIGxhc3Qgb3BlbiB0YWcgPCR7ZWxlbWVudC50YWd9PiAob24gbGluZSAke2VsZW1lbnQubG9jLnN0YXJ0UG9zaXRpb24ubGluZX0pYDtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoZXJyb3IsIHRhZy5sb2MpO1xuICAgIH1cbiAgfVxuXG4gIGFzc2VtYmxlQXR0cmlidXRlVmFsdWUoXG4gICAgcGFydHM6IChBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCB8IEFTVHYxLlRleHROb2RlKVtdLFxuICAgIGlzUXVvdGVkOiBib29sZWFuLFxuICAgIGlzRHluYW1pYzogYm9vbGVhbixcbiAgICBzcGFuOiBTb3VyY2VTcGFuXG4gICk6IEFTVHYxLkNvbmNhdFN0YXRlbWVudCB8IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50IHwgQVNUdjEuVGV4dE5vZGUge1xuICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgIGlmIChpc1F1b3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3NlbWJsZUNvbmNhdGVuYXRlZFZhbHVlKHBhcnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJ0cy5sZW5ndGggPT09IDEgfHxcbiAgICAgICAgICAocGFydHMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICBwYXJ0c1sxXS50eXBlID09PSAnVGV4dE5vZGUnICYmXG4gICAgICAgICAgICAocGFydHNbMV0gYXMgQVNUdjEuVGV4dE5vZGUpLmNoYXJzID09PSAnLycpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBwYXJ0c1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgICAgYEFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIG9yIGEgbXVzdGFjaGUsIGAgK1xuICAgICAgICAgICAgICBgcHJlY2VkZWQgYnkgd2hpdGVzcGFjZSBvciBhICc9JyBjaGFyYWN0ZXIsIGFuZCBgICtcbiAgICAgICAgICAgICAgYGZvbGxvd2VkIGJ5IHdoaXRlc3BhY2UsIGEgJz4nIGNoYXJhY3Rlciwgb3IgJy8+J2AsXG4gICAgICAgICAgICBzcGFuXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzWzBdIDogYi50ZXh0KHsgY2hhcnM6ICcnLCBsb2M6IHNwYW4gfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICBBU1RQbHVnaW5zIGNhbiBtYWtlIGNoYW5nZXMgdG8gdGhlIEdsaW1tZXIgdGVtcGxhdGUgQVNUIGJlZm9yZVxuICBjb21waWxhdGlvbiBiZWdpbnMuXG4qL1xuZXhwb3J0IGludGVyZmFjZSBBU1RQbHVnaW5CdWlsZGVyIHtcbiAgKGVudjogQVNUUGx1Z2luRW52aXJvbm1lbnQpOiBBU1RQbHVnaW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQVNUUGx1Z2luIHtcbiAgbmFtZTogc3RyaW5nO1xuICB2aXNpdG9yOiBOb2RlVmlzaXRvcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBU1RQbHVnaW5FbnZpcm9ubWVudCB7XG4gIG1ldGE/OiBvYmplY3Q7XG4gIHN5bnRheDogU3ludGF4O1xufVxuXG5pbnRlcmZhY2UgSGFuZGxlYmFyc1BhcnNlT3B0aW9ucyB7XG4gIHNyY05hbWU/OiBzdHJpbmc7XG4gIGlnbm9yZVN0YW5kYWxvbmU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlSWRGbiB7XG4gIChzcmM6IHN0cmluZyk6IE9wdGlvbjxzdHJpbmc+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZWNvbXBpbGVPcHRpb25zIGV4dGVuZHMgUHJlcHJvY2Vzc09wdGlvbnMge1xuICBpZD86IFRlbXBsYXRlSWRGbjtcbiAgY3VzdG9taXplQ29tcG9uZW50TmFtZT8oaW5wdXQ6IHN0cmluZyk6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVwcm9jZXNzT3B0aW9ucyB7XG4gIHN0cmljdE1vZGU/OiBib29sZWFuO1xuICBsb2NhbHM/OiBzdHJpbmdbXTtcbiAgbWV0YT86IHtcbiAgICBtb2R1bGVOYW1lPzogc3RyaW5nO1xuICB9O1xuICBwbHVnaW5zPzoge1xuICAgIGFzdD86IEFTVFBsdWdpbkJ1aWxkZXJbXTtcbiAgfTtcbiAgcGFyc2VPcHRpb25zPzogSGFuZGxlYmFyc1BhcnNlT3B0aW9ucztcbiAgY3VzdG9taXplQ29tcG9uZW50TmFtZT8oaW5wdXQ6IHN0cmluZyk6IHN0cmluZztcblxuICAvKipcbiAgICBVc2VmdWwgZm9yIHNwZWNpZnlpbmcgYSBncm91cCBvZiBvcHRpb25zIHRvZ2V0aGVyLlxuXG4gICAgV2hlbiBgJ2NvZGVtb2QnYCB3ZSBkaXNhYmxlIGFsbCB3aGl0ZXNwYWNlIGNvbnRyb2wgaW4gaGFuZGxlYmFyc1xuICAgICh0byBwcmVzZXJ2ZSBhcyBtdWNoIGFzIHBvc3NpYmxlKSBhbmQgd2UgYWxzbyBhdm9pZCBhbnlcbiAgICBlc2NhcGluZy91bmVzY2FwaW5nIG9mIEhUTUwgZW50aXR5IGNvZGVzLlxuICAgKi9cbiAgbW9kZT86ICdjb2RlbW9kJyB8ICdwcmVjb21waWxlJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTeW50YXgge1xuICBwYXJzZTogdHlwZW9mIHByZXByb2Nlc3M7XG4gIGJ1aWxkZXJzOiB0eXBlb2YgcHVibGljQnVpbGRlcjtcbiAgcHJpbnQ6IHR5cGVvZiBwcmludDtcbiAgdHJhdmVyc2U6IHR5cGVvZiB0cmF2ZXJzZTtcbiAgV2Fsa2VyOiB0eXBlb2YgV2Fsa2VyO1xufVxuXG5jb25zdCBzeW50YXg6IFN5bnRheCA9IHtcbiAgcGFyc2U6IHByZXByb2Nlc3MsXG4gIGJ1aWxkZXJzOiBwdWJsaWNCdWlsZGVyLFxuICBwcmludCxcbiAgdHJhdmVyc2UsXG4gIFdhbGtlcixcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzKFxuICBpbnB1dDogc3RyaW5nIHwgU291cmNlIHwgSEJTLlByb2dyYW0sXG4gIG9wdGlvbnM6IFByZXByb2Nlc3NPcHRpb25zID0ge31cbik6IEFTVHYxLlRlbXBsYXRlIHtcbiAgbGV0IG1vZGUgPSBvcHRpb25zLm1vZGUgfHwgJ3ByZWNvbXBpbGUnO1xuXG4gIGxldCBzb3VyY2U6IFNvdXJjZTtcbiAgbGV0IGFzdDogSEJTLlByb2dyYW07XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgc291cmNlID0gbmV3IFNvdXJjZShpbnB1dCwgb3B0aW9ucy5tZXRhPy5tb2R1bGVOYW1lKTtcblxuICAgIGlmIChtb2RlID09PSAnY29kZW1vZCcpIHtcbiAgICAgIGFzdCA9IHBhcnNlV2l0aG91dFByb2Nlc3NpbmcoaW5wdXQsIG9wdGlvbnMucGFyc2VPcHRpb25zKSBhcyBIQlMuUHJvZ3JhbTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXN0ID0gcGFyc2UoaW5wdXQsIG9wdGlvbnMucGFyc2VPcHRpb25zKSBhcyBIQlMuUHJvZ3JhbTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTb3VyY2UpIHtcbiAgICBzb3VyY2UgPSBpbnB1dDtcblxuICAgIGlmIChtb2RlID09PSAnY29kZW1vZCcpIHtcbiAgICAgIGFzdCA9IHBhcnNlV2l0aG91dFByb2Nlc3NpbmcoaW5wdXQuc291cmNlLCBvcHRpb25zLnBhcnNlT3B0aW9ucykgYXMgSEJTLlByb2dyYW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzdCA9IHBhcnNlKGlucHV0LnNvdXJjZSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpIGFzIEhCUy5Qcm9ncmFtO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzb3VyY2UgPSBuZXcgU291cmNlKCcnLCBvcHRpb25zLm1ldGE/Lm1vZHVsZU5hbWUpO1xuICAgIGFzdCA9IGlucHV0O1xuICB9XG5cbiAgbGV0IGVudGl0eVBhcnNlciA9IHVuZGVmaW5lZDtcbiAgaWYgKG1vZGUgPT09ICdjb2RlbW9kJykge1xuICAgIGVudGl0eVBhcnNlciA9IG5ldyBFbnRpdHlQYXJzZXIoe30pO1xuICB9XG5cbiAgbGV0IG9mZnNldHMgPSBTb3VyY2VTcGFuLmZvckNoYXJQb3NpdGlvbnMoc291cmNlLCAwLCBzb3VyY2Uuc291cmNlLmxlbmd0aCk7XG4gIGFzdC5sb2MgPSB7XG4gICAgc291cmNlOiAnKHByb2dyYW0pJyxcbiAgICBzdGFydDogb2Zmc2V0cy5zdGFydFBvc2l0aW9uLFxuICAgIGVuZDogb2Zmc2V0cy5lbmRQb3NpdGlvbixcbiAgfTtcblxuICBsZXQgcHJvZ3JhbSA9IG5ldyBUb2tlbml6ZXJFdmVudEhhbmRsZXJzKHNvdXJjZSwgZW50aXR5UGFyc2VyLCBtb2RlKS5hY2NlcHRUZW1wbGF0ZShhc3QpO1xuXG4gIGlmIChvcHRpb25zLnN0cmljdE1vZGUpIHtcbiAgICBwcm9ncmFtLmJsb2NrUGFyYW1zID0gb3B0aW9ucy5sb2NhbHMgPz8gW107XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBsdWdpbnMgJiYgb3B0aW9ucy5wbHVnaW5zLmFzdCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gb3B0aW9ucy5wbHVnaW5zLmFzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxldCB0cmFuc2Zvcm0gPSBvcHRpb25zLnBsdWdpbnMuYXN0W2ldO1xuICAgICAgbGV0IGVudjogQVNUUGx1Z2luRW52aXJvbm1lbnQgPSBhc3NpZ24oe30sIG9wdGlvbnMsIHsgc3ludGF4IH0sIHsgcGx1Z2luczogdW5kZWZpbmVkIH0pO1xuXG4gICAgICBsZXQgcGx1Z2luUmVzdWx0ID0gdHJhbnNmb3JtKGVudik7XG5cbiAgICAgIHRyYXZlcnNlKHByb2dyYW0sIHBsdWdpblJlc3VsdC52aXNpdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJvZ3JhbTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=