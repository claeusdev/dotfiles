function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

import { assertPresent, assign } from '@glimmer/util';
import { parse, parseWithoutProcessing } from '@handlebars/parser';
import { EntityParser } from 'simple-html-tokenizer';
import print from '../generation/print';
import { voidMap } from '../generation/printer';
import { Source } from '../source/source';
import { SourceSpan } from '../source/span';
import { generateSyntaxError } from '../syntax-error';
import traverse from '../traversal/traverse';
import Walker from '../traversal/walker';
import { appendChild, parseElementBlockParams } from '../utils';
import b from '../v1/parser-builders';
import publicBuilder from '../v1/public-builders';
import { HandlebarsNodeVisitors } from './handlebars-node-visitors';
export var TokenizerEventHandlers = /*#__PURE__*/function (_HandlebarsNodeVisito) {
  _inheritsLoose(TokenizerEventHandlers, _HandlebarsNodeVisito);

  function TokenizerEventHandlers() {
    var _this;

    _this = _HandlebarsNodeVisito.apply(this, arguments) || this;
    _this.tagOpenLine = 0;
    _this.tagOpenColumn = 0;
    return _this;
  }

  var _proto = TokenizerEventHandlers.prototype;

  _proto.reset = function reset() {
    this.currentNode = null;
  } // Comment
  ;

  _proto.beginComment = function beginComment() {
    this.currentNode = b.comment('', this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn));
  };

  _proto.appendToCommentData = function appendToCommentData(_char) {
    this.currentComment.value += _char;
  };

  _proto.finishComment = function finishComment() {
    appendChild(this.currentElement(), this.finish(this.currentComment));
  } // Data
  ;

  _proto.beginData = function beginData() {
    this.currentNode = b.text({
      chars: '',
      loc: this.offset().collapsed()
    });
  };

  _proto.appendToData = function appendToData(_char2) {
    this.currentData.chars += _char2;
  };

  _proto.finishData = function finishData() {
    this.currentData.loc = this.currentData.loc.withEnd(this.offset());
    appendChild(this.currentElement(), this.currentData);
  } // Tags - basic
  ;

  _proto.tagOpen = function tagOpen() {
    this.tagOpenLine = this.tokenizer.line;
    this.tagOpenColumn = this.tokenizer.column;
  };

  _proto.beginStartTag = function beginStartTag() {
    this.currentNode = {
      type: 'StartTag',
      name: '',
      attributes: [],
      modifiers: [],
      comments: [],
      selfClosing: false,
      loc: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn)
    };
  };

  _proto.beginEndTag = function beginEndTag() {
    this.currentNode = {
      type: 'EndTag',
      name: '',
      attributes: [],
      modifiers: [],
      comments: [],
      selfClosing: false,
      loc: this.source.offsetFor(this.tagOpenLine, this.tagOpenColumn)
    };
  };

  _proto.finishTag = function finishTag() {
    var tag = this.finish(this.currentTag);

    if (tag.type === 'StartTag') {
      this.finishStartTag();

      if (voidMap[tag.name] || tag.selfClosing) {
        this.finishEndTag(true);
      }
    } else if (tag.type === 'EndTag') {
      this.finishEndTag(false);
    }
  };

  _proto.finishStartTag = function finishStartTag() {
    var _this$finish = this.finish(this.currentStartTag),
        name = _this$finish.name,
        attrs = _this$finish.attributes,
        modifiers = _this$finish.modifiers,
        comments = _this$finish.comments,
        selfClosing = _this$finish.selfClosing,
        loc = _this$finish.loc;

    var element = b.element({
      tag: name,
      selfClosing: selfClosing,
      attrs: attrs,
      modifiers: modifiers,
      comments: comments,
      children: [],
      blockParams: [],
      loc: loc
    });
    this.elementStack.push(element);
  };

  _proto.finishEndTag = function finishEndTag(isVoid) {
    var tag = this.finish(this.currentTag);
    var element = this.elementStack.pop();
    var parent = this.currentElement();
    this.validateEndTag(tag, element, isVoid);
    element.loc = element.loc.withEnd(this.offset());
    parseElementBlockParams(element);
    appendChild(parent, element);
  };

  _proto.markTagAsSelfClosing = function markTagAsSelfClosing() {
    this.currentTag.selfClosing = true;
  } // Tags - name
  ;

  _proto.appendToTagName = function appendToTagName(_char3) {
    this.currentTag.name += _char3;
  } // Tags - attributes
  ;

  _proto.beginAttribute = function beginAttribute() {
    var offset = this.offset();
    this.currentAttribute = {
      name: '',
      parts: [],
      currentPart: null,
      isQuoted: false,
      isDynamic: false,
      start: offset,
      valueSpan: offset.collapsed()
    };
  };

  _proto.appendToAttributeName = function appendToAttributeName(_char4) {
    this.currentAttr.name += _char4;
  };

  _proto.beginAttributeValue = function beginAttributeValue(isQuoted) {
    this.currentAttr.isQuoted = isQuoted;
    this.startTextPart();
    this.currentAttr.valueSpan = this.offset().collapsed();
  };

  _proto.appendToAttributeValue = function appendToAttributeValue(_char5) {
    var parts = this.currentAttr.parts;
    var lastPart = parts[parts.length - 1];
    var current = this.currentAttr.currentPart;

    if (current) {
      current.chars += _char5; // update end location for each added char

      current.loc = current.loc.withEnd(this.offset());
    } else {
      // initially assume the text node is a single char
      var loc = this.offset(); // the tokenizer line/column have already been advanced, correct location info

      if (_char5 === '\n') {
        loc = lastPart ? lastPart.loc.getEnd() : this.currentAttr.valueSpan.getStart();
      } else {
        loc = loc.move(-1);
      }

      this.currentAttr.currentPart = b.text({
        chars: _char5,
        loc: loc.collapsed()
      });
    }
  };

  _proto.finishAttributeValue = function finishAttributeValue() {
    this.finalizeTextPart();
    var tag = this.currentTag;
    var tokenizerPos = this.offset();

    if (tag.type === 'EndTag') {
      throw generateSyntaxError("Invalid end tag: closing tag must not have attributes", this.source.spanFor({
        start: tag.loc.toJSON(),
        end: tokenizerPos.toJSON()
      }));
    }

    var _this$currentAttr = this.currentAttr,
        name = _this$currentAttr.name,
        parts = _this$currentAttr.parts,
        start = _this$currentAttr.start,
        isQuoted = _this$currentAttr.isQuoted,
        isDynamic = _this$currentAttr.isDynamic,
        valueSpan = _this$currentAttr.valueSpan;
    var value = this.assembleAttributeValue(parts, isQuoted, isDynamic, start.until(tokenizerPos));
    value.loc = valueSpan.withEnd(tokenizerPos);
    var attribute = b.attr({
      name: name,
      value: value,
      loc: start.until(tokenizerPos)
    });
    this.currentStartTag.attributes.push(attribute);
  };

  _proto.reportSyntaxError = function reportSyntaxError(message) {
    throw generateSyntaxError(message, this.offset().collapsed());
  };

  _proto.assembleConcatenatedValue = function assembleConcatenatedValue(parts) {
    for (var i = 0; i < parts.length; i++) {
      var part = parts[i];

      if (part.type !== 'MustacheStatement' && part.type !== 'TextNode') {
        throw generateSyntaxError('Unsupported node in quoted attribute value: ' + part['type'], part.loc);
      }
    }

    assertPresent(parts, "the concatenation parts of an element should not be empty");
    var first = parts[0];
    var last = parts[parts.length - 1];
    return b.concat(parts, this.source.spanFor(first.loc).extend(this.source.spanFor(last.loc)));
  };

  _proto.validateEndTag = function validateEndTag(tag, element, selfClosing) {
    var error;

    if (voidMap[tag.name] && !selfClosing) {
      // EngTag is also called by StartTag for void and self-closing tags (i.e.
      // <input> or <br />, so we need to check for that here. Otherwise, we would
      // throw an error for those cases.
      error = "<" + tag.name + "> elements do not need end tags. You should remove it";
    } else if (element.tag === undefined) {
      error = "Closing tag </" + tag.name + "> without an open tag";
    } else if (element.tag !== tag.name) {
      error = "Closing tag </" + tag.name + "> did not match last open tag <" + element.tag + "> (on line " + element.loc.startPosition.line + ")";
    }

    if (error) {
      throw generateSyntaxError(error, tag.loc);
    }
  };

  _proto.assembleAttributeValue = function assembleAttributeValue(parts, isQuoted, isDynamic, span) {
    if (isDynamic) {
      if (isQuoted) {
        return this.assembleConcatenatedValue(parts);
      } else {
        if (parts.length === 1 || parts.length === 2 && parts[1].type === 'TextNode' && parts[1].chars === '/') {
          return parts[0];
        } else {
          throw generateSyntaxError("An unquoted attribute value must be a string or a mustache, " + "preceded by whitespace or a '=' character, and " + "followed by whitespace, a '>' character, or '/>'", span);
        }
      }
    } else {
      return parts.length > 0 ? parts[0] : b.text({
        chars: '',
        loc: span
      });
    }
  };

  return TokenizerEventHandlers;
}(HandlebarsNodeVisitors);
var syntax = {
  parse: preprocess,
  builders: publicBuilder,
  print: print,
  traverse: traverse,
  Walker: Walker
};
export function preprocess(input, options) {
  if (options === void 0) {
    options = {};
  }

  var _a, _b, _c;

  var mode = options.mode || 'precompile';
  var source;
  var ast;

  if (typeof input === 'string') {
    source = new Source(input, (_a = options.meta) === null || _a === void 0 ? void 0 : _a.moduleName);

    if (mode === 'codemod') {
      ast = parseWithoutProcessing(input, options.parseOptions);
    } else {
      ast = parse(input, options.parseOptions);
    }
  } else if (input instanceof Source) {
    source = input;

    if (mode === 'codemod') {
      ast = parseWithoutProcessing(input.source, options.parseOptions);
    } else {
      ast = parse(input.source, options.parseOptions);
    }
  } else {
    source = new Source('', (_b = options.meta) === null || _b === void 0 ? void 0 : _b.moduleName);
    ast = input;
  }

  var entityParser = undefined;

  if (mode === 'codemod') {
    entityParser = new EntityParser({});
  }

  var offsets = SourceSpan.forCharPositions(source, 0, source.source.length);
  ast.loc = {
    source: '(program)',
    start: offsets.startPosition,
    end: offsets.endPosition
  };
  var program = new TokenizerEventHandlers(source, entityParser, mode).acceptTemplate(ast);

  if (options.strictMode) {
    program.blockParams = (_c = options.locals) !== null && _c !== void 0 ? _c : [];
  }

  if (options && options.plugins && options.plugins.ast) {
    for (var i = 0, l = options.plugins.ast.length; i < l; i++) {
      var transform = options.plugins.ast[i];
      var env = assign({}, options, {
        syntax: syntax
      }, {
        plugins: undefined
      });
      var pluginResult = transform(env);
      traverse(program, pluginResult.visitor);
    }
  }

  return program;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL3Rva2VuaXplci1ldmVudC1oYW5kbGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUNBLFNBQUEsYUFBQSxFQUFBLE1BQUEsUUFBQSxlQUFBO0FBQ0EsU0FBQSxLQUFBLEVBQUEsc0JBQUEsUUFBQSxvQkFBQTtBQUNBLFNBQUEsWUFBQSxRQUFBLHVCQUFBO0FBRUEsT0FBQSxLQUFBLE1BQUEscUJBQUE7QUFDQSxTQUFBLE9BQUEsUUFBQSx1QkFBQTtBQUVBLFNBQUEsTUFBQSxRQUFBLGtCQUFBO0FBQ0EsU0FBQSxVQUFBLFFBQUEsZ0JBQUE7QUFDQSxTQUFBLG1CQUFBLFFBQUEsaUJBQUE7QUFDQSxPQUFBLFFBQUEsTUFBQSx1QkFBQTtBQUVBLE9BQUEsTUFBQSxNQUFBLHFCQUFBO0FBQ0EsU0FBQSxXQUFBLEVBQUEsdUJBQUEsUUFBQSxVQUFBO0FBR0EsT0FBQSxDQUFBLE1BQUEsdUJBQUE7QUFDQSxPQUFBLGFBQUEsTUFBQSx1QkFBQTtBQUNBLFNBQUEsc0JBQUEsUUFBQSw0QkFBQTtBQUVBLFdBQU0sc0JBQU47QUFBQTs7QUFBQSxvQ0FBQTtBQUFBOzs7QUFDVSxVQUFBLFdBQUEsR0FBQSxDQUFBO0FBQ0EsVUFBQSxhQUFBLEdBQUEsQ0FBQTtBQUZWO0FBd1JDOztBQXhSRDs7QUFBQSxTQUlFLEtBSkYsR0FJRSxpQkFBSztBQUNILFNBQUEsV0FBQSxHQUFBLElBQUE7QUFMOEQsR0FBbEUsQ0FRRTtBQVJGOztBQUFBLFNBVUUsWUFWRixHQVVFLHdCQUFZO0FBQ1YsU0FBQSxXQUFBLEdBQW1CLENBQUMsQ0FBRCxPQUFBLENBQUEsRUFBQSxFQUFjLEtBQUEsTUFBQSxDQUFBLFNBQUEsQ0FBc0IsS0FBdEIsV0FBQSxFQUF3QyxLQUF6RSxhQUFpQyxDQUFkLENBQW5CO0FBQ0QsR0FaSDs7QUFBQSxTQWNFLG1CQWRGLEdBY0UsNkJBQW1CLEtBQW5CLEVB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QUFHLE9BQU8sQ0FBUCxPQUFBLENBQUEsR0FBQSxDQUFoQixDQUFnQixDQUFoQjtBQUNBLFVBQUksR0FBRyxHQUF5QixNQUFNLENBQUEsRUFBQSxFQUFBLE9BQUEsRUFBYztBQUFFLFFBQUEsTUFBQSxFQUFBO0FBQUYsT0FBZCxFQUEwQjtBQUFFLFFBQUEsT0FBTyxFQUFFO0FBQVgsT0FBMUIsQ0FBdEM7QUFFQSxVQUFJLFlBQVksR0FBRyxTQUFTLENBQTVCLEdBQTRCLENBQTVCO0FBRUEsTUFBQSxRQUFRLENBQUEsT0FBQSxFQUFVLFlBQVksQ0FBOUIsT0FBUSxDQUFSO0FBQ0Q7QUFDRjs7QUFFRCxTQUFBLE9BQUE7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgYXNzZXJ0UHJlc2VudCwgYXNzaWduIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBwYXJzZSwgcGFyc2VXaXRob3V0UHJvY2Vzc2luZyB9IGZyb20gJ0BoYW5kbGViYXJzL3BhcnNlcic7XG5pbXBvcnQgeyBFbnRpdHlQYXJzZXIgfSBmcm9tICdzaW1wbGUtaHRtbC10b2tlbml6ZXInO1xuXG5pbXBvcnQgcHJpbnQgZnJvbSAnLi4vZ2VuZXJhdGlvbi9wcmludCc7XG5pbXBvcnQgeyB2b2lkTWFwIH0gZnJvbSAnLi4vZ2VuZXJhdGlvbi9wcmludGVyJztcbmltcG9ydCB7IFRhZyB9IGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQgeyBTb3VyY2UgfSBmcm9tICcuLi9zb3VyY2Uvc291cmNlJztcbmltcG9ydCB7IFNvdXJjZU9mZnNldCwgU291cmNlU3BhbiB9IGZyb20gJy4uL3NvdXJjZS9zcGFuJztcbmltcG9ydCB7IGdlbmVyYXRlU3ludGF4RXJyb3IgfSBmcm9tICcuLi9zeW50YXgtZXJyb3InO1xuaW1wb3J0IHRyYXZlcnNlIGZyb20gJy4uL3RyYXZlcnNhbC90cmF2ZXJzZSc7XG5pbXBvcnQgeyBOb2RlVmlzaXRvciB9IGZyb20gJy4uL3RyYXZlcnNhbC92aXNpdG9yJztcbmltcG9ydCBXYWxrZXIgZnJvbSAnLi4vdHJhdmVyc2FsL3dhbGtlcic7XG5pbXBvcnQgeyBhcHBlbmRDaGlsZCwgcGFyc2VFbGVtZW50QmxvY2tQYXJhbXMgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuLi92MS9hcGknO1xuaW1wb3J0ICogYXMgSEJTIGZyb20gJy4uL3YxL2hhbmRsZWJhcnMtYXN0JztcbmltcG9ydCBiIGZyb20gJy4uL3YxL3BhcnNlci1idWlsZGVycyc7XG5pbXBvcnQgcHVibGljQnVpbGRlciBmcm9tICcuLi92MS9wdWJsaWMtYnVpbGRlcnMnO1xuaW1wb3J0IHsgSGFuZGxlYmFyc05vZGVWaXNpdG9ycyB9IGZyb20gJy4vaGFuZGxlYmFycy1ub2RlLXZpc2l0b3JzJztcblxuZXhwb3J0IGNsYXNzIFRva2VuaXplckV2ZW50SGFuZGxlcnMgZXh0ZW5kcyBIYW5kbGViYXJzTm9kZVZpc2l0b3JzIHtcbiAgcHJpdmF0ZSB0YWdPcGVuTGluZSA9IDA7XG4gIHByaXZhdGUgdGFnT3BlbkNvbHVtbiA9IDA7XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gIH1cblxuICAvLyBDb21tZW50XG5cbiAgYmVnaW5Db21tZW50KCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSBiLmNvbW1lbnQoJycsIHRoaXMuc291cmNlLm9mZnNldEZvcih0aGlzLnRhZ09wZW5MaW5lLCB0aGlzLnRhZ09wZW5Db2x1bW4pKTtcbiAgfVxuXG4gIGFwcGVuZFRvQ29tbWVudERhdGEoY2hhcjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50Q29tbWVudC52YWx1ZSArPSBjaGFyO1xuICB9XG5cbiAgZmluaXNoQ29tbWVudCgpOiB2b2lkIHtcbiAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIHRoaXMuZmluaXNoKHRoaXMuY3VycmVudENvbW1lbnQpKTtcbiAgfVxuXG4gIC8vIERhdGFcblxuICBiZWdpbkRhdGEoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50Tm9kZSA9IGIudGV4dCh7XG4gICAgICBjaGFyczogJycsXG4gICAgICBsb2M6IHRoaXMub2Zmc2V0KCkuY29sbGFwc2VkKCksXG4gICAgfSk7XG4gIH1cblxuICBhcHBlbmRUb0RhdGEoY2hhcjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50RGF0YS5jaGFycyArPSBjaGFyO1xuICB9XG5cbiAgZmluaXNoRGF0YSgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnREYXRhLmxvYyA9IHRoaXMuY3VycmVudERhdGEubG9jLndpdGhFbmQodGhpcy5vZmZzZXQoKSk7XG5cbiAgICBhcHBlbmRDaGlsZCh0aGlzLmN1cnJlbnRFbGVtZW50KCksIHRoaXMuY3VycmVudERhdGEpO1xuICB9XG5cbiAgLy8gVGFncyAtIGJhc2ljXG5cbiAgdGFnT3BlbigpOiB2b2lkIHtcbiAgICB0aGlzLnRhZ09wZW5MaW5lID0gdGhpcy50b2tlbml6ZXIubGluZTtcbiAgICB0aGlzLnRhZ09wZW5Db2x1bW4gPSB0aGlzLnRva2VuaXplci5jb2x1bW47XG4gIH1cblxuICBiZWdpblN0YXJ0VGFnKCk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudE5vZGUgPSB7XG4gICAgICB0eXBlOiAnU3RhcnRUYWcnLFxuICAgICAgbmFtZTogJycsXG4gICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgIG1vZGlmaWVyczogW10sXG4gICAgICBjb21tZW50czogW10sXG4gICAgICBzZWxmQ2xvc2luZzogZmFsc2UsXG4gICAgICBsb2M6IHRoaXMuc291cmNlLm9mZnNldEZvcih0aGlzLnRhZ09wZW5MaW5lLCB0aGlzLnRhZ09wZW5Db2x1bW4pLFxuICAgIH07XG4gIH1cblxuICBiZWdpbkVuZFRhZygpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnROb2RlID0ge1xuICAgICAgdHlwZTogJ0VuZFRhZycsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgbW9kaWZpZXJzOiBbXSxcbiAgICAgIGNvbW1lbnRzOiBbXSxcbiAgICAgIHNlbGZDbG9zaW5nOiBmYWxzZSxcbiAgICAgIGxvYzogdGhpcy5zb3VyY2Uub2Zmc2V0Rm9yKHRoaXMudGFnT3BlbkxpbmUsIHRoaXMudGFnT3BlbkNvbHVtbiksXG4gICAgfTtcbiAgfVxuXG4gIGZpbmlzaFRhZygpOiB2b2lkIHtcbiAgICBsZXQgdGFnID0gdGhpcy5maW5pc2godGhpcy5jdXJyZW50VGFnKTtcblxuICAgIGlmICh0YWcudHlwZSA9PT0gJ1N0YXJ0VGFnJykge1xuICAgICAgdGhpcy5maW5pc2hTdGFydFRhZygpO1xuXG4gICAgICBpZiAodm9pZE1hcFt0YWcubmFtZV0gfHwgdGFnLnNlbGZDbG9zaW5nKSB7XG4gICAgICAgIHRoaXMuZmluaXNoRW5kVGFnKHRydWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGFnLnR5cGUgPT09ICdFbmRUYWcnKSB7XG4gICAgICB0aGlzLmZpbmlzaEVuZFRhZyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZmluaXNoU3RhcnRUYWcoKTogdm9pZCB7XG4gICAgbGV0IHsgbmFtZSwgYXR0cmlidXRlczogYXR0cnMsIG1vZGlmaWVycywgY29tbWVudHMsIHNlbGZDbG9zaW5nLCBsb2MgfSA9IHRoaXMuZmluaXNoKFxuICAgICAgdGhpcy5jdXJyZW50U3RhcnRUYWdcbiAgICApO1xuXG4gICAgbGV0IGVsZW1lbnQgPSBiLmVsZW1lbnQoe1xuICAgICAgdGFnOiBuYW1lLFxuICAgICAgc2VsZkNsb3NpbmcsXG4gICAgICBhdHRycyxcbiAgICAgIG1vZGlmaWVycyxcbiAgICAgIGNvbW1lbnRzLFxuICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgYmxvY2tQYXJhbXM6IFtdLFxuICAgICAgbG9jLFxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudFN0YWNrLnB1c2goZWxlbWVudCk7XG4gIH1cblxuICBmaW5pc2hFbmRUYWcoaXNWb2lkOiBib29sZWFuKTogdm9pZCB7XG4gICAgbGV0IHRhZyA9IHRoaXMuZmluaXNoKHRoaXMuY3VycmVudFRhZyk7XG5cbiAgICBsZXQgZWxlbWVudCA9IHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpIGFzIEFTVHYxLkVsZW1lbnROb2RlO1xuICAgIGxldCBwYXJlbnQgPSB0aGlzLmN1cnJlbnRFbGVtZW50KCk7XG5cbiAgICB0aGlzLnZhbGlkYXRlRW5kVGFnKHRhZywgZWxlbWVudCwgaXNWb2lkKTtcblxuICAgIGVsZW1lbnQubG9jID0gZWxlbWVudC5sb2Mud2l0aEVuZCh0aGlzLm9mZnNldCgpKTtcbiAgICBwYXJzZUVsZW1lbnRCbG9ja1BhcmFtcyhlbGVtZW50KTtcbiAgICBhcHBlbmRDaGlsZChwYXJlbnQsIGVsZW1lbnQpO1xuICB9XG5cbiAgbWFya1RhZ0FzU2VsZkNsb3NpbmcoKTogdm9pZCB7XG4gICAgdGhpcy5jdXJyZW50VGFnLnNlbGZDbG9zaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRhZ3MgLSBuYW1lXG5cbiAgYXBwZW5kVG9UYWdOYW1lKGNoYXI6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuY3VycmVudFRhZy5uYW1lICs9IGNoYXI7XG4gIH1cblxuICAvLyBUYWdzIC0gYXR0cmlidXRlc1xuXG4gIGJlZ2luQXR0cmlidXRlKCk6IHZvaWQge1xuICAgIGxldCBvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG4gICAgdGhpcy5jdXJyZW50QXR0cmlidXRlID0ge1xuICAgICAgbmFtZTogJycsXG4gICAgICBwYXJ0czogW10sXG4gICAgICBjdXJyZW50UGFydDogbnVsbCxcbiAgICAgIGlzUXVvdGVkOiBmYWxzZSxcbiAgICAgIGlzRHluYW1pYzogZmFsc2UsXG4gICAgICBzdGFydDogb2Zmc2V0LFxuICAgICAgdmFsdWVTcGFuOiBvZmZzZXQuY29sbGFwc2VkKCksXG4gICAgfTtcbiAgfVxuXG4gIGFwcGVuZFRvQXR0cmlidXRlTmFtZShjaGFyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRBdHRyLm5hbWUgKz0gY2hhcjtcbiAgfVxuXG4gIGJlZ2luQXR0cmlidXRlVmFsdWUoaXNRdW90ZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRBdHRyLmlzUXVvdGVkID0gaXNRdW90ZWQ7XG4gICAgdGhpcy5zdGFydFRleHRQYXJ0KCk7XG4gICAgdGhpcy5jdXJyZW50QXR0ci52YWx1ZVNwYW4gPSB0aGlzLm9mZnNldCgpLmNvbGxhcHNlZCgpO1xuICB9XG5cbiAgYXBwZW5kVG9BdHRyaWJ1dGVWYWx1ZShjaGFyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBsZXQgcGFydHMgPSB0aGlzLmN1cnJlbnRBdHRyLnBhcnRzO1xuICAgIGxldCBsYXN0UGFydCA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgbGV0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnRBdHRyLmN1cnJlbnRQYXJ0O1xuXG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnQuY2hhcnMgKz0gY2hhcjtcblxuICAgICAgLy8gdXBkYXRlIGVuZCBsb2NhdGlvbiBmb3IgZWFjaCBhZGRlZCBjaGFyXG4gICAgICBjdXJyZW50LmxvYyA9IGN1cnJlbnQubG9jLndpdGhFbmQodGhpcy5vZmZzZXQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluaXRpYWxseSBhc3N1bWUgdGhlIHRleHQgbm9kZSBpcyBhIHNpbmdsZSBjaGFyXG4gICAgICBsZXQgbG9jOiBTb3VyY2VPZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG4gICAgICAvLyB0aGUgdG9rZW5pemVyIGxpbmUvY29sdW1uIGhhdmUgYWxyZWFkeSBiZWVuIGFkdmFuY2VkLCBjb3JyZWN0IGxvY2F0aW9uIGluZm9cbiAgICAgIGlmIChjaGFyID09PSAnXFxuJykge1xuICAgICAgICBsb2MgPSBsYXN0UGFydCA/IGxhc3RQYXJ0LmxvYy5nZXRFbmQoKSA6IHRoaXMuY3VycmVudEF0dHIudmFsdWVTcGFuLmdldFN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2MgPSBsb2MubW92ZSgtMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudEF0dHIuY3VycmVudFBhcnQgPSBiLnRleHQoeyBjaGFyczogY2hhciwgbG9jOiBsb2MuY29sbGFwc2VkKCkgfSk7XG4gICAgfVxuICB9XG5cbiAgZmluaXNoQXR0cmlidXRlVmFsdWUoKTogdm9pZCB7XG4gICAgdGhpcy5maW5hbGl6ZVRleHRQYXJ0KCk7XG5cbiAgICBsZXQgdGFnID0gdGhpcy5jdXJyZW50VGFnO1xuICAgIGxldCB0b2tlbml6ZXJQb3MgPSB0aGlzLm9mZnNldCgpO1xuXG4gICAgaWYgKHRhZy50eXBlID09PSAnRW5kVGFnJykge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYEludmFsaWQgZW5kIHRhZzogY2xvc2luZyB0YWcgbXVzdCBub3QgaGF2ZSBhdHRyaWJ1dGVzYCxcbiAgICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcih7IHN0YXJ0OiB0YWcubG9jLnRvSlNPTigpLCBlbmQ6IHRva2VuaXplclBvcy50b0pTT04oKSB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgeyBuYW1lLCBwYXJ0cywgc3RhcnQsIGlzUXVvdGVkLCBpc0R5bmFtaWMsIHZhbHVlU3BhbiB9ID0gdGhpcy5jdXJyZW50QXR0cjtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmFzc2VtYmxlQXR0cmlidXRlVmFsdWUocGFydHMsIGlzUXVvdGVkLCBpc0R5bmFtaWMsIHN0YXJ0LnVudGlsKHRva2VuaXplclBvcykpO1xuICAgIHZhbHVlLmxvYyA9IHZhbHVlU3Bhbi53aXRoRW5kKHRva2VuaXplclBvcyk7XG5cbiAgICBsZXQgYXR0cmlidXRlID0gYi5hdHRyKHsgbmFtZSwgdmFsdWUsIGxvYzogc3RhcnQudW50aWwodG9rZW5pemVyUG9zKSB9KTtcblxuICAgIHRoaXMuY3VycmVudFN0YXJ0VGFnLmF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUpO1xuICB9XG5cbiAgcmVwb3J0U3ludGF4RXJyb3IobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihtZXNzYWdlLCB0aGlzLm9mZnNldCgpLmNvbGxhcHNlZCgpKTtcbiAgfVxuXG4gIGFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUoXG4gICAgcGFydHM6IChBU1R2MS5NdXN0YWNoZVN0YXRlbWVudCB8IEFTVHYxLlRleHROb2RlKVtdXG4gICk6IEFTVHYxLkNvbmNhdFN0YXRlbWVudCB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhcnQ6IEFTVHYxLkJhc2VOb2RlID0gcGFydHNbaV07XG5cbiAgICAgIGlmIChwYXJ0LnR5cGUgIT09ICdNdXN0YWNoZVN0YXRlbWVudCcgJiYgcGFydC50eXBlICE9PSAnVGV4dE5vZGUnKSB7XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgJ1Vuc3VwcG9ydGVkIG5vZGUgaW4gcXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZTogJyArIHBhcnRbJ3R5cGUnXSxcbiAgICAgICAgICBwYXJ0LmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzc2VydFByZXNlbnQocGFydHMsIGB0aGUgY29uY2F0ZW5hdGlvbiBwYXJ0cyBvZiBhbiBlbGVtZW50IHNob3VsZCBub3QgYmUgZW1wdHlgKTtcblxuICAgIGxldCBmaXJzdCA9IHBhcnRzWzBdO1xuICAgIGxldCBsYXN0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG5cbiAgICByZXR1cm4gYi5jb25jYXQocGFydHMsIHRoaXMuc291cmNlLnNwYW5Gb3IoZmlyc3QubG9jKS5leHRlbmQodGhpcy5zb3VyY2Uuc3BhbkZvcihsYXN0LmxvYykpKTtcbiAgfVxuXG4gIHZhbGlkYXRlRW5kVGFnKFxuICAgIHRhZzogVGFnPCdTdGFydFRhZycgfCAnRW5kVGFnJz4sXG4gICAgZWxlbWVudDogQVNUdjEuRWxlbWVudE5vZGUsXG4gICAgc2VsZkNsb3Npbmc6IGJvb2xlYW5cbiAgKTogdm9pZCB7XG4gICAgbGV0IGVycm9yO1xuXG4gICAgaWYgKHZvaWRNYXBbdGFnLm5hbWVdICYmICFzZWxmQ2xvc2luZykge1xuICAgICAgLy8gRW5nVGFnIGlzIGFsc28gY2FsbGVkIGJ5IFN0YXJ0VGFnIGZvciB2b2lkIGFuZCBzZWxmLWNsb3NpbmcgdGFncyAoaS5lLlxuICAgICAgLy8gPGlucHV0PiBvciA8YnIgLz4sIHNvIHdlIG5lZWQgdG8gY2hlY2sgZm9yIHRoYXQgaGVyZS4gT3RoZXJ3aXNlLCB3ZSB3b3VsZFxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgZm9yIHRob3NlIGNhc2VzLlxuICAgICAgZXJyb3IgPSBgPCR7dGFnLm5hbWV9PiBlbGVtZW50cyBkbyBub3QgbmVlZCBlbmQgdGFncy4gWW91IHNob3VsZCByZW1vdmUgaXRgO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBgQ2xvc2luZyB0YWcgPC8ke3RhZy5uYW1lfT4gd2l0aG91dCBhbiBvcGVuIHRhZ2A7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LnRhZyAhPT0gdGFnLm5hbWUpIHtcbiAgICAgIGVycm9yID0gYENsb3NpbmcgdGFnIDwvJHt0YWcubmFtZX0+IGRpZCBub3QgbWF0Y2ggbGFzdCBvcGVuIHRhZyA8JHtlbGVtZW50LnRhZ30+IChvbiBsaW5lICR7ZWxlbWVudC5sb2Muc3RhcnRQb3NpdGlvbi5saW5lfSlgO1xuICAgIH1cblxuICAgIGlmIChlcnJvcikge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihlcnJvciwgdGFnLmxvYyk7XG4gICAgfVxuICB9XG5cbiAgYXNzZW1ibGVBdHRyaWJ1dGVWYWx1ZShcbiAgICBwYXJ0czogKEFTVHYxLk11c3RhY2hlU3RhdGVtZW50IHwgQVNUdjEuVGV4dE5vZGUpW10sXG4gICAgaXNRdW90ZWQ6IGJvb2xlYW4sXG4gICAgaXNEeW5hbWljOiBib29sZWFuLFxuICAgIHNwYW46IFNvdXJjZVNwYW5cbiAgKTogQVNUdjEuQ29uY2F0U3RhdGVtZW50IHwgQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCBBU1R2MS5UZXh0Tm9kZSB7XG4gICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgaWYgKGlzUXVvdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzc2VtYmxlQ29uY2F0ZW5hdGVkVmFsdWUocGFydHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBhcnRzLmxlbmd0aCA9PT0gMSB8fFxuICAgICAgICAgIChwYXJ0cy5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHBhcnRzWzFdLnR5cGUgPT09ICdUZXh0Tm9kZScgJiZcbiAgICAgICAgICAgIChwYXJ0c1sxXSBhcyBBU1R2MS5UZXh0Tm9kZSkuY2hhcnMgPT09ICcvJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnRzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgICBgQW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcgb3IgYSBtdXN0YWNoZSwgYCArXG4gICAgICAgICAgICAgIGBwcmVjZWRlZCBieSB3aGl0ZXNwYWNlIG9yIGEgJz0nIGNoYXJhY3RlciwgYW5kIGAgK1xuICAgICAgICAgICAgICBgZm9sbG93ZWQgYnkgd2hpdGVzcGFjZSwgYSAnPicgY2hhcmFjdGVyLCBvciAnLz4nYCxcbiAgICAgICAgICAgIHNwYW5cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiBiLnRleHQoeyBjaGFyczogJycsIGxvYzogc3BhbiB9KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gIEFTVFBsdWdpbnMgY2FuIG1ha2UgY2hhbmdlcyB0byB0aGUgR2xpbW1lciB0ZW1wbGF0ZSBBU1QgYmVmb3JlXG4gIGNvbXBpbGF0aW9uIGJlZ2lucy5cbiovXG5leHBvcnQgaW50ZXJmYWNlIEFTVFBsdWdpbkJ1aWxkZXIge1xuICAoZW52OiBBU1RQbHVnaW5FbnZpcm9ubWVudCk6IEFTVFBsdWdpbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBU1RQbHVnaW4ge1xuICBuYW1lOiBzdHJpbmc7XG4gIHZpc2l0b3I6IE5vZGVWaXNpdG9yO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFTVFBsdWdpbkVudmlyb25tZW50IHtcbiAgbWV0YT86IG9iamVjdDtcbiAgc3ludGF4OiBTeW50YXg7XG59XG5cbmludGVyZmFjZSBIYW5kbGViYXJzUGFyc2VPcHRpb25zIHtcbiAgc3JjTmFtZT86IHN0cmluZztcbiAgaWdub3JlU3RhbmRhbG9uZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVtcGxhdGVJZEZuIHtcbiAgKHNyYzogc3RyaW5nKTogT3B0aW9uPHN0cmluZz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJlY29tcGlsZU9wdGlvbnMgZXh0ZW5kcyBQcmVwcm9jZXNzT3B0aW9ucyB7XG4gIGlkPzogVGVtcGxhdGVJZEZuO1xuICBjdXN0b21pemVDb21wb25lbnROYW1lPyhpbnB1dDogc3RyaW5nKTogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByZXByb2Nlc3NPcHRpb25zIHtcbiAgc3RyaWN0TW9kZT86IGJvb2xlYW47XG4gIGxvY2Fscz86IHN0cmluZ1tdO1xuICBtZXRhPzoge1xuICAgIG1vZHVsZU5hbWU/OiBzdHJpbmc7XG4gIH07XG4gIHBsdWdpbnM/OiB7XG4gICAgYXN0PzogQVNUUGx1Z2luQnVpbGRlcltdO1xuICB9O1xuICBwYXJzZU9wdGlvbnM/OiBIYW5kbGViYXJzUGFyc2VPcHRpb25zO1xuICBjdXN0b21pemVDb21wb25lbnROYW1lPyhpbnB1dDogc3RyaW5nKTogc3RyaW5nO1xuXG4gIC8qKlxuICAgIFVzZWZ1bCBmb3Igc3BlY2lmeWluZyBhIGdyb3VwIG9mIG9wdGlvbnMgdG9nZXRoZXIuXG5cbiAgICBXaGVuIGAnY29kZW1vZCdgIHdlIGRpc2FibGUgYWxsIHdoaXRlc3BhY2UgY29udHJvbCBpbiBoYW5kbGViYXJzXG4gICAgKHRvIHByZXNlcnZlIGFzIG11Y2ggYXMgcG9zc2libGUpIGFuZCB3ZSBhbHNvIGF2b2lkIGFueVxuICAgIGVzY2FwaW5nL3VuZXNjYXBpbmcgb2YgSFRNTCBlbnRpdHkgY29kZXMuXG4gICAqL1xuICBtb2RlPzogJ2NvZGVtb2QnIHwgJ3ByZWNvbXBpbGUnO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN5bnRheCB7XG4gIHBhcnNlOiB0eXBlb2YgcHJlcHJvY2VzcztcbiAgYnVpbGRlcnM6IHR5cGVvZiBwdWJsaWNCdWlsZGVyO1xuICBwcmludDogdHlwZW9mIHByaW50O1xuICB0cmF2ZXJzZTogdHlwZW9mIHRyYXZlcnNlO1xuICBXYWxrZXI6IHR5cGVvZiBXYWxrZXI7XG59XG5cbmNvbnN0IHN5bnRheDogU3ludGF4ID0ge1xuICBwYXJzZTogcHJlcHJvY2VzcyxcbiAgYnVpbGRlcnM6IHB1YmxpY0J1aWxkZXIsXG4gIHByaW50LFxuICB0cmF2ZXJzZSxcbiAgV2Fsa2VyLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHByZXByb2Nlc3MoXG4gIGlucHV0OiBzdHJpbmcgfCBTb3VyY2UgfCBIQlMuUHJvZ3JhbSxcbiAgb3B0aW9uczogUHJlcHJvY2Vzc09wdGlvbnMgPSB7fVxuKTogQVNUdjEuVGVtcGxhdGUge1xuICBsZXQgbW9kZSA9IG9wdGlvbnMubW9kZSB8fCAncHJlY29tcGlsZSc7XG5cbiAgbGV0IHNvdXJjZTogU291cmNlO1xuICBsZXQgYXN0OiBIQlMuUHJvZ3JhbTtcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2UgPSBuZXcgU291cmNlKGlucHV0LCBvcHRpb25zLm1ldGE/Lm1vZHVsZU5hbWUpO1xuXG4gICAgaWYgKG1vZGUgPT09ICdjb2RlbW9kJykge1xuICAgICAgYXN0ID0gcGFyc2VXaXRob3V0UHJvY2Vzc2luZyhpbnB1dCwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpIGFzIEhCUy5Qcm9ncmFtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3QgPSBwYXJzZShpbnB1dCwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpIGFzIEhCUy5Qcm9ncmFtO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbnB1dCBpbnN0YW5jZW9mIFNvdXJjZSkge1xuICAgIHNvdXJjZSA9IGlucHV0O1xuXG4gICAgaWYgKG1vZGUgPT09ICdjb2RlbW9kJykge1xuICAgICAgYXN0ID0gcGFyc2VXaXRob3V0UHJvY2Vzc2luZyhpbnB1dC5zb3VyY2UsIG9wdGlvbnMucGFyc2VPcHRpb25zKSBhcyBIQlMuUHJvZ3JhbTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXN0ID0gcGFyc2UoaW5wdXQuc291cmNlLCBvcHRpb25zLnBhcnNlT3B0aW9ucykgYXMgSEJTLlByb2dyYW07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNvdXJjZSA9IG5ldyBTb3VyY2UoJycsIG9wdGlvbnMubWV0YT8ubW9kdWxlTmFtZSk7XG4gICAgYXN0ID0gaW5wdXQ7XG4gIH1cblxuICBsZXQgZW50aXR5UGFyc2VyID0gdW5kZWZpbmVkO1xuICBpZiAobW9kZSA9PT0gJ2NvZGVtb2QnKSB7XG4gICAgZW50aXR5UGFyc2VyID0gbmV3IEVudGl0eVBhcnNlcih7fSk7XG4gIH1cblxuICBsZXQgb2Zmc2V0cyA9IFNvdXJjZVNwYW4uZm9yQ2hhclBvc2l0aW9ucyhzb3VyY2UsIDAsIHNvdXJjZS5zb3VyY2UubGVuZ3RoKTtcbiAgYXN0LmxvYyA9IHtcbiAgICBzb3VyY2U6ICcocHJvZ3JhbSknLFxuICAgIHN0YXJ0OiBvZmZzZXRzLnN0YXJ0UG9zaXRpb24sXG4gICAgZW5kOiBvZmZzZXRzLmVuZFBvc2l0aW9uLFxuICB9O1xuXG4gIGxldCBwcm9ncmFtID0gbmV3IFRva2VuaXplckV2ZW50SGFuZGxlcnMoc291cmNlLCBlbnRpdHlQYXJzZXIsIG1vZGUpLmFjY2VwdFRlbXBsYXRlKGFzdCk7XG5cbiAgaWYgKG9wdGlvbnMuc3RyaWN0TW9kZSkge1xuICAgIHByb2dyYW0uYmxvY2tQYXJhbXMgPSBvcHRpb25zLmxvY2FscyA/PyBbXTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGx1Z2lucyAmJiBvcHRpb25zLnBsdWdpbnMuYXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvcHRpb25zLnBsdWdpbnMuYXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGV0IHRyYW5zZm9ybSA9IG9wdGlvbnMucGx1Z2lucy5hc3RbaV07XG4gICAgICBsZXQgZW52OiBBU1RQbHVnaW5FbnZpcm9ubWVudCA9IGFzc2lnbih7fSwgb3B0aW9ucywgeyBzeW50YXggfSwgeyBwbHVnaW5zOiB1bmRlZmluZWQgfSk7XG5cbiAgICAgIGxldCBwbHVnaW5SZXN1bHQgPSB0cmFuc2Zvcm0oZW52KTtcblxuICAgICAgdHJhdmVyc2UocHJvZ3JhbSwgcGx1Z2luUmVzdWx0LnZpc2l0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9ncmFtO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==