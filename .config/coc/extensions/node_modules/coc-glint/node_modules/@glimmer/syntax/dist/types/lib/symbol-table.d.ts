import { Core, Dict } from '@glimmer/interfaces';
export declare abstract class SymbolTable {
    static top(locals: string[]): ProgramSymbolTable;
    abstract isRoot: boolean;
    abstract has(name: string): boolean;
    abstract get(name: string): number;
    abstract getLocalsMap(): Dict<number>;
    abstract getEvalInfo(): Core.EvalInfo;
    abstract allocateFree(name: string): number;
    abstract allocateTemplateLocal(name: string): number;
    abstract allocateNamed(name: string): number;
    abstract allocateBlock(name: string): number;
    abstract allocate(identifier: string): number;
    abstract setHasEval(): void;
    child(locals: string[]): BlockSymbolTable;
}
export declare class ProgramSymbolTable extends SymbolTable {
    #private;
    private templateLocals;
    constructor(templateLocals: string[]);
    isRoot: boolean;
    symbols: string[];
    upvars: string[];
    private size;
    private named;
    private blocks;
    private usedTemplateLocals;
    setHasEval(): void;
    get hasEval(): boolean;
    has(name: string): boolean;
    get(_name: string): number;
    getLocalsMap(): Dict<number>;
    getEvalInfo(): Core.EvalInfo;
    allocateFree(name: string): number;
    allocateTemplateLocal(name: string): number;
    allocateNamed(name: string): number;
    allocateBlock(name: string): number;
    allocate(identifier: string): number;
}
export declare class BlockSymbolTable extends SymbolTable {
    private parent;
    symbols: string[];
    slots: number[];
    constructor(parent: SymbolTable, symbols: string[], slots: number[]);
    isRoot: boolean;
    get locals(): string[];
    has(name: string): boolean;
    get(name: string): number;
    getLocalsMap(): Dict<number>;
    getEvalInfo(): Core.EvalInfo;
    setHasEval(): void;
    allocateFree(name: string): number;
    allocateTemplateLocal(name: string): number;
    allocateNamed(name: string): number;
    allocateBlock(name: string): number;
    allocate(identifier: string): number;
}
//# sourceMappingURL=symbol-table.d.ts.map