var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return privateMap.get(receiver);
};

var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  privateMap.set(receiver, value);
  return value;
};

var _locPosSpan, _charPosSpan, _providedHbsLoc; // eslint-disable-next-line import/no-extraneous-dependencies


import { DEBUG } from '@glimmer/env';
import { assertNever } from '@glimmer/util';
import { BROKEN_LOCATION, NON_EXISTENT_LOCATION } from '../location';
import { SourceSlice } from '../slice';
import { IsInvisible, match, MatchAny } from './match';
import { BROKEN, CharPosition, HbsPosition, InvisiblePosition } from './offset';
/**
 * A `SourceSpan` object represents a span of characters inside of a template source.
 *
 * There are three kinds of `SourceSpan` objects:
 *
 * - `ConcreteSourceSpan`, which contains byte offsets
 * - `LazySourceSpan`, which contains `SourceLocation`s from the Handlebars AST, which can be
 *   converted to byte offsets on demand.
 * - `InvisibleSourceSpan`, which represent source strings that aren't present in the source,
 *   because:
 *     - they were created synthetically
 *     - their location is nonsensical (the span is broken)
 *     - they represent nothing in the source (this currently happens only when a bug in the
 *       upstream Handlebars parser fails to assign a location to empty blocks)
 *
 * At a high level, all `SourceSpan` objects provide:
 *
 * - byte offsets
 * - source in column and line format
 *
 * And you can do these operations on `SourceSpan`s:
 *
 * - collapse it to a `SourceSpan` representing its starting or ending position
 * - slice out some characters, optionally skipping some characters at the beginning or end
 * - create a new `SourceSpan` with a different starting or ending offset
 *
 * All SourceSpan objects implement `SourceLocation`, for compatibility. All SourceSpan
 * objects have a `toJSON` that emits `SourceLocation`, also for compatibility.
 *
 * For compatibility, subclasses of `AbstractSourceSpan` must implement `locDidUpdate`, which
 * happens when an AST plugin attempts to modify the `start` or `end` of a span directly.
 *
 * The goal is to avoid creating any problems for use-cases like AST Explorer.
 */

export class SourceSpan {
  constructor(data) {
    this.data = data;
    this.isInvisible = data.kind !== "CharPosition"
    /* CharPosition */
    && data.kind !== "HbsPosition"
    /* HbsPosition */
    ;
  }

  static get NON_EXISTENT() {
    return new InvisibleSpan("NonExistent"
    /* NonExistent */
    , NON_EXISTENT_LOCATION).wrap();
  }

  static load(source, serialized) {
    if (typeof serialized === 'number') {
      return SourceSpan.forCharPositions(source, serialized, serialized);
    } else if (typeof serialized === 'string') {
      return SourceSpan.synthetic(serialized);
    } else if (Array.isArray(serialized)) {
      return SourceSpan.forCharPositions(source, serialized[0], serialized[1]);
    } else if (serialized === "NonExistent"
    /* NonExistent */
    ) {
        return SourceSpan.NON_EXISTENT;
      } else if (serialized === "Broken"
    /* Broken */
    ) {
        return SourceSpan.broken(BROKEN_LOCATION);
      }

    assertNever(serialized);
  }

  static forHbsLoc(source, loc) {
    let start = new HbsPosition(source, loc.start);
    let end = new HbsPosition(source, loc.end);
    return new HbsSpan(source, {
      start,
      end
    }, loc).wrap();
  }

  static forCharPositions(source, startPos, endPos) {
    let start = new CharPosition(source, startPos);
    let end = new CharPosition(source, endPos);
    return new CharPositionSpan(source, {
      start,
      end
    }).wrap();
  }

  static synthetic(chars) {
    return new InvisibleSpan("InternalsSynthetic"
    /* InternalsSynthetic */
    , NON_EXISTENT_LOCATION, chars).wrap();
  }

  static broken(pos = BROKEN_LOCATION) {
    return new InvisibleSpan("Broken"
    /* Broken */
    , pos).wrap();
  }

  getStart() {
    return this.data.getStart().wrap();
  }

  getEnd() {
    return this.data.getEnd().wrap();
  }

  get loc() {
    let span = this.data.toHbsSpan();
    return span === null ? BROKEN_LOCATION : span.toHbsLoc();
  }

  get module() {
    return this.data.getModule();
  }
  /**
   * Get the starting `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
   */


  get startPosition() {
    return this.loc.start;
  }
  /**
   * Get the ending `SourcePosition` for this `SourceSpan`, lazily computing it if needed.
   */


  get endPosition() {
    return this.loc.end;
  }
  /**
   * Support converting ASTv1 nodes into a serialized format using JSON.stringify.
   */


  toJSON() {
    return this.loc;
  }
  /**
   * Create a new span with the current span's end and a new beginning.
   */


  withStart(other) {
    return span(other.data, this.data.getEnd());
  }
  /**
   * Create a new span with the current span's beginning and a new ending.
   */


  withEnd(other) {
    return span(this.data.getStart(), other.data);
  }

  asString() {
    return this.data.asString();
  }
  /**
   * Convert this `SourceSpan` into a `SourceSlice`. In debug mode, this method optionally checks
   * that the byte offsets represented by this `SourceSpan` actually correspond to the expected
   * string.
   */


  toSlice(expected) {
    let chars = this.data.asString();

    if (DEBUG) {
      if (expected !== undefined && chars !== expected) {
        // eslint-disable-next-line no-console
        console.warn(`unexpectedly found ${JSON.stringify(chars)} when slicing source, but expected ${JSON.stringify(expected)}`);
      }
    }

    return new SourceSlice({
      loc: this,
      chars: expected || chars
    });
  }
  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use startPosition instead
   */


  get start() {
    return this.loc.start;
  }
  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use withStart instead
   */


  set start(position) {
    this.data.locDidUpdate({
      start: position
    });
  }
  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use endPosition instead
   */


  get end() {
    return this.loc.end;
  }
  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use withEnd instead
   */


  set end(position) {
    this.data.locDidUpdate({
      end: position
    });
  }
  /**
   * For compatibility with SourceLocation in AST plugins
   *
   * @deprecated use module instead
   */


  get source() {
    return this.module;
  }

  collapse(where) {
    switch (where) {
      case 'start':
        return this.getStart().collapsed();

      case 'end':
        return this.getEnd().collapsed();
    }
  }

  extend(other) {
    return span(this.data.getStart(), other.data.getEnd());
  }

  serialize() {
    return this.data.serialize();
  }

  slice({
    skipStart = 0,
    skipEnd = 0
  }) {
    return span(this.getStart().move(skipStart).data, this.getEnd().move(-skipEnd).data);
  }

  sliceStartChars({
    skipStart = 0,
    chars
  }) {
    return span(this.getStart().move(skipStart).data, this.getStart().move(skipStart + chars).data);
  }

  sliceEndChars({
    skipEnd = 0,
    chars
  }) {
    return span(this.getEnd().move(skipEnd - chars).data, this.getStart().move(-skipEnd).data);
  }

}

class CharPositionSpan {
  constructor(source, charPositions) {
    this.source = source;
    this.charPositions = charPositions;
    this.kind = "CharPosition"
    /* CharPosition */
    ;

    _locPosSpan.set(this, null);
  }

  wrap() {
    return new SourceSpan(this);
  }

  asString() {
    return this.source.slice(this.charPositions.start.charPos, this.charPositions.end.charPos);
  }

  getModule() {
    return this.source.module;
  }

  getStart() {
    return this.charPositions.start;
  }

  getEnd() {
    return this.charPositions.end;
  }

  locDidUpdate() {
    if (false
    /* LOCAL_DEBUG */
    ) {
      // eslint-disable-next-line no-console
      console.warn(`updating a location that came from a CharPosition span doesn't work reliably. Don't try to update locations after the plugin phase`);
    }
  }

  toHbsSpan() {
    let locPosSpan = __classPrivateFieldGet(this, _locPosSpan);

    if (locPosSpan === null) {
      let start = this.charPositions.start.toHbsPos();
      let end = this.charPositions.end.toHbsPos();

      if (start === null || end === null) {
        locPosSpan = __classPrivateFieldSet(this, _locPosSpan, BROKEN);
      } else {
        locPosSpan = __classPrivateFieldSet(this, _locPosSpan, new HbsSpan(this.source, {
          start,
          end
        }));
      }
    }

    return locPosSpan === BROKEN ? null : locPosSpan;
  }

  serialize() {
    let {
      start: {
        charPos: start
      },
      end: {
        charPos: end
      }
    } = this.charPositions;

    if (start === end) {
      return start;
    } else {
      return [start, end];
    }
  }

  toCharPosSpan() {
    return this;
  }

}

_locPosSpan = new WeakMap();
export class HbsSpan {
  constructor(source, hbsPositions, providedHbsLoc = null) {
    this.source = source;
    this.hbsPositions = hbsPositions;
    this.kind = "HbsPosition"
    /* HbsPosition */
    ;

    _charPosSpan.set(this, null); // the source location from Handlebars + AST Plugins -- could be wrong


    _providedHbsLoc.set(this, void 0);

    __classPrivateFieldSet(this, _providedHbsLoc, providedHbsLoc);
  }

  serialize() {
    let charPos = this.toCharPosSpan();
    return charPos === null ? "Broken"
    /* Broken */
    : charPos.wrap().serialize();
  }

  wrap() {
    return new SourceSpan(this);
  }

  updateProvided(pos, edge) {
    if (__classPrivateFieldGet(this, _providedHbsLoc)) {
      __classPrivateFieldGet(this, _providedHbsLoc)[edge] = pos;
    } // invalidate computed character offsets


    __classPrivateFieldSet(this, _charPosSpan, null);

    __classPrivateFieldSet(this, _providedHbsLoc, {
      start: pos,
      end: pos
    });
  }

  locDidUpdate({
    start,
    end
  }) {
    if (start !== undefined) {
      this.updateProvided(start, 'start');
      this.hbsPositions.start = new HbsPosition(this.source, start, null);
    }

    if (end !== undefined) {
      this.updateProvided(end, 'end');
      this.hbsPositions.end = new HbsPosition(this.source, end, null);
    }
  }

  asString() {
    let span = this.toCharPosSpan();
    return span === null ? '' : span.asString();
  }

  getModule() {
    return this.source.module;
  }

  getStart() {
    return this.hbsPositions.start;
  }

  getEnd() {
    return this.hbsPositions.end;
  }

  toHbsLoc() {
    return {
      start: this.hbsPositions.start.hbsPos,
      end: this.hbsPositions.end.hbsPos
    };
  }

  toHbsSpan() {
    return this;
  }

  toCharPosSpan() {
    let charPosSpan = __classPrivateFieldGet(this, _charPosSpan);

    if (charPosSpan === null) {
      let start = this.hbsPositions.start.toCharPos();
      let end = this.hbsPositions.end.toCharPos();

      if (start && end) {
        charPosSpan = __classPrivateFieldSet(this, _charPosSpan, new CharPositionSpan(this.source, {
          start,
          end
        }));
      } else {
        charPosSpan = __classPrivateFieldSet(this, _charPosSpan, BROKEN);
        return null;
      }
    }

    return charPosSpan === BROKEN ? null : charPosSpan;
  }

}
_charPosSpan = new WeakMap(), _providedHbsLoc = new WeakMap();

class InvisibleSpan {
  constructor(kind, // whatever was provided, possibly broken
  loc, // if the span represents a synthetic string
  string = null) {
    this.kind = kind;
    this.loc = loc;
    this.string = string;
  }

  serialize() {
    switch (this.kind) {
      case "Broken"
      /* Broken */
      :
      case "NonExistent"
      /* NonExistent */
      :
        return this.kind;

      case "InternalsSynthetic"
      /* InternalsSynthetic */
      :
        return this.string || '';
    }
  }

  wrap() {
    return new SourceSpan(this);
  }

  asString() {
    return this.string || '';
  }

  locDidUpdate({
    start,
    end
  }) {
    if (start !== undefined) {
      this.loc.start = start;
    }

    if (end !== undefined) {
      this.loc.end = end;
    }
  }

  getModule() {
    // TODO: Make this reflect the actual module this span originated from
    return 'an unknown module';
  }

  getStart() {
    return new InvisiblePosition(this.kind, this.loc.start);
  }

  getEnd() {
    return new InvisiblePosition(this.kind, this.loc.end);
  }

  toCharPosSpan() {
    return this;
  }

  toHbsSpan() {
    return null;
  }

  toHbsLoc() {
    return BROKEN_LOCATION;
  }

}

export const span = match(m => m.when("HbsPosition"
/* HbsPosition */
, "HbsPosition"
/* HbsPosition */
, (left, right) => new HbsSpan(left.source, {
  start: left,
  end: right
}).wrap()).when("CharPosition"
/* CharPosition */
, "CharPosition"
/* CharPosition */
, (left, right) => new CharPositionSpan(left.source, {
  start: left,
  end: right
}).wrap()).when("CharPosition"
/* CharPosition */
, "HbsPosition"
/* HbsPosition */
, (left, right) => {
  let rightCharPos = right.toCharPos();

  if (rightCharPos === null) {
    return new InvisibleSpan("Broken"
    /* Broken */
    , BROKEN_LOCATION).wrap();
  } else {
    return span(left, rightCharPos);
  }
}).when("HbsPosition"
/* HbsPosition */
, "CharPosition"
/* CharPosition */
, (left, right) => {
  let leftCharPos = left.toCharPos();

  if (leftCharPos === null) {
    return new InvisibleSpan("Broken"
    /* Broken */
    , BROKEN_LOCATION).wrap();
  } else {
    return span(leftCharPos, right);
  }
}).when(IsInvisible, MatchAny, left => new InvisibleSpan(left.kind, BROKEN_LOCATION).wrap()).when(MatchAny, IsInvisible, (_, right) => new InvisibleSpan(right.kind, BROKEN_LOCATION).wrap()));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvc291cmNlL2xvYy9zcGFuLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQUFBOzs7QUFDQSxTQUFTLEtBQVQsUUFBc0IsY0FBdEI7QUFFQSxTQUFTLFdBQVQsUUFBNEIsZUFBNUI7QUFFQSxTQUNFLGVBREYsRUFFRSxxQkFGRixRQUtPLGFBTFA7QUFNQSxTQUFTLFdBQVQsUUFBNEIsVUFBNUI7QUFFQSxTQUFTLFdBQVQsRUFBc0IsS0FBdEIsRUFBNkIsUUFBN0IsUUFBc0QsU0FBdEQ7QUFDQSxTQUVFLE1BRkYsRUFHRSxZQUhGLEVBSUUsV0FKRixFQUtFLGlCQUxGLFFBUU8sVUFSUDtBQXlEQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQ0EsT0FBTSxNQUFPLFVBQVAsQ0FBaUI7QUE0Q3JCLEVBQUEsV0FBQSxDQUFvQixJQUFwQixFQUE0QztBQUF4QixTQUFBLElBQUEsR0FBQSxJQUFBO0FBQ2xCLFNBQUssV0FBTCxHQUNFLElBQUksQ0FBQyxJQUFMLEtBQVM7QUFBQTtBQUFULE9BQXlDLElBQUksQ0FBQyxJQUFMLEtBQVM7QUFBQTtBQURwRDtBQUVEOztBQTlDRCxhQUFXLFlBQVgsR0FBdUI7QUFDckIsV0FBTyxJQUFJLGFBQUosQ0FBaUI7QUFBQTtBQUFqQixNQUEwQyxxQkFBMUMsRUFBaUUsSUFBakUsRUFBUDtBQUNEOztBQUVELFNBQU8sSUFBUCxDQUFZLE1BQVosRUFBNEIsVUFBNUIsRUFBNEQ7QUFDMUQsUUFBSSxPQUFPLFVBQVAsS0FBc0IsUUFBMUIsRUFBb0M7QUFDbEMsYUFBTyxVQUFVLENBQUMsZ0JBQVgsQ0FBNEIsTUFBNUIsRUFBb0MsVUFBcEMsRUFBZ0QsVUFBaEQsQ0FBUDtBQUNELEtBRkQsTUFFTyxJQUFJLE9BQU8sVUFBUCxLQUFzQixRQUExQixFQUFvQztBQUN6QyxhQUFPLFVBQVUsQ0FB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Q0FBQyxDQUFELEVBQUksS0FBSixLQUMzQixJQUFJLGFBQUosQ0FBa0IsS0FBSyxDQUFDLElBQXhCLEVBQThCLGVBQTlCLEVBQStDLElBQS9DLEVBakNKLENBRDRDLENBQXZDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby1leHRyYW5lb3VzLWRlcGVuZGVuY2llc1xuaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuaW1wb3J0IHsgTE9DQUxfREVCVUcgfSBmcm9tICdAZ2xpbW1lci9sb2NhbC1kZWJ1Zy1mbGFncyc7XG5pbXBvcnQgeyBhc3NlcnROZXZlciB9IGZyb20gJ0BnbGltbWVyL3V0aWwnO1xuXG5pbXBvcnQge1xuICBCUk9LRU5fTE9DQVRJT04sXG4gIE5PTl9FWElTVEVOVF9MT0NBVElPTixcbiAgU291cmNlTG9jYXRpb24sXG4gIFNvdXJjZVBvc2l0aW9uLFxufSBmcm9tICcuLi9sb2NhdGlvbic7XG5pbXBvcnQgeyBTb3VyY2VTbGljZSB9IGZyb20gJy4uL3NsaWNlJztcbmltcG9ydCB7IFNvdXJjZSB9IGZyb20gJy4uL3NvdXJjZSc7XG5pbXBvcnQgeyBJc0ludmlzaWJsZSwgbWF0Y2gsIE1hdGNoQW55LCBNYXRjaEZuIH0gZnJvbSAnLi9tYXRjaCc7XG5pbXBvcnQge1xuICBBbnlQb3NpdGlvbixcbiAgQlJPS0VOLFxuICBDaGFyUG9zaXRpb24sXG4gIEhic1Bvc2l0aW9uLFxuICBJbnZpc2libGVQb3NpdGlvbixcbiAgT2Zmc2V0S2luZCxcbiAgU291cmNlT2Zmc2V0LFxufSBmcm9tICcuL29mZnNldCc7XG5cbi8qKlxuICogQWxsIHNwYW5zIGhhdmUgdGhlc2UgZGV0YWlscyBpbiBjb21tb24uXG4gKi9cbmludGVyZmFjZSBTcGFuRGF0YSB7XG4gIHJlYWRvbmx5IGtpbmQ6IE9mZnNldEtpbmQ7XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhpcyBzcGFuIGludG8gYSBzdHJpbmcuIElmIHRoZSBzcGFuIGlzIGJyb2tlbiwgcmV0dXJuIGAnJ2AuXG4gICAqL1xuICBhc1N0cmluZygpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG1vZHVsZSB0aGUgc3BhbiB3YXMgbG9jYXRlZCBpbi5cbiAgICovXG4gIGdldE1vZHVsZSgpOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhcnRpbmcgcG9zaXRpb24gZm9yIHRoaXMgc3Bhbi4gVHJ5IHRvIGF2b2lkIGNyZWF0aW5nIG5ldyBwb3NpdGlvbiBvYmplY3RzLCBhcyB0aGV5XG4gICAqIGNhY2hlIGNvbXB1dGF0aW9ucy5cbiAgICovXG4gIGdldFN0YXJ0KCk6IEFueVBvc2l0aW9uO1xuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVuZGluZyBwb3NpdGlvbiBmb3IgdGhpcyBzcGFuLiBUcnkgdG8gYXZvaWQgY3JlYXRpbmcgbmV3IHBvc2l0aW9uIG9iamVjdHMsIGFzIHRoZXlcbiAgICogY2FjaGUgY29tcHV0YXRpb25zLlxuICAgKi9cbiAgZ2V0RW5kKCk6IEFueVBvc2l0aW9uO1xuXG4gIC8qKlxuICAgKiBDb21wdXRlIHRoZSBgU291cmNlTG9jYXRpb25gIGZvciB0aGlzIHNwYW4sIHJldHVybmVkIGFzIGFuIGluc3RhbmNlIG9mIGBIYnNTcGFuYC5cbiAgICovXG4gIHRvSGJzU3BhbigpOiBIYnNTcGFuIHwgbnVsbDtcblxuICAvKipcbiAgICogRm9yIGNvbXBhdGliaWxpdHksIHdoZW5ldmVyIHRoZSBgc3RhcnRgIG9yIGBlbmRgIG9mIGEge0BzZWUgU291cmNlT2Zmc2V0fSBjaGFuZ2VzLCBzcGFucyBhcmVcbiAgICogbm90aWZpZWQgb2YgdGhlIGNoYW5nZSBzbyB0aGV5IGNhbiB1cGRhdGUgdGhlbXNlbHZlcy4gVGhpcyBzaG91bGRuJ3QgaGFwcGVuIG91dHNpZGUgb2YgQVNUXG4gICAqIHBsdWdpbnMuXG4gICAqL1xuICBsb2NEaWRVcGRhdGUoY2hhbmdlczogeyBzdGFydD86IFNvdXJjZVBvc2l0aW9uOyBlbmQ/OiBTb3VyY2VQb3NpdGlvbiB9KTogdm9pZDtcblxuICAvKipcbiAgICogU2VyaWFsaXplIGludG8gYSB7QHNlZSBTZXJpYWxpemVkU291cmNlU3Bhbn0sIHdoaWNoIGlzIGNvbXBhY3QgYW5kIGRlc2lnbmVkIGZvciByZWFkYWJpbGl0eSBpblxuICAgKiBjb250ZXh0IGxpa2UgQVNUIEV4cGxvcmVyLiBJZiB5b3UgbmVlZCBhIHtAc2VlIFNvdXJjZUxvY2F0aW9ufSwgdXNlIHtAc2VlIHRvSlNPTn0uXG4gICAqL1xuICBzZXJpYWxpemUoKTogU2VyaWFsaXplZFNvdXJjZVNwYW47XG59XG5cbi8qKlxuICogQSBgU291cmNlU3BhbmAgb2JqZWN0IHJlcHJlc2VudHMgYSBzcGFuIG9mIGNoYXJhY3RlcnMgaW5zaWRlIG9mIGEgdGVtcGxhdGUgc291cmNlLlxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBraW5kcyBvZiBgU291cmNlU3BhbmAgb2JqZWN0czpcbiAqXG4gKiAtIGBDb25jcmV0ZVNvdXJjZVNwYW5gLCB3aGljaCBjb250YWlucyBieXRlIG9mZnNldHNcbiAqIC0gYExhenlTb3VyY2VTcGFuYCwgd2hpY2ggY29udGFpbnMgYFNvdXJjZUxvY2F0aW9uYHMgZnJvbSB0aGUgSGFuZGxlYmFycyBBU1QsIHdoaWNoIGNhbiBiZVxuICogICBjb252ZXJ0ZWQgdG8gYnl0ZSBvZmZzZXRzIG9uIGRlbWFuZC5cbiAqIC0gYEludmlzaWJsZVNvdXJjZVNwYW5gLCB3aGljaCByZXByZXNlbnQgc291cmNlIHN0cmluZ3MgdGhhdCBhcmVuJ3QgcHJlc2VudCBpbiB0aGUgc291cmNlLFxuICogICBiZWNhdXNlOlxuICogICAgIC0gdGhleSB3ZXJlIGNyZWF0ZWQgc3ludGhldGljYWxseVxuICogICAgIC0gdGhlaXIgbG9jYXRpb24gaXMgbm9uc2Vuc2ljYWwgKHRoZSBzcGFuIGlzIGJyb2tlbilcbiAqICAgICAtIHRoZXkgcmVwcmVzZW50IG5vdGhpbmcgaW4gdGhlIHNvdXJjZSAodGhpcyBjdXJyZW50bHkgaGFwcGVucyBvbmx5IHdoZW4gYSBidWcgaW4gdGhlXG4gKiAgICAgICB1cHN0cmVhbSBIYW5kbGViYXJzIHBhcnNlciBmYWlscyB0byBhc3NpZ24gYSBsb2NhdGlvbiB0byBlbXB0eSBibG9ja3MpXG4gKlxuICogQXQgYSBoaWdoIGxldmVsLCBhbGwgYFNvdXJjZVNwYW5gIG9iamVjdHMgcHJvdmlkZTpcbiAqXG4gKiAtIGJ5dGUgb2Zmc2V0c1xuICogLSBzb3VyY2UgaW4gY29sdW1uIGFuZCBsaW5lIGZvcm1hdFxuICpcbiAqIEFuZCB5b3UgY2FuIGRvIHRoZXNlIG9wZXJhdGlvbnMgb24gYFNvdXJjZVNwYW5gczpcbiAqXG4gKiAtIGNvbGxhcHNlIGl0IHRvIGEgYFNvdXJjZVNwYW5gIHJlcHJlc2VudGluZyBpdHMgc3RhcnRpbmcgb3IgZW5kaW5nIHBvc2l0aW9uXG4gKiAtIHNsaWNlIG91dCBzb21lIGNoYXJhY3RlcnMsIG9wdGlvbmFsbHkgc2tpcHBpbmcgc29tZSBjaGFyYWN0ZXJzIGF0IHRoZSBiZWdpbm5pbmcgb3IgZW5kXG4gKiAtIGNyZWF0ZSBhIG5ldyBgU291cmNlU3BhbmAgd2l0aCBhIGRpZmZlcmVudCBzdGFydGluZyBvciBlbmRpbmcgb2Zmc2V0XG4gKlxuICogQWxsIFNvdXJjZVNwYW4gb2JqZWN0cyBpbXBsZW1lbnQgYFNvdXJjZUxvY2F0aW9uYCwgZm9yIGNvbXBhdGliaWxpdHkuIEFsbCBTb3VyY2VTcGFuXG4gKiBvYmplY3RzIGhhdmUgYSBgdG9KU09OYCB0aGF0IGVtaXRzIGBTb3VyY2VMb2NhdGlvbmAsIGFsc28gZm9yIGNvbXBhdGliaWxpdHkuXG4gKlxuICogRm9yIGNvbXBhdGliaWxpdHksIHN1YmNsYXNzZXMgb2YgYEFic3RyYWN0U291cmNlU3BhbmAgbXVzdCBpbXBsZW1lbnQgYGxvY0RpZFVwZGF0ZWAsIHdoaWNoXG4gKiBoYXBwZW5zIHdoZW4gYW4gQVNUIHBsdWdpbiBhdHRlbXB0cyB0byBtb2RpZnkgdGhlIGBzdGFydGAgb3IgYGVuZGAgb2YgYSBzcGFuIGRpcmVjdGx5LlxuICpcbiAqIFRoZSBnb2FsIGlzIHRvIGF2b2lkIGNyZWF0aW5nIGFueSBwcm9ibGVtcyBmb3IgdXNlLWNhc2VzIGxpa2UgQVNUIEV4cGxvcmVyLlxuICovXG5leHBvcnQgY2xhc3MgU291cmNlU3BhbiBpbXBsZW1lbnRzIFNvdXJjZUxvY2F0aW9uIHtcbiAgc3RhdGljIGdldCBOT05fRVhJU1RFTlQoKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIG5ldyBJbnZpc2libGVTcGFuKE9mZnNldEtpbmQuTm9uRXhpc3RlbnQsIE5PTl9FWElTVEVOVF9MT0NBVElPTikud3JhcCgpO1xuICB9XG5cbiAgc3RhdGljIGxvYWQoc291cmNlOiBTb3VyY2UsIHNlcmlhbGl6ZWQ6IFNlcmlhbGl6ZWRTb3VyY2VTcGFuKTogU291cmNlU3BhbiB7XG4gICAgaWYgKHR5cGVvZiBzZXJpYWxpemVkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIFNvdXJjZVNwYW4uZm9yQ2hhclBvc2l0aW9ucyhzb3VyY2UsIHNlcmlhbGl6ZWQsIHNlcmlhbGl6ZWQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNlcmlhbGl6ZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gU291cmNlU3Bhbi5zeW50aGV0aWMoc2VyaWFsaXplZCk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWQpKSB7XG4gICAgICByZXR1cm4gU291cmNlU3Bhbi5mb3JDaGFyUG9zaXRpb25zKHNvdXJjZSwgc2VyaWFsaXplZFswXSwgc2VyaWFsaXplZFsxXSk7XG4gICAgfSBlbHNlIGlmIChzZXJpYWxpemVkID09PSBPZmZzZXRLaW5kLk5vbkV4aXN0ZW50KSB7XG4gICAgICByZXR1cm4gU291cmNlU3Bhbi5OT05fRVhJU1RFTlQ7XG4gICAgfSBlbHNlIGlmIChzZXJpYWxpemVkID09PSBPZmZzZXRLaW5kLkJyb2tlbikge1xuICAgICAgcmV0dXJuIFNvdXJjZVNwYW4uYnJva2VuKEJST0tFTl9MT0NBVElPTik7XG4gICAgfVxuXG4gICAgYXNzZXJ0TmV2ZXIoc2VyaWFsaXplZCk7XG4gIH1cblxuICBzdGF0aWMgZm9ySGJzTG9jKHNvdXJjZTogU291cmNlLCBsb2M6IFNvdXJjZUxvY2F0aW9uKTogU291cmNlU3BhbiB7XG4gICAgbGV0IHN0YXJ0ID0gbmV3IEhic1Bvc2l0aW9uKHNvdXJjZSwgbG9jLnN0YXJ0KTtcbiAgICBsZXQgZW5kID0gbmV3IEhic1Bvc2l0aW9uKHNvdXJjZSwgbG9jLmVuZCk7XG4gICAgcmV0dXJuIG5ldyBIYnNTcGFuKHNvdXJjZSwgeyBzdGFydCwgZW5kIH0sIGxvYykud3JhcCgpO1xuICB9XG5cbiAgc3RhdGljIGZvckNoYXJQb3NpdGlvbnMoc291cmNlOiBTb3VyY2UsIHN0YXJ0UG9zOiBudW1iZXIsIGVuZFBvczogbnVtYmVyKTogU291cmNlU3BhbiB7XG4gICAgbGV0IHN0YXJ0ID0gbmV3IENoYXJQb3NpdGlvbihzb3VyY2UsIHN0YXJ0UG9zKTtcbiAgICBsZXQgZW5kID0gbmV3IENoYXJQb3NpdGlvbihzb3VyY2UsIGVuZFBvcyk7XG5cbiAgICByZXR1cm4gbmV3IENoYXJQb3NpdGlvblNwYW4oc291cmNlLCB7IHN0YXJ0LCBlbmQgfSkud3JhcCgpO1xuICB9XG5cbiAgc3RhdGljIHN5bnRoZXRpYyhjaGFyczogc3RyaW5nKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIG5ldyBJbnZpc2libGVTcGFuKE9mZnNldEtpbmQuSW50ZXJuYWxzU3ludGhldGljLCBOT05fRVhJU1RFTlRfTE9DQVRJT04sIGNoYXJzKS53cmFwKCk7XG4gIH1cblxuICBzdGF0aWMgYnJva2VuKHBvczogU291cmNlTG9jYXRpb24gPSBCUk9LRU5fTE9DQVRJT04pOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gbmV3IEludmlzaWJsZVNwYW4oT2Zmc2V0S2luZC5Ccm9rZW4sIHBvcykud3JhcCgpO1xuICB9XG5cbiAgcmVhZG9ubHkgaXNJbnZpc2libGU6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkYXRhOiBTcGFuRGF0YSAmIEFueVNwYW4pIHtcbiAgICB0aGlzLmlzSW52aXNpYmxlID1cbiAgICAgIGRhdGEua2luZCAhPT0gT2Zmc2V0S2luZC5DaGFyUG9zaXRpb24gJiYgZGF0YS5raW5kICE9PSBPZmZzZXRLaW5kLkhic1Bvc2l0aW9uO1xuICB9XG5cbiAgZ2V0U3RhcnQoKTogU291cmNlT2Zmc2V0IHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmdldFN0YXJ0KCkud3JhcCgpO1xuICB9XG5cbiAgZ2V0RW5kKCk6IFNvdXJjZU9mZnNldCB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5nZXRFbmQoKS53cmFwKCk7XG4gIH1cblxuICBnZXQgbG9jKCk6IFNvdXJjZUxvY2F0aW9uIHtcbiAgICBsZXQgc3BhbiA9IHRoaXMuZGF0YS50b0hic1NwYW4oKTtcbiAgICByZXR1cm4gc3BhbiA9PT0gbnVsbCA/IEJST0tFTl9MT0NBVElPTiA6IHNwYW4udG9IYnNMb2MoKTtcbiAgfVxuXG4gIGdldCBtb2R1bGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmdldE1vZHVsZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhcnRpbmcgYFNvdXJjZVBvc2l0aW9uYCBmb3IgdGhpcyBgU291cmNlU3BhbmAsIGxhemlseSBjb21wdXRpbmcgaXQgaWYgbmVlZGVkLlxuICAgKi9cbiAgZ2V0IHN0YXJ0UG9zaXRpb24oKTogU291cmNlUG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmxvYy5zdGFydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGVuZGluZyBgU291cmNlUG9zaXRpb25gIGZvciB0aGlzIGBTb3VyY2VTcGFuYCwgbGF6aWx5IGNvbXB1dGluZyBpdCBpZiBuZWVkZWQuXG4gICAqL1xuICBnZXQgZW5kUG9zaXRpb24oKTogU291cmNlUG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmxvYy5lbmQ7XG4gIH1cblxuICAvKipcbiAgICogU3VwcG9ydCBjb252ZXJ0aW5nIEFTVHYxIG5vZGVzIGludG8gYSBzZXJpYWxpemVkIGZvcm1hdCB1c2luZyBKU09OLnN0cmluZ2lmeS5cbiAgICovXG4gIHRvSlNPTigpOiBTb3VyY2VMb2NhdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMubG9jO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzcGFuIHdpdGggdGhlIGN1cnJlbnQgc3BhbidzIGVuZCBhbmQgYSBuZXcgYmVnaW5uaW5nLlxuICAgKi9cbiAgd2l0aFN0YXJ0KG90aGVyOiBTb3VyY2VPZmZzZXQpOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gc3BhbihvdGhlci5kYXRhLCB0aGlzLmRhdGEuZ2V0RW5kKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBzcGFuIHdpdGggdGhlIGN1cnJlbnQgc3BhbidzIGJlZ2lubmluZyBhbmQgYSBuZXcgZW5kaW5nLlxuICAgKi9cbiAgd2l0aEVuZCh0aGlzOiBTb3VyY2VTcGFuLCBvdGhlcjogU291cmNlT2Zmc2V0KTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIHNwYW4odGhpcy5kYXRhLmdldFN0YXJ0KCksIG90aGVyLmRhdGEpO1xuICB9XG5cbiAgYXNTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmFzU3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCB0aGlzIGBTb3VyY2VTcGFuYCBpbnRvIGEgYFNvdXJjZVNsaWNlYC4gSW4gZGVidWcgbW9kZSwgdGhpcyBtZXRob2Qgb3B0aW9uYWxseSBjaGVja3NcbiAgICogdGhhdCB0aGUgYnl0ZSBvZmZzZXRzIHJlcHJlc2VudGVkIGJ5IHRoaXMgYFNvdXJjZVNwYW5gIGFjdHVhbGx5IGNvcnJlc3BvbmQgdG8gdGhlIGV4cGVjdGVkXG4gICAqIHN0cmluZy5cbiAgICovXG4gIHRvU2xpY2UoZXhwZWN0ZWQ/OiBzdHJpbmcpOiBTb3VyY2VTbGljZSB7XG4gICAgbGV0IGNoYXJzID0gdGhpcy5kYXRhLmFzU3RyaW5nKCk7XG5cbiAgICBpZiAoREVCVUcpIHtcbiAgICAgIGlmIChleHBlY3RlZCAhPT0gdW5kZWZpbmVkICYmIGNoYXJzICE9PSBleHBlY3RlZCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYHVuZXhwZWN0ZWRseSBmb3VuZCAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgY2hhcnNcbiAgICAgICAgICApfSB3aGVuIHNsaWNpbmcgc291cmNlLCBidXQgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShleHBlY3RlZCl9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU291cmNlU2xpY2Uoe1xuICAgICAgbG9jOiB0aGlzLFxuICAgICAgY2hhcnM6IGV4cGVjdGVkIHx8IGNoYXJzLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBjb21wYXRpYmlsaXR5IHdpdGggU291cmNlTG9jYXRpb24gaW4gQVNUIHBsdWdpbnNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHN0YXJ0UG9zaXRpb24gaW5zdGVhZFxuICAgKi9cbiAgZ2V0IHN0YXJ0KCk6IFNvdXJjZVBvc2l0aW9uIHtcbiAgICByZXR1cm4gdGhpcy5sb2Muc3RhcnQ7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTb3VyY2VMb2NhdGlvbiBpbiBBU1QgcGx1Z2luc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2Ugd2l0aFN0YXJ0IGluc3RlYWRcbiAgICovXG4gIHNldCBzdGFydChwb3NpdGlvbjogU291cmNlUG9zaXRpb24pIHtcbiAgICB0aGlzLmRhdGEubG9jRGlkVXBkYXRlKHsgc3RhcnQ6IHBvc2l0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBjb21wYXRpYmlsaXR5IHdpdGggU291cmNlTG9jYXRpb24gaW4gQVNUIHBsdWdpbnNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGVuZFBvc2l0aW9uIGluc3RlYWRcbiAgICovXG4gIGdldCBlbmQoKTogU291cmNlUG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmxvYy5lbmQ7XG4gIH1cblxuICAvKipcbiAgICogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBTb3VyY2VMb2NhdGlvbiBpbiBBU1QgcGx1Z2luc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2Ugd2l0aEVuZCBpbnN0ZWFkXG4gICAqL1xuICBzZXQgZW5kKHBvc2l0aW9uOiBTb3VyY2VQb3NpdGlvbikge1xuICAgIHRoaXMuZGF0YS5sb2NEaWRVcGRhdGUoeyBlbmQ6IHBvc2l0aW9uIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBjb21wYXRpYmlsaXR5IHdpdGggU291cmNlTG9jYXRpb24gaW4gQVNUIHBsdWdpbnNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgdXNlIG1vZHVsZSBpbnN0ZWFkXG4gICAqL1xuICBnZXQgc291cmNlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlO1xuICB9XG5cbiAgY29sbGFwc2Uod2hlcmU6ICdzdGFydCcgfCAnZW5kJyk6IFNvdXJjZVNwYW4ge1xuICAgIHN3aXRjaCAod2hlcmUpIHtcbiAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnQoKS5jb2xsYXBzZWQoKTtcbiAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVuZCgpLmNvbGxhcHNlZCgpO1xuICAgIH1cbiAgfVxuXG4gIGV4dGVuZChvdGhlcjogU291cmNlU3Bhbik6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiBzcGFuKHRoaXMuZGF0YS5nZXRTdGFydCgpLCBvdGhlci5kYXRhLmdldEVuZCgpKTtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemVkU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YS5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIHNsaWNlKHsgc2tpcFN0YXJ0ID0gMCwgc2tpcEVuZCA9IDAgfTogeyBza2lwU3RhcnQ/OiBudW1iZXI7IHNraXBFbmQ/OiBudW1iZXIgfSk6IFNvdXJjZVNwYW4ge1xuICAgIHJldHVybiBzcGFuKHRoaXMuZ2V0U3RhcnQoKS5tb3ZlKHNraXBTdGFydCkuZGF0YSwgdGhpcy5nZXRFbmQoKS5tb3ZlKC1za2lwRW5kKS5kYXRhKTtcbiAgfVxuXG4gIHNsaWNlU3RhcnRDaGFycyh7IHNraXBTdGFydCA9IDAsIGNoYXJzIH06IHsgc2tpcFN0YXJ0PzogbnVtYmVyOyBjaGFyczogbnVtYmVyIH0pOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gc3Bhbih0aGlzLmdldFN0YXJ0KCkubW92ZShza2lwU3RhcnQpLmRhdGEsIHRoaXMuZ2V0U3RhcnQoKS5tb3ZlKHNraXBTdGFydCArIGNoYXJzKS5kYXRhKTtcbiAgfVxuXG4gIHNsaWNlRW5kQ2hhcnMoeyBza2lwRW5kID0gMCwgY2hhcnMgfTogeyBza2lwRW5kPzogbnVtYmVyOyBjaGFyczogbnVtYmVyIH0pOiBTb3VyY2VTcGFuIHtcbiAgICByZXR1cm4gc3Bhbih0aGlzLmdldEVuZCgpLm1vdmUoc2tpcEVuZCAtIGNoYXJzKS5kYXRhLCB0aGlzLmdldFN0YXJ0KCkubW92ZSgtc2tpcEVuZCkuZGF0YSk7XG4gIH1cbn1cblxudHlwZSBBbnlTcGFuID0gSGJzU3BhbiB8IENoYXJQb3NpdGlvblNwYW4gfCBJbnZpc2libGVTcGFuO1xuXG5jbGFzcyBDaGFyUG9zaXRpb25TcGFuIGltcGxlbWVudHMgU3BhbkRhdGEge1xuICByZWFkb25seSBraW5kID0gT2Zmc2V0S2luZC5DaGFyUG9zaXRpb247XG5cbiAgI2xvY1Bvc1NwYW46IEhic1NwYW4gfCBCUk9LRU4gfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBzb3VyY2U6IFNvdXJjZSxcbiAgICByZWFkb25seSBjaGFyUG9zaXRpb25zOiB7IHN0YXJ0OiBDaGFyUG9zaXRpb247IGVuZDogQ2hhclBvc2l0aW9uIH1cbiAgKSB7fVxuXG4gIHdyYXAoKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VTcGFuKHRoaXMpO1xuICB9XG5cbiAgYXNTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc2xpY2UodGhpcy5jaGFyUG9zaXRpb25zLnN0YXJ0LmNoYXJQb3MsIHRoaXMuY2hhclBvc2l0aW9ucy5lbmQuY2hhclBvcyk7XG4gIH1cblxuICBnZXRNb2R1bGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UubW9kdWxlO1xuICB9XG5cbiAgZ2V0U3RhcnQoKTogQW55UG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmNoYXJQb3NpdGlvbnMuc3RhcnQ7XG4gIH1cblxuICBnZXRFbmQoKTogQW55UG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmNoYXJQb3NpdGlvbnMuZW5kO1xuICB9XG5cbiAgbG9jRGlkVXBkYXRlKCkge1xuICAgIGlmIChMT0NBTF9ERUJVRykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYHVwZGF0aW5nIGEgbG9jYXRpb24gdGhhdCBjYW1lIGZyb20gYSBDaGFyUG9zaXRpb24gc3BhbiBkb2Vzbid0IHdvcmsgcmVsaWFibHkuIERvbid0IHRyeSB0byB1cGRhdGUgbG9jYXRpb25zIGFmdGVyIHRoZSBwbHVnaW4gcGhhc2VgXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHRvSGJzU3BhbigpOiBIYnNTcGFuIHwgbnVsbCB7XG4gICAgbGV0IGxvY1Bvc1NwYW4gPSB0aGlzLiNsb2NQb3NTcGFuO1xuXG4gICAgaWYgKGxvY1Bvc1NwYW4gPT09IG51bGwpIHtcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuY2hhclBvc2l0aW9ucy5zdGFydC50b0hic1BvcygpO1xuICAgICAgbGV0IGVuZCA9IHRoaXMuY2hhclBvc2l0aW9ucy5lbmQudG9IYnNQb3MoKTtcblxuICAgICAgaWYgKHN0YXJ0ID09PSBudWxsIHx8IGVuZCA9PT0gbnVsbCkge1xuICAgICAgICBsb2NQb3NTcGFuID0gdGhpcy4jbG9jUG9zU3BhbiA9IEJST0tFTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvY1Bvc1NwYW4gPSB0aGlzLiNsb2NQb3NTcGFuID0gbmV3IEhic1NwYW4odGhpcy5zb3VyY2UsIHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsb2NQb3NTcGFuID09PSBCUk9LRU4gPyBudWxsIDogbG9jUG9zU3BhbjtcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemVkU291cmNlU3BhbiB7XG4gICAgbGV0IHtcbiAgICAgIHN0YXJ0OiB7IGNoYXJQb3M6IHN0YXJ0IH0sXG4gICAgICBlbmQ6IHsgY2hhclBvczogZW5kIH0sXG4gICAgfSA9IHRoaXMuY2hhclBvc2l0aW9ucztcblxuICAgIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbc3RhcnQsIGVuZF07XG4gICAgfVxuICB9XG5cbiAgdG9DaGFyUG9zU3BhbigpOiBDaGFyUG9zaXRpb25TcGFuIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSGJzU3BhbiBpbXBsZW1lbnRzIFNwYW5EYXRhIHtcbiAgcmVhZG9ubHkga2luZCA9IE9mZnNldEtpbmQuSGJzUG9zaXRpb247XG5cbiAgI2NoYXJQb3NTcGFuOiBDaGFyUG9zaXRpb25TcGFuIHwgQlJPS0VOIHwgbnVsbCA9IG51bGw7XG5cbiAgLy8gdGhlIHNvdXJjZSBsb2NhdGlvbiBmcm9tIEhhbmRsZWJhcnMgKyBBU1QgUGx1Z2lucyAtLSBjb3VsZCBiZSB3cm9uZ1xuICAjcHJvdmlkZWRIYnNMb2M6IFNvdXJjZUxvY2F0aW9uIHwgbnVsbDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBzb3VyY2U6IFNvdXJjZSxcbiAgICByZWFkb25seSBoYnNQb3NpdGlvbnM6IHsgc3RhcnQ6IEhic1Bvc2l0aW9uOyBlbmQ6IEhic1Bvc2l0aW9uIH0sXG4gICAgcHJvdmlkZWRIYnNMb2M6IFNvdXJjZUxvY2F0aW9uIHwgbnVsbCA9IG51bGxcbiAgKSB7XG4gICAgdGhpcy4jcHJvdmlkZWRIYnNMb2MgPSBwcm92aWRlZEhic0xvYztcbiAgfVxuXG4gIHNlcmlhbGl6ZSgpOiBTZXJpYWxpemVkQ29uY3JldGVTb3VyY2VTcGFuIHtcbiAgICBsZXQgY2hhclBvcyA9IHRoaXMudG9DaGFyUG9zU3BhbigpO1xuICAgIHJldHVybiBjaGFyUG9zID09PSBudWxsID8gT2Zmc2V0S2luZC5Ccm9rZW4gOiBjaGFyUG9zLndyYXAoKS5zZXJpYWxpemUoKTtcbiAgfVxuXG4gIHdyYXAoKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VTcGFuKHRoaXMpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVQcm92aWRlZChwb3M6IFNvdXJjZVBvc2l0aW9uLCBlZGdlOiAnc3RhcnQnIHwgJ2VuZCcpIHtcbiAgICBpZiAodGhpcy4jcHJvdmlkZWRIYnNMb2MpIHtcbiAgICAgIHRoaXMuI3Byb3ZpZGVkSGJzTG9jW2VkZ2VdID0gcG9zO1xuICAgIH1cblxuICAgIC8vIGludmFsaWRhdGUgY29tcHV0ZWQgY2hhcmFjdGVyIG9mZnNldHNcbiAgICB0aGlzLiNjaGFyUG9zU3BhbiA9IG51bGw7XG4gICAgdGhpcy4jcHJvdmlkZWRIYnNMb2MgPSB7XG4gICAgICBzdGFydDogcG9zLFxuICAgICAgZW5kOiBwb3MsXG4gICAgfTtcbiAgfVxuXG4gIGxvY0RpZFVwZGF0ZSh7IHN0YXJ0LCBlbmQgfTogeyBzdGFydD86IFNvdXJjZVBvc2l0aW9uOyBlbmQ/OiBTb3VyY2VQb3NpdGlvbiB9KTogdm9pZCB7XG4gICAgaWYgKHN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlUHJvdmlkZWQoc3RhcnQsICdzdGFydCcpO1xuICAgICAgdGhpcy5oYnNQb3NpdGlvbnMuc3RhcnQgPSBuZXcgSGJzUG9zaXRpb24odGhpcy5zb3VyY2UsIHN0YXJ0LCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlUHJvdmlkZWQoZW5kLCAnZW5kJyk7XG4gICAgICB0aGlzLmhic1Bvc2l0aW9ucy5lbmQgPSBuZXcgSGJzUG9zaXRpb24odGhpcy5zb3VyY2UsIGVuZCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgYXNTdHJpbmcoKTogc3RyaW5nIHtcbiAgICBsZXQgc3BhbiA9IHRoaXMudG9DaGFyUG9zU3BhbigpO1xuICAgIHJldHVybiBzcGFuID09PSBudWxsID8gJycgOiBzcGFuLmFzU3RyaW5nKCk7XG4gIH1cblxuICBnZXRNb2R1bGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UubW9kdWxlO1xuICB9XG5cbiAgZ2V0U3RhcnQoKTogQW55UG9zaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmhic1Bvc2l0aW9ucy5zdGFydDtcbiAgfVxuXG4gIGdldEVuZCgpOiBBbnlQb3NpdGlvbiB7XG4gICAgcmV0dXJuIHRoaXMuaGJzUG9zaXRpb25zLmVuZDtcbiAgfVxuXG4gIHRvSGJzTG9jKCk6IFNvdXJjZUxvY2F0aW9uIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHRoaXMuaGJzUG9zaXRpb25zLnN0YXJ0Lmhic1BvcyxcbiAgICAgIGVuZDogdGhpcy5oYnNQb3NpdGlvbnMuZW5kLmhic1BvcyxcbiAgICB9O1xuICB9XG5cbiAgdG9IYnNTcGFuKCk6IEhic1NwYW4ge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdG9DaGFyUG9zU3BhbigpOiBDaGFyUG9zaXRpb25TcGFuIHwgbnVsbCB7XG4gICAgbGV0IGNoYXJQb3NTcGFuID0gdGhpcy4jY2hhclBvc1NwYW47XG5cbiAgICBpZiAoY2hhclBvc1NwYW4gPT09IG51bGwpIHtcbiAgICAgIGxldCBzdGFydCA9IHRoaXMuaGJzUG9zaXRpb25zLnN0YXJ0LnRvQ2hhclBvcygpO1xuICAgICAgbGV0IGVuZCA9IHRoaXMuaGJzUG9zaXRpb25zLmVuZC50b0NoYXJQb3MoKTtcblxuICAgICAgaWYgKHN0YXJ0ICYmIGVuZCkge1xuICAgICAgICBjaGFyUG9zU3BhbiA9IHRoaXMuI2NoYXJQb3NTcGFuID0gbmV3IENoYXJQb3NpdGlvblNwYW4odGhpcy5zb3VyY2UsIHtcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhclBvc1NwYW4gPSB0aGlzLiNjaGFyUG9zU3BhbiA9IEJST0tFTjtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXJQb3NTcGFuID09PSBCUk9LRU4gPyBudWxsIDogY2hhclBvc1NwYW47XG4gIH1cbn1cblxuY2xhc3MgSW52aXNpYmxlU3BhbiBpbXBsZW1lbnRzIFNwYW5EYXRhIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkga2luZDogT2Zmc2V0S2luZC5Ccm9rZW4gfCBPZmZzZXRLaW5kLkludGVybmFsc1N5bnRoZXRpYyB8IE9mZnNldEtpbmQuTm9uRXhpc3RlbnQsXG4gICAgLy8gd2hhdGV2ZXIgd2FzIHByb3ZpZGVkLCBwb3NzaWJseSBicm9rZW5cbiAgICByZWFkb25seSBsb2M6IFNvdXJjZUxvY2F0aW9uLFxuICAgIC8vIGlmIHRoZSBzcGFuIHJlcHJlc2VudHMgYSBzeW50aGV0aWMgc3RyaW5nXG4gICAgcmVhZG9ubHkgc3RyaW5nOiBzdHJpbmcgfCBudWxsID0gbnVsbFxuICApIHt9XG5cbiAgc2VyaWFsaXplKCk6IFNlcmlhbGl6ZWRDb25jcmV0ZVNvdXJjZVNwYW4ge1xuICAgIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gICAgICBjYXNlIE9mZnNldEtpbmQuQnJva2VuOlxuICAgICAgY2FzZSBPZmZzZXRLaW5kLk5vbkV4aXN0ZW50OlxuICAgICAgICByZXR1cm4gdGhpcy5raW5kO1xuICAgICAgY2FzZSBPZmZzZXRLaW5kLkludGVybmFsc1N5bnRoZXRpYzpcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nIHx8ICcnO1xuICAgIH1cbiAgfVxuXG4gIHdyYXAoKTogU291cmNlU3BhbiB7XG4gICAgcmV0dXJuIG5ldyBTb3VyY2VTcGFuKHRoaXMpO1xuICB9XG5cbiAgYXNTdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcgfHwgJyc7XG4gIH1cblxuICBsb2NEaWRVcGRhdGUoeyBzdGFydCwgZW5kIH06IHsgc3RhcnQ/OiBTb3VyY2VQb3NpdGlvbjsgZW5kPzogU291cmNlUG9zaXRpb24gfSkge1xuICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmxvYy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cblxuICAgIGlmIChlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sb2MuZW5kID0gZW5kO1xuICAgIH1cbiAgfVxuXG4gIGdldE1vZHVsZSgpOiBzdHJpbmcge1xuICAgIC8vIFRPRE86IE1ha2UgdGhpcyByZWZsZWN0IHRoZSBhY3R1YWwgbW9kdWxlIHRoaXMgc3BhbiBvcmlnaW5hdGVkIGZyb21cbiAgICByZXR1cm4gJ2FuIHVua25vd24gbW9kdWxlJztcbiAgfVxuXG4gIGdldFN0YXJ0KCk6IEFueVBvc2l0aW9uIHtcbiAgICByZXR1cm4gbmV3IEludmlzaWJsZVBvc2l0aW9uKHRoaXMua2luZCwgdGhpcy5sb2Muc3RhcnQpO1xuICB9XG5cbiAgZ2V0RW5kKCk6IEFueVBvc2l0aW9uIHtcbiAgICByZXR1cm4gbmV3IEludmlzaWJsZVBvc2l0aW9uKHRoaXMua2luZCwgdGhpcy5sb2MuZW5kKTtcbiAgfVxuXG4gIHRvQ2hhclBvc1NwYW4oKTogSW52aXNpYmxlU3BhbiB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0b0hic1NwYW4oKTogbnVsbCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0b0hic0xvYygpOiBTb3VyY2VMb2NhdGlvbiB7XG4gICAgcmV0dXJuIEJST0tFTl9MT0NBVElPTjtcbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgc3BhbjogTWF0Y2hGbjxTb3VyY2VTcGFuPiA9IG1hdGNoKChtKSA9PlxuICBtXG4gICAgLndoZW4oT2Zmc2V0S2luZC5IYnNQb3NpdGlvbiwgT2Zmc2V0S2luZC5IYnNQb3NpdGlvbiwgKGxlZnQsIHJpZ2h0KSA9PlxuICAgICAgbmV3IEhic1NwYW4obGVmdC5zb3VyY2UsIHtcbiAgICAgICAgc3RhcnQ6IGxlZnQsXG4gICAgICAgIGVuZDogcmlnaHQsXG4gICAgICB9KS53cmFwKClcbiAgICApXG4gICAgLndoZW4oT2Zmc2V0S2luZC5DaGFyUG9zaXRpb24sIE9mZnNldEtpbmQuQ2hhclBvc2l0aW9uLCAobGVmdCwgcmlnaHQpID0+XG4gICAgICBuZXcgQ2hhclBvc2l0aW9uU3BhbihsZWZ0LnNvdXJjZSwge1xuICAgICAgICBzdGFydDogbGVmdCxcbiAgICAgICAgZW5kOiByaWdodCxcbiAgICAgIH0pLndyYXAoKVxuICAgIClcbiAgICAud2hlbihPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbiwgT2Zmc2V0S2luZC5IYnNQb3NpdGlvbiwgKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBsZXQgcmlnaHRDaGFyUG9zID0gcmlnaHQudG9DaGFyUG9zKCk7XG5cbiAgICAgIGlmIChyaWdodENoYXJQb3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZpc2libGVTcGFuKE9mZnNldEtpbmQuQnJva2VuLCBCUk9LRU5fTE9DQVRJT04pLndyYXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzcGFuKGxlZnQsIHJpZ2h0Q2hhclBvcyk7XG4gICAgICB9XG4gICAgfSlcbiAgICAud2hlbihPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLCBPZmZzZXRLaW5kLkNoYXJQb3NpdGlvbiwgKGxlZnQsIHJpZ2h0KSA9PiB7XG4gICAgICBsZXQgbGVmdENoYXJQb3MgPSBsZWZ0LnRvQ2hhclBvcygpO1xuXG4gICAgICBpZiAobGVmdENoYXJQb3MgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnZpc2libGVTcGFuKE9mZnNldEtpbmQuQnJva2VuLCBCUk9LRU5fTE9DQVRJT04pLndyYXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzcGFuKGxlZnRDaGFyUG9zLCByaWdodCk7XG4gICAgICB9XG4gICAgfSlcbiAgICAud2hlbihJc0ludmlzaWJsZSwgTWF0Y2hBbnksIChsZWZ0KSA9PiBuZXcgSW52aXNpYmxlU3BhbihsZWZ0LmtpbmQsIEJST0tFTl9MT0NBVElPTikud3JhcCgpKVxuICAgIC53aGVuKE1hdGNoQW55LCBJc0ludmlzaWJsZSwgKF8sIHJpZ2h0KSA9PlxuICAgICAgbmV3IEludmlzaWJsZVNwYW4ocmlnaHQua2luZCwgQlJPS0VOX0xPQ0FUSU9OKS53cmFwKClcbiAgICApXG4pO1xuXG5leHBvcnQgdHlwZSBTZXJpYWxpemVkQ29uY3JldGVTb3VyY2VTcGFuID1cbiAgfCAvKiogY29sbGFwc2VkICovIG51bWJlclxuICB8IC8qKiBub3JtYWwgKi8gW3N0YXJ0OiBudW1iZXIsIHNpemU6IG51bWJlcl1cbiAgfCAvKiogc3ludGhldGljICovIHN0cmluZztcblxuZXhwb3J0IHR5cGUgU2VyaWFsaXplZFNvdXJjZVNwYW4gPVxuICB8IFNlcmlhbGl6ZWRDb25jcmV0ZVNvdXJjZVNwYW5cbiAgfCBPZmZzZXRLaW5kLk5vbkV4aXN0ZW50XG4gIHwgT2Zmc2V0S2luZC5Ccm9rZW47XG4iXSwic291cmNlUm9vdCI6IiJ9