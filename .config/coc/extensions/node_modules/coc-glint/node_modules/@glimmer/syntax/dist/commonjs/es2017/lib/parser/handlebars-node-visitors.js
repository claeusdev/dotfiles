"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HandlebarsNodeVisitors = void 0;

var _parser = require("../parser");

var _location = require("../source/location");

var _syntaxError = require("../syntax-error");

var _utils = require("../utils");

var _legacyInterop = require("../v1/legacy-interop");

var _parserBuilders = _interopRequireDefault(require("../v1/parser-builders"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class HandlebarsNodeVisitors extends _parser.Parser {
  get isTopLevel() {
    return this.elementStack.length === 0;
  }

  Program(program) {
    let body = [];
    let node;

    if (this.isTopLevel) {
      node = _parserBuilders.default.template({
        body,
        blockParams: program.blockParams,
        loc: this.source.spanFor(program.loc)
      });
    } else {
      node = _parserBuilders.default.blockItself({
        body,
        blockParams: program.blockParams,
        chained: program.chained,
        loc: this.source.spanFor(program.loc)
      });
    }

    let i,
        l = program.body.length;
    this.elementStack.push(node);

    if (l === 0) {
      return this.elementStack.pop();
    }

    for (i = 0; i < l; i++) {
      this.acceptNode(program.body[i]);
    } // Ensure that that the element stack is balanced properly.


    let poppedNode = this.elementStack.pop();

    if (poppedNode !== node) {
      let elementNode = poppedNode;
      throw (0, _syntaxError.generateSyntaxError)(`Unclosed element \`${elementNode.tag}\``, elementNode.loc);
    }

    return node;
  }

  BlockStatement(block) {
    if (this.tokenizer.state === "comment"
    /* comment */
    ) {
        this.appendToCommentData(this.sourceForNode(block));
        return;
      }

    if (this.tokenizer.state !== "data"
    /* data */
    && this.tokenizer.state !== "beforeData"
    /* beforeData */
    ) {
        throw (0, _syntaxError.generateSyntaxError)('A block may only be used inside an HTML element or another block.', this.source.spanFor(block.loc));
      }

    let {
      path,
      params,
      hash
    } = acceptCallNodes(this, block); // These are bugs in Handlebars upstream

    if (!block.program.loc) {
      block.program.loc = _location.NON_EXISTENT_LOCATION;
    }

    if (block.inverse && !block.inverse.loc) {
      block.inverse.loc = _location.NON_EXISTENT_LOCATION;
    }

    let program = this.Program(block.program);
    let inverse = block.inverse ? this.Program(block.inverse) : null;

    let node = _parserBuilders.default.block({
      path,
      params,
      hash,
      defaultBlock: program,
      elseBlock: inverse,
      loc: this.source.spanFor(block.loc),
      openStrip: block.openStrip,
      inverseStrip: block.inverseStrip,
      closeStrip: block.closeStrip
    });

    let parentProgram = this.currentElement();
    (0, _utils.appendChild)(parentProgram, node);
  }

  MustacheStatement(rawMustache) {
    let {
      tokenizer
    } = this;

    if (tokenizer.state === 'comment') {
      this.appendToCommentData(this.sourceForNode(rawMustache));
      return;
    }

    let mustache;
    let {
      escaped,
      loc,
      strip
    } = rawMustache;

    if ((0, _utils.isHBSLiteral)(rawMustache.path)) {
      mustache = _parserBuilders.default.mustache({
        path: this.acceptNode(rawMustache.path),
        params: [],
        hash: _parserBuilders.default.hash([], this.source.spanFor(rawMustache.path.loc).collapse('end')),
        trusting: !escaped,
        loc: this.source.spanFor(loc),
        strip
      });
    } else {
      let {
        path,
        params,
        hash
      } = acceptCallNodes(this, rawMustache);
      mustache = _parserBuilders.default.mustache({
        path,
        params,
        hash,
        trusting: !escaped,
        loc: this.source.spanFor(loc),
        strip
      });
    }

    switch (tokenizer.state) {
      // Tag helpers
      case "tagOpen"
      /* tagOpen */
      :
      case "tagName"
      /* tagName */
      :
        throw (0, _syntaxError.generateSyntaxError)(`Cannot use mustaches in an elements tagname`, mustache.loc);

      case "beforeAttributeName"
      /* beforeAttributeName */
      :
        addElementModifier(this.currentStartTag, mustache);
        break;

      case "attributeName"
      /* attributeName */
      :
      case "afterAttributeName"
      /* afterAttributeName */
      :
        this.beginAttributeValue(false);
        this.finishAttributeValue();
        addElementModifier(this.currentStartTag, mustache);
        tokenizer.transitionTo("beforeAttributeName"
        /* beforeAttributeName */
        );
        break;

      case "afterAttributeValueQuoted"
      /* afterAttributeValueQuoted */
      :
        addElementModifier(this.currentStartTag, mustache);
        tokenizer.transitionTo("beforeAttributeName"
        /* beforeAttributeName */
        );
        break;
      // Attribute values

      case "beforeAttributeValue"
      /* beforeAttributeValue */
      :
        this.beginAttributeValue(false);
        this.appendDynamicAttributeValuePart(mustache);
        tokenizer.transitionTo("attributeValueUnquoted"
        /* attributeValueUnquoted */
        );
        break;

      case "attributeValueDoubleQuoted"
      /* attributeValueDoubleQuoted */
      :
      case "attributeValueSingleQuoted"
      /* attributeValueSingleQuoted */
      :
      case "attributeValueUnquoted"
      /* attributeValueUnquoted */
      :
        this.appendDynamicAttributeValuePart(mustache);
        break;
      // TODO: Only append child when the tokenizer state makes
      // sense to do so, otherwise throw an error.

      default:
        (0, _utils.appendChild)(this.currentElement(), mustache);
    }

    return mustache;
  }

  appendDynamicAttributeValuePart(part) {
    this.finalizeTextPart();
    let attr = this.currentAttr;
    attr.isDynamic = true;
    attr.parts.push(part);
  }

  finalizeTextPart() {
    let attr = this.currentAttr;
    let text = attr.currentPart;

    if (text !== null) {
      this.currentAttr.parts.push(text);
      this.startTextPart();
    }
  }

  startTextPart() {
    this.currentAttr.currentPart = null;
  }

  ContentStatement(content) {
    updateTokenizerLocation(this.tokenizer, content);
    this.tokenizer.tokenizePart(content.value);
    this.tokenizer.flushData();
  }

  CommentStatement(rawComment) {
    let {
      tokenizer
    } = this;

    if (tokenizer.state === "comment"
    /* comment */
    ) {
        this.appendToCommentData(this.sourceForNode(rawComment));
        return null;
      }

    let {
      value,
      loc
    } = rawComment;

    let comment = _parserBuilders.default.mustacheComment(value, this.source.spanFor(loc));

    switch (tokenizer.state) {
      case "beforeAttributeName"
      /* beforeAttributeName */
      :
        this.currentStartTag.comments.push(comment);
        break;

      case "beforeData"
      /* beforeData */
      :
      case "data"
      /* data */
      :
        (0, _utils.appendChild)(this.currentElement(), comment);
        break;

      default:
        throw (0, _syntaxError.generateSyntaxError)(`Using a Handlebars comment when in the \`${tokenizer['state']}\` state is not supported`, this.source.spanFor(rawComment.loc));
    }

    return comment;
  }

  PartialStatement(partial) {
    throw (0, _syntaxError.generateSyntaxError)(`Handlebars partials are not supported`, this.source.spanFor(partial.loc));
  }

  PartialBlockStatement(partialBlock) {
    throw (0, _syntaxError.generateSyntaxError)(`Handlebars partial blocks are not supported`, this.source.spanFor(partialBlock.loc));
  }

  Decorator(decorator) {
    throw (0, _syntaxError.generateSyntaxError)(`Handlebars decorators are not supported`, this.source.spanFor(decorator.loc));
  }

  DecoratorBlock(decoratorBlock) {
    throw (0, _syntaxError.generateSyntaxError)(`Handlebars decorator blocks are not supported`, this.source.spanFor(decoratorBlock.loc));
  }

  SubExpression(sexpr) {
    let {
      path,
      params,
      hash
    } = acceptCallNodes(this, sexpr);
    return _parserBuilders.default.sexpr({
      path,
      params,
      hash,
      loc: this.source.spanFor(sexpr.loc)
    });
  }

  PathExpression(path) {
    let {
      original
    } = path;
    let parts;

    if (original.indexOf('/') !== -1) {
      if (original.slice(0, 2) === './') {
        throw (0, _syntaxError.generateSyntaxError)(`Using "./" is not supported in Glimmer and unnecessary`, this.source.spanFor(path.loc));
      }

      if (original.slice(0, 3) === '../') {
        throw (0, _syntaxError.generateSyntaxError)(`Changing context using "../" is not supported in Glimmer`, this.source.spanFor(path.loc));
      }

      if (original.indexOf('.') !== -1) {
        throw (0, _syntaxError.generateSyntaxError)(`Mixing '.' and '/' in paths is not supported in Glimmer; use only '.' to separate property paths`, this.source.spanFor(path.loc));
      }

      parts = [path.parts.join('/')];
    } else if (original === '.') {
      throw (0, _syntaxError.generateSyntaxError)(`'.' is not a supported path in Glimmer; check for a path with a trailing '.'`, this.source.spanFor(path.loc));
    } else {
      parts = path.parts;
    }

    let thisHead = false; // This is to fix a bug in the Handlebars AST where the path expressions in
    // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
    // are simply turned into `{{foo}}`. The fix is to push it back onto the
    // parts array and let the runtime see the difference. However, we cannot
    // simply use the string `this` as it means literally the property called
    // "this" in the current context (it can be expressed in the syntax as
    // `{{[this]}}`, where the square bracket are generally for this kind of
    // escaping â€“ such as `{{foo.["bar.baz"]}}` would mean lookup a property
    // named literally "bar.baz" on `this.foo`). By convention, we use `null`
    // for this purpose.

    if (original.match(/^this(\..+)?$/)) {
      thisHead = true;
    }

    let pathHead;

    if (thisHead) {
      pathHead = {
        type: 'ThisHead',
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + 4
          }
        }
      };
    } else if (path.data) {
      let head = parts.shift();

      if (head === undefined) {
        throw (0, _syntaxError.generateSyntaxError)(`Attempted to parse a path expression, but it was not valid. Paths beginning with @ must start with a-z.`, this.source.spanFor(path.loc));
      }

      pathHead = {
        type: 'AtHead',
        name: `@${head}`,
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + head.length + 1
          }
        }
      };
    } else {
      let head = parts.shift();

      if (head === undefined) {
        throw (0, _syntaxError.generateSyntaxError)(`Attempted to parse a path expression, but it was not valid. Paths must start with a-z or A-Z.`, this.source.spanFor(path.loc));
      }

      pathHead = {
        type: 'VarHead',
        name: head,
        loc: {
          start: path.loc.start,
          end: {
            line: path.loc.start.line,
            column: path.loc.start.column + head.length
          }
        }
      };
    }

    return new _legacyInterop.PathExpressionImplV1(path.original, pathHead, parts, this.source.spanFor(path.loc));
  }

  Hash(hash) {
    let pairs = [];

    for (let i = 0; i < hash.pairs.length; i++) {
      let pair = hash.pairs[i];
      pairs.push(_parserBuilders.default.pair({
        key: pair.key,
        value: this.acceptNode(pair.value),
        loc: this.source.spanFor(pair.loc)
      }));
    }

    return _parserBuilders.default.hash(pairs, this.source.spanFor(hash.loc));
  }

  StringLiteral(string) {
    return _parserBuilders.default.literal({
      type: 'StringLiteral',
      value: string.value,
      loc: string.loc
    });
  }

  BooleanLiteral(boolean) {
    return _parserBuilders.default.literal({
      type: 'BooleanLiteral',
      value: boolean.value,
      loc: boolean.loc
    });
  }

  NumberLiteral(number) {
    return _parserBuilders.default.literal({
      type: 'NumberLiteral',
      value: number.value,
      loc: number.loc
    });
  }

  UndefinedLiteral(undef) {
    return _parserBuilders.default.literal({
      type: 'UndefinedLiteral',
      value: undefined,
      loc: undef.loc
    });
  }

  NullLiteral(nul) {
    return _parserBuilders.default.literal({
      type: 'NullLiteral',
      value: null,
      loc: nul.loc
    });
  }

}

exports.HandlebarsNodeVisitors = HandlebarsNodeVisitors;

function calculateRightStrippedOffsets(original, value) {
  if (value === '') {
    // if it is empty, just return the count of newlines
    // in original
    return {
      lines: original.split('\n').length - 1,
      columns: 0
    };
  } // otherwise, return the number of newlines prior to
  // `value`


  let difference = original.split(value)[0];
  let lines = difference.split(/\n/);
  let lineCount = lines.length - 1;
  return {
    lines: lineCount,
    columns: lines[lineCount].length
  };
}

function updateTokenizerLocation(tokenizer, content) {
  let line = content.loc.start.line;
  let column = content.loc.start.column;
  let offsets = calculateRightStrippedOffsets(content.original, content.value);
  line = line + offsets.lines;

  if (offsets.lines) {
    column = offsets.columns;
  } else {
    column = column + offsets.columns;
  }

  tokenizer.line = line;
  tokenizer.column = column;
}

function acceptCallNodes(compiler, node) {
  let path = compiler.PathExpression(node.path);
  let params = node.params ? node.params.map(e => compiler.acceptNode(e)) : []; // if there is no hash, position it as a collapsed node immediately after the last param (or the
  // path, if there are also no params)

  let end = params.length > 0 ? params[params.length - 1].loc : path.loc;
  let hash = node.hash ? compiler.Hash(node.hash) : {
    type: 'Hash',
    pairs: [],
    loc: compiler.source.spanFor(end).collapse('end')
  };
  return {
    path,
    params,
    hash
  };
}

function addElementModifier(element, mustache) {
  let {
    path,
    params,
    hash,
    loc
  } = mustache;

  if ((0, _utils.isHBSLiteral)(path)) {
    let modifier = `{{${(0, _utils.printLiteral)(path)}}}`;
    let tag = `<${element.name} ... ${modifier} ...`;
    throw (0, _syntaxError.generateSyntaxError)(`In ${tag}, ${modifier} is not a valid modifier`, mustache.loc);
  }

  let modifier = _parserBuilders.default.elementModifier({
    path,
    params,
    hash,
    loc
  });

  element.modifiers.push(modifier);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL2hhbmRsZWJhcnMtbm9kZS12aXNpdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBR0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBR0E7O0FBQ0E7Ozs7QUFFTSxNQUFBLHNCQUFBLFNBQUEsY0FBQSxDQUFxRDtBQUt6RCxNQUFBLFVBQUEsR0FBc0I7QUFDcEIsV0FBTyxLQUFBLFlBQUEsQ0FBQSxNQUFBLEtBQVAsQ0FBQTtBQUNEOztBQUtELEVBQUEsT0FBTyxDQUFBLE9BQUEsRUFBcUI7QUFDMUIsUUFBSSxJQUFJLEdBQVIsRUFBQTtBQUNBLFFBQUEsSUFBQTs7QUFFQSxRQUFJLEtBQUosVUFBQSxFQUFxQjtBQUNuQixNQUFBLElBQUksR0FBRyx3QkFBQSxRQUFBLENBQVc7QUFBQSxRQUFBLElBQUE7QUFFaEIsUUFBQSxXQUFXLEVBQUUsT0FBTyxDQUZKLFdBQUE7QUFHaEIsUUFBQSxHQUFHLEVBQUUsS0FBQSxNQUFBLENBQUEsT0FBQSxDQUFvQixPQUFPLENBQTNCLEdBQUE7QUFIVyxPQUFYLENBQVA7QUFERixLQUFBLE1BTU87QUFDTCxNQUFBLElBQUksR0FBRyx3QkFBQSxXQUFBLENBQWM7QUFBQSxRQUFBLElBQUE7QUFFbkIsUUFBQSxXQUFXLEVBQUUsT0FBTyxDQUZELFdBQUE7QUFHbkIsUUFBQSxPQUFPLEVBQUUsT0FBTyxDQUhHLE9BQUE7QUFJbkIsUUFBQSxHQUFHLEVBQUUsS0FBQSxNQUFBLENBQUEsT0FBQSxDQUFvQixPQUFPLENBQTNCLEdBQUE7QUFKYyxPQUFkLENBQVA7QUFNRDs7QUFFRCxRQUFBLENBQUE7QUFBQSxRQUNFLENBQUMsR0FBRyxPQUFPLENBQVAsSUFBQSxDQUROLE1BQUE7QUFHQSxTQUFBLFlBQUEsQ0FBQSxJQUFBLENBQUEsSUFBQTs7QUFFQSxRQUFJLENBQUMsS0FBTCxDQUFBLEVBQWE7QUFDWCxhQUFPLEtB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LENBQUEsT0FBQSxFQUFBLFFBQUEsRUFFbUM7QUFFakMsTUFBSTtBQUFBLElBQUEsSUFBQTtBQUFBLElBQUEsTUFBQTtBQUFBLElBQUEsSUFBQTtBQUFzQixJQUFBO0FBQXRCLE1BQUosUUFBQTs7QUFFQSxNQUFJLHlCQUFKLElBQUksQ0FBSixFQUF3QjtBQUN0QixRQUFJLFFBQVEsR0FBRyxLQUFLLHlCQUFZLElBQVosQ0FBcEIsSUFBQTtBQUNBLFFBQUksR0FBRyxHQUFHLElBQUksT0FBTyxDQUFDLElBQUksUUFBUSxRQUFsQyxNQUFBO0FBRUEsVUFBTSxzQ0FBb0IsTUFBTSxHQUFHLEtBQUssUUFBZiwwQkFBbkIsRUFBc0UsUUFBUSxDQUFwRixHQUFNLENBQU47QUFDRDs7QUFFRCxNQUFJLFFBQVEsR0FBRyx3QkFBQSxlQUFBLENBQWtCO0FBQUEsSUFBQSxJQUFBO0FBQUEsSUFBQSxNQUFBO0FBQUEsSUFBQSxJQUFBO0FBQXNCLElBQUE7QUFBdEIsR0FBbEIsQ0FBZjs7QUFDQSxFQUFBLE9BQU8sQ0FBUCxTQUFBLENBQUEsSUFBQSxDQUFBLFFBQUE7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9wdGlvbiwgUmVjYXN0IH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBUb2tlbml6ZXJTdGF0ZSB9IGZyb20gJ3NpbXBsZS1odG1sLXRva2VuaXplcic7XG5cbmltcG9ydCB7IFBhcnNlciwgUGFyc2VyTm9kZUJ1aWxkZXIsIFRhZyB9IGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQgeyBOT05fRVhJU1RFTlRfTE9DQVRJT04gfSBmcm9tICcuLi9zb3VyY2UvbG9jYXRpb24nO1xuaW1wb3J0IHsgZ2VuZXJhdGVTeW50YXhFcnJvciB9IGZyb20gJy4uL3N5bnRheC1lcnJvcic7XG5pbXBvcnQgeyBhcHBlbmRDaGlsZCwgaXNIQlNMaXRlcmFsLCBwcmludExpdGVyYWwgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBBU1R2MSBmcm9tICcuLi92MS9hcGknO1xuaW1wb3J0ICogYXMgSEJTIGZyb20gJy4uL3YxL2hhbmRsZWJhcnMtYXN0JztcbmltcG9ydCB7IFBhdGhFeHByZXNzaW9uSW1wbFYxIH0gZnJvbSAnLi4vdjEvbGVnYWN5LWludGVyb3AnO1xuaW1wb3J0IGIgZnJvbSAnLi4vdjEvcGFyc2VyLWJ1aWxkZXJzJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMgZXh0ZW5kcyBQYXJzZXIge1xuICBhYnN0cmFjdCBhcHBlbmRUb0NvbW1lbnREYXRhKHM6IHN0cmluZyk6IHZvaWQ7XG4gIGFic3RyYWN0IGJlZ2luQXR0cmlidXRlVmFsdWUocXVvdGVkOiBib29sZWFuKTogdm9pZDtcbiAgYWJzdHJhY3QgZmluaXNoQXR0cmlidXRlVmFsdWUoKTogdm9pZDtcblxuICBwcml2YXRlIGdldCBpc1RvcExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFjay5sZW5ndGggPT09IDA7XG4gIH1cblxuICBQcm9ncmFtKHByb2dyYW06IEhCUy5Qcm9ncmFtKTogQVNUdjEuQmxvY2s7XG4gIFByb2dyYW0ocHJvZ3JhbTogSEJTLlByb2dyYW0pOiBBU1R2MS5UZW1wbGF0ZTtcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVHYxLlRlbXBsYXRlIHwgQVNUdjEuQmxvY2s7XG4gIFByb2dyYW0ocHJvZ3JhbTogSEJTLlByb2dyYW0pOiBBU1R2MS5CbG9jayB8IEFTVHYxLlRlbXBsYXRlIHtcbiAgICBsZXQgYm9keTogQVNUdjEuU3RhdGVtZW50W10gPSBbXTtcbiAgICBsZXQgbm9kZTtcblxuICAgIGlmICh0aGlzLmlzVG9wTGV2ZWwpIHtcbiAgICAgIG5vZGUgPSBiLnRlbXBsYXRlKHtcbiAgICAgICAgYm9keSxcbiAgICAgICAgYmxvY2tQYXJhbXM6IHByb2dyYW0uYmxvY2tQYXJhbXMsXG4gICAgICAgIGxvYzogdGhpcy5zb3VyY2Uuc3BhbkZvcihwcm9ncmFtLmxvYyksXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IGIuYmxvY2tJdHNlbGYoe1xuICAgICAgICBib2R5LFxuICAgICAgICBibG9ja1BhcmFtczogcHJvZ3JhbS5ibG9ja1BhcmFtcyxcbiAgICAgICAgY2hhaW5lZDogcHJvZ3JhbS5jaGFpbmVkLFxuICAgICAgICBsb2M6IHRoaXMuc291cmNlLnNwYW5Gb3IocHJvZ3JhbS5sb2MpLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbGV0IGksXG4gICAgICBsID0gcHJvZ3JhbS5ib2R5Lmxlbmd0aDtcblxuICAgIHRoaXMuZWxlbWVudFN0YWNrLnB1c2gobm9kZSk7XG5cbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpIGFzIEFTVHYxLkJsb2NrIHwgQVNUdjEuVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5hY2NlcHROb2RlKHByb2dyYW0uYm9keVtpXSk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhhdCB0aGUgZWxlbWVudCBzdGFjayBpcyBiYWxhbmNlZCBwcm9wZXJseS5cbiAgICBsZXQgcG9wcGVkTm9kZSA9IHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgIGlmIChwb3BwZWROb2RlICE9PSBub2RlKSB7XG4gICAgICBsZXQgZWxlbWVudE5vZGUgPSBwb3BwZWROb2RlIGFzIEFTVHYxLkVsZW1lbnROb2RlO1xuXG4gICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKGBVbmNsb3NlZCBlbGVtZW50IFxcYCR7ZWxlbWVudE5vZGUudGFnfVxcYGAsIGVsZW1lbnROb2RlLmxvYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBCbG9ja1N0YXRlbWVudChibG9jazogSEJTLkJsb2NrU3RhdGVtZW50KTogQVNUdjEuQmxvY2tTdGF0ZW1lbnQgfCB2b2lkIHtcbiAgICBpZiAodGhpcy50b2tlbml6ZXIuc3RhdGUgPT09IFRva2VuaXplclN0YXRlLmNvbW1lbnQpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUoYmxvY2spKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnRva2VuaXplci5zdGF0ZSAhPT0gVG9rZW5pemVyU3RhdGUuZGF0YSAmJlxuICAgICAgdGhpcy50b2tlbml6ZXIuc3RhdGUgIT09IFRva2VuaXplclN0YXRlLmJlZm9yZURhdGFcbiAgICApIHtcbiAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICdBIGJsb2NrIG1heSBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIEhUTUwgZWxlbWVudCBvciBhbm90aGVyIGJsb2NrLicsXG4gICAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IoYmxvY2subG9jKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCBibG9jayk7XG5cbiAgICAvLyBUaGVzZSBhcmUgYnVncyBpbiBIYW5kbGViYXJzIHVwc3RyZWFtXG4gICAgaWYgKCFibG9jay5wcm9ncmFtLmxvYykge1xuICAgICAgYmxvY2sucHJvZ3JhbS5sb2MgPSBOT05fRVhJU1RFTlRfTE9DQVRJT047XG4gICAgfVxuXG4gICAgaWYgKGJsb2NrLmludmVyc2UgJiYgIWJsb2NrLmludmVyc2UubG9jKSB7XG4gICAgICBibG9jay5pbnZlcnNlLmxvYyA9IE5PTl9FWElTVEVOVF9MT0NBVElPTjtcbiAgICB9XG5cbiAgICBsZXQgcHJvZ3JhbSA9IHRoaXMuUHJvZ3JhbShibG9jay5wcm9ncmFtKTtcbiAgICBsZXQgaW52ZXJzZSA9IGJsb2NrLmludmVyc2UgPyB0aGlzLlByb2dyYW0oYmxvY2suaW52ZXJzZSkgOiBudWxsO1xuXG4gICAgbGV0IG5vZGUgPSBiLmJsb2NrKHtcbiAgICAgIHBhdGgsXG4gICAgICBwYXJhbXMsXG4gICAgICBoYXNoLFxuICAgICAgZGVmYXVsdEJsb2NrOiBwcm9ncmFtLFxuICAgICAgZWxzZUJsb2NrOiBpbnZlcnNlLFxuICAgICAgbG9jOiB0aGlzLnNvdXJjZS5zcGFuRm9yKGJsb2NrLmxvYyksXG4gICAgICBvcGVuU3RyaXA6IGJsb2NrLm9wZW5TdHJpcCxcbiAgICAgIGludmVyc2VTdHJpcDogYmxvY2suaW52ZXJzZVN0cmlwLFxuICAgICAgY2xvc2VTdHJpcDogYmxvY2suY2xvc2VTdHJpcCxcbiAgICB9KTtcblxuICAgIGxldCBwYXJlbnRQcm9ncmFtID0gdGhpcy5jdXJyZW50RWxlbWVudCgpO1xuXG4gICAgYXBwZW5kQ2hpbGQocGFyZW50UHJvZ3JhbSwgbm9kZSk7XG4gIH1cblxuICBNdXN0YWNoZVN0YXRlbWVudChyYXdNdXN0YWNoZTogSEJTLk11c3RhY2hlU3RhdGVtZW50KTogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQgfCB2b2lkIHtcbiAgICBsZXQgeyB0b2tlbml6ZXIgfSA9IHRoaXM7XG5cbiAgICBpZiAodG9rZW5pemVyLnN0YXRlID09PSAnY29tbWVudCcpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUocmF3TXVzdGFjaGUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgbXVzdGFjaGU6IEFTVHYxLk11c3RhY2hlU3RhdGVtZW50O1xuICAgIGxldCB7IGVzY2FwZWQsIGxvYywgc3RyaXAgfSA9IHJhd011c3RhY2hlO1xuXG4gICAgaWYgKGlzSEJTTGl0ZXJhbChyYXdNdXN0YWNoZS5wYXRoKSkge1xuICAgICAgbXVzdGFjaGUgPSBiLm11c3RhY2hlKHtcbiAgICAgICAgcGF0aDogdGhpcy5hY2NlcHROb2RlPEFTVHYxLkxpdGVyYWw+KHJhd011c3RhY2hlLnBhdGgpLFxuICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICBoYXNoOiBiLmhhc2goW10sIHRoaXMuc291cmNlLnNwYW5Gb3IocmF3TXVzdGFjaGUucGF0aC5sb2MpLmNvbGxhcHNlKCdlbmQnKSksXG4gICAgICAgIHRydXN0aW5nOiAhZXNjYXBlZCxcbiAgICAgICAgbG9jOiB0aGlzLnNvdXJjZS5zcGFuRm9yKGxvYyksXG4gICAgICAgIHN0cmlwLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKFxuICAgICAgICB0aGlzLFxuICAgICAgICByYXdNdXN0YWNoZSBhcyBIQlMuTXVzdGFjaGVTdGF0ZW1lbnQgJiB7XG4gICAgICAgICAgcGF0aDogSEJTLlBhdGhFeHByZXNzaW9uO1xuICAgICAgICB9XG4gICAgICApO1xuICAgICAgbXVzdGFjaGUgPSBiLm11c3RhY2hlKHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBoYXNoLFxuICAgICAgICB0cnVzdGluZzogIWVzY2FwZWQsXG4gICAgICAgIGxvYzogdGhpcy5zb3VyY2Uuc3BhbkZvcihsb2MpLFxuICAgICAgICBzdHJpcCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW5pemVyLnN0YXRlKSB7XG4gICAgICAvLyBUYWcgaGVscGVyc1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS50YWdPcGVuOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS50YWdOYW1lOlxuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKGBDYW5ub3QgdXNlIG11c3RhY2hlcyBpbiBhbiBlbGVtZW50cyB0YWduYW1lYCwgbXVzdGFjaGUubG9jKTtcblxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lOlxuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZU5hbWU6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmFmdGVyQXR0cmlidXRlTmFtZTpcbiAgICAgICAgdGhpcy5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5maW5pc2hBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmFmdGVyQXR0cmlidXRlVmFsdWVRdW90ZWQ6XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gQXR0cmlidXRlIHZhbHVlc1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVWYWx1ZTpcbiAgICAgICAgdGhpcy5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5hcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVVucXVvdGVkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlRG91YmxlUXVvdGVkOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVNpbmdsZVF1b3RlZDpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVVbnF1b3RlZDpcbiAgICAgICAgdGhpcy5hcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KG11c3RhY2hlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIFRPRE86IE9ubHkgYXBwZW5kIGNoaWxkIHdoZW4gdGhlIHRva2VuaXplciBzdGF0ZSBtYWtlc1xuICAgICAgLy8gc2Vuc2UgdG8gZG8gc28sIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgbXVzdGFjaGUpO1xuICAgIH1cblxuICAgIHJldHVybiBtdXN0YWNoZTtcbiAgfVxuXG4gIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQocGFydDogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLmZpbmFsaXplVGV4dFBhcnQoKTtcbiAgICBsZXQgYXR0ciA9IHRoaXMuY3VycmVudEF0dHI7XG4gICAgYXR0ci5pc0R5bmFtaWMgPSB0cnVlO1xuICAgIGF0dHIucGFydHMucHVzaChwYXJ0KTtcbiAgfVxuXG4gIGZpbmFsaXplVGV4dFBhcnQoKTogdm9pZCB7XG4gICAgbGV0IGF0dHIgPSB0aGlzLmN1cnJlbnRBdHRyO1xuICAgIGxldCB0ZXh0ID0gYXR0ci5jdXJyZW50UGFydDtcbiAgICBpZiAodGV4dCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5jdXJyZW50QXR0ci5wYXJ0cy5wdXNoKHRleHQpO1xuICAgICAgdGhpcy5zdGFydFRleHRQYXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgc3RhcnRUZXh0UGFydCgpOiB2b2lkIHtcbiAgICB0aGlzLmN1cnJlbnRBdHRyLmN1cnJlbnRQYXJ0ID0gbnVsbDtcbiAgfVxuXG4gIENvbnRlbnRTdGF0ZW1lbnQoY29udGVudDogSEJTLkNvbnRlbnRTdGF0ZW1lbnQpOiB2b2lkIHtcbiAgICB1cGRhdGVUb2tlbml6ZXJMb2NhdGlvbih0aGlzLnRva2VuaXplciwgY29udGVudCk7XG5cbiAgICB0aGlzLnRva2VuaXplci50b2tlbml6ZVBhcnQoY29udGVudC52YWx1ZSk7XG4gICAgdGhpcy50b2tlbml6ZXIuZmx1c2hEYXRhKCk7XG4gIH1cblxuICBDb21tZW50U3RhdGVtZW50KHJhd0NvbW1lbnQ6IEhCUy5Db21tZW50U3RhdGVtZW50KTogT3B0aW9uPEFTVHYxLk11c3RhY2hlQ29tbWVudFN0YXRlbWVudD4ge1xuICAgIGxldCB7IHRva2VuaXplciB9ID0gdGhpcztcblxuICAgIGlmICh0b2tlbml6ZXIuc3RhdGUgPT09IFRva2VuaXplclN0YXRlLmNvbW1lbnQpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUocmF3Q29tbWVudCkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHsgdmFsdWUsIGxvYyB9ID0gcmF3Q29tbWVudDtcbiAgICBsZXQgY29tbWVudCA9IGIubXVzdGFjaGVDb21tZW50KHZhbHVlLCB0aGlzLnNvdXJjZS5zcGFuRm9yKGxvYykpO1xuXG4gICAgc3dpdGNoICh0b2tlbml6ZXIuc3RhdGUpIHtcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZTpcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhcnRUYWcuY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlRGF0YTpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuZGF0YTpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBjb21tZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVzaW5nIGEgSGFuZGxlYmFycyBjb21tZW50IHdoZW4gaW4gdGhlIFxcYCR7dG9rZW5pemVyWydzdGF0ZSddfVxcYCBzdGF0ZSBpcyBub3Qgc3VwcG9ydGVkYCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHJhd0NvbW1lbnQubG9jKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50O1xuICB9XG5cbiAgUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsOiBIQlMuUGFydGlhbFN0YXRlbWVudCk6IG5ldmVyIHtcbiAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgcGFydGlhbHMgYXJlIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcihwYXJ0aWFsLmxvYylcbiAgICApO1xuICB9XG5cbiAgUGFydGlhbEJsb2NrU3RhdGVtZW50KHBhcnRpYWxCbG9jazogSEJTLlBhcnRpYWxCbG9ja1N0YXRlbWVudCk6IG5ldmVyIHtcbiAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgcGFydGlhbCBibG9ja3MgYXJlIG5vdCBzdXBwb3J0ZWRgLFxuICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcihwYXJ0aWFsQmxvY2subG9jKVxuICAgICk7XG4gIH1cblxuICBEZWNvcmF0b3IoZGVjb3JhdG9yOiBIQlMuRGVjb3JhdG9yKTogbmV2ZXIge1xuICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBkZWNvcmF0b3JzIGFyZSBub3Qgc3VwcG9ydGVkYCxcbiAgICAgIHRoaXMuc291cmNlLnNwYW5Gb3IoZGVjb3JhdG9yLmxvYylcbiAgICApO1xuICB9XG5cbiAgRGVjb3JhdG9yQmxvY2soZGVjb3JhdG9yQmxvY2s6IEhCUy5EZWNvcmF0b3JCbG9jayk6IG5ldmVyIHtcbiAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgZGVjb3JhdG9yIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZGAsXG4gICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKGRlY29yYXRvckJsb2NrLmxvYylcbiAgICApO1xuICB9XG5cbiAgU3ViRXhwcmVzc2lvbihzZXhwcjogSEJTLlN1YkV4cHJlc3Npb24pOiBBU1R2MS5TdWJFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCBzZXhwcik7XG4gICAgcmV0dXJuIGIuc2V4cHIoeyBwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYzogdGhpcy5zb3VyY2Uuc3BhbkZvcihzZXhwci5sb2MpIH0pO1xuICB9XG5cbiAgUGF0aEV4cHJlc3Npb24ocGF0aDogSEJTLlBhdGhFeHByZXNzaW9uKTogQVNUdjEuUGF0aEV4cHJlc3Npb24ge1xuICAgIGxldCB7IG9yaWdpbmFsIH0gPSBwYXRoO1xuICAgIGxldCBwYXJ0czogc3RyaW5nW107XG5cbiAgICBpZiAob3JpZ2luYWwuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDIpID09PSAnLi8nKSB7XG4gICAgICAgIHRocm93IGdlbmVyYXRlU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVzaW5nIFwiLi9cIiBpcyBub3Qgc3VwcG9ydGVkIGluIEdsaW1tZXIgYW5kIHVubmVjZXNzYXJ5YCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDMpID09PSAnLi4vJykge1xuICAgICAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKFxuICAgICAgICAgIGBDaGFuZ2luZyBjb250ZXh0IHVzaW5nIFwiLi4vXCIgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyYCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgTWl4aW5nICcuJyBhbmQgJy8nIGluIHBhdGhzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lcjsgdXNlIG9ubHkgJy4nIHRvIHNlcGFyYXRlIHByb3BlcnR5IHBhdGhzYCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcGFydHMgPSBbcGF0aC5wYXJ0cy5qb2luKCcvJyldO1xuICAgIH0gZWxzZSBpZiAob3JpZ2luYWwgPT09ICcuJykge1xuICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgYCcuJyBpcyBub3QgYSBzdXBwb3J0ZWQgcGF0aCBpbiBHbGltbWVyOyBjaGVjayBmb3IgYSBwYXRoIHdpdGggYSB0cmFpbGluZyAnLidgLFxuICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHMgPSBwYXRoLnBhcnRzO1xuICAgIH1cblxuICAgIGxldCB0aGlzSGVhZCA9IGZhbHNlO1xuXG4gICAgLy8gVGhpcyBpcyB0byBmaXggYSBidWcgaW4gdGhlIEhhbmRsZWJhcnMgQVNUIHdoZXJlIHRoZSBwYXRoIGV4cHJlc3Npb25zIGluXG4gICAgLy8gYHt7dGhpcy5mb299fWAgKGFuZCBzaW1pbGFybHkgYHt7Zm9vLWJhciB0aGlzLmZvbyBuYW1lZD10aGlzLmZvb319YCBldGMpXG4gICAgLy8gYXJlIHNpbXBseSB0dXJuZWQgaW50byBge3tmb299fWAuIFRoZSBmaXggaXMgdG8gcHVzaCBpdCBiYWNrIG9udG8gdGhlXG4gICAgLy8gcGFydHMgYXJyYXkgYW5kIGxldCB0aGUgcnVudGltZSBzZWUgdGhlIGRpZmZlcmVuY2UuIEhvd2V2ZXIsIHdlIGNhbm5vdFxuICAgIC8vIHNpbXBseSB1c2UgdGhlIHN0cmluZyBgdGhpc2AgYXMgaXQgbWVhbnMgbGl0ZXJhbGx5IHRoZSBwcm9wZXJ0eSBjYWxsZWRcbiAgICAvLyBcInRoaXNcIiBpbiB0aGUgY3VycmVudCBjb250ZXh0IChpdCBjYW4gYmUgZXhwcmVzc2VkIGluIHRoZSBzeW50YXggYXNcbiAgICAvLyBge3tbdGhpc119fWAsIHdoZXJlIHRoZSBzcXVhcmUgYnJhY2tldCBhcmUgZ2VuZXJhbGx5IGZvciB0aGlzIGtpbmQgb2ZcbiAgICAvLyBlc2NhcGluZyDigJMgc3VjaCBhcyBge3tmb28uW1wiYmFyLmJhelwiXX19YCB3b3VsZCBtZWFuIGxvb2t1cCBhIHByb3BlcnR5XG4gICAgLy8gbmFtZWQgbGl0ZXJhbGx5IFwiYmFyLmJhelwiIG9uIGB0aGlzLmZvb2ApLiBCeSBjb252ZW50aW9uLCB3ZSB1c2UgYG51bGxgXG4gICAgLy8gZm9yIHRoaXMgcHVycG9zZS5cbiAgICBpZiAob3JpZ2luYWwubWF0Y2goL150aGlzKFxcLi4rKT8kLykpIHtcbiAgICAgIHRoaXNIZWFkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsZXQgcGF0aEhlYWQ6IEFTVHYxLlBhdGhIZWFkO1xuICAgIGlmICh0aGlzSGVhZCkge1xuICAgICAgcGF0aEhlYWQgPSB7XG4gICAgICAgIHR5cGU6ICdUaGlzSGVhZCcsXG4gICAgICAgIGxvYzoge1xuICAgICAgICAgIHN0YXJ0OiBwYXRoLmxvYy5zdGFydCxcbiAgICAgICAgICBlbmQ6IHsgbGluZTogcGF0aC5sb2Muc3RhcnQubGluZSwgY29sdW1uOiBwYXRoLmxvYy5zdGFydC5jb2x1bW4gKyA0IH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGF0aC5kYXRhKSB7XG4gICAgICBsZXQgaGVhZCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChoZWFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHBhcnNlIGEgcGF0aCBleHByZXNzaW9uLCBidXQgaXQgd2FzIG5vdCB2YWxpZC4gUGF0aHMgYmVnaW5uaW5nIHdpdGggQCBtdXN0IHN0YXJ0IHdpdGggYS16LmAsXG4gICAgICAgICAgdGhpcy5zb3VyY2Uuc3BhbkZvcihwYXRoLmxvYylcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcGF0aEhlYWQgPSB7XG4gICAgICAgIHR5cGU6ICdBdEhlYWQnLFxuICAgICAgICBuYW1lOiBgQCR7aGVhZH1gLFxuICAgICAgICBsb2M6IHtcbiAgICAgICAgICBzdGFydDogcGF0aC5sb2Muc3RhcnQsXG4gICAgICAgICAgZW5kOiB7IGxpbmU6IHBhdGgubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aC5sb2Muc3RhcnQuY29sdW1uICsgaGVhZC5sZW5ndGggKyAxIH0sXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaGVhZCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChoZWFkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgZ2VuZXJhdGVTeW50YXhFcnJvcihcbiAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHBhcnNlIGEgcGF0aCBleHByZXNzaW9uLCBidXQgaXQgd2FzIG5vdCB2YWxpZC4gUGF0aHMgbXVzdCBzdGFydCB3aXRoIGEteiBvciBBLVouYCxcbiAgICAgICAgICB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhdGgubG9jKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBwYXRoSGVhZCA9IHtcbiAgICAgICAgdHlwZTogJ1ZhckhlYWQnLFxuICAgICAgICBuYW1lOiBoZWFkLFxuICAgICAgICBsb2M6IHtcbiAgICAgICAgICBzdGFydDogcGF0aC5sb2Muc3RhcnQsXG4gICAgICAgICAgZW5kOiB7IGxpbmU6IHBhdGgubG9jLnN0YXJ0LmxpbmUsIGNvbHVtbjogcGF0aC5sb2Muc3RhcnQuY29sdW1uICsgaGVhZC5sZW5ndGggfSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQYXRoRXhwcmVzc2lvbkltcGxWMShwYXRoLm9yaWdpbmFsLCBwYXRoSGVhZCwgcGFydHMsIHRoaXMuc291cmNlLnNwYW5Gb3IocGF0aC5sb2MpKTtcbiAgfVxuXG4gIEhhc2goaGFzaDogSEJTLkhhc2gpOiBBU1R2MS5IYXNoIHtcbiAgICBsZXQgcGFpcnM6IEFTVHYxLkhhc2hQYWlyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaC5wYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhaXIgPSBoYXNoLnBhaXJzW2ldO1xuICAgICAgcGFpcnMucHVzaChcbiAgICAgICAgYi5wYWlyKHtcbiAgICAgICAgICBrZXk6IHBhaXIua2V5LFxuICAgICAgICAgIHZhbHVlOiB0aGlzLmFjY2VwdE5vZGUocGFpci52YWx1ZSksXG4gICAgICAgICAgbG9jOiB0aGlzLnNvdXJjZS5zcGFuRm9yKHBhaXIubG9jKSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGIuaGFzaChwYWlycywgdGhpcy5zb3VyY2Uuc3BhbkZvcihoYXNoLmxvYykpO1xuICB9XG5cbiAgU3RyaW5nTGl0ZXJhbChzdHJpbmc6IEhCUy5TdHJpbmdMaXRlcmFsKTogQVNUdjEuU3RyaW5nTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCh7IHR5cGU6ICdTdHJpbmdMaXRlcmFsJywgdmFsdWU6IHN0cmluZy52YWx1ZSwgbG9jOiBzdHJpbmcubG9jIH0pO1xuICB9XG5cbiAgQm9vbGVhbkxpdGVyYWwoYm9vbGVhbjogSEJTLkJvb2xlYW5MaXRlcmFsKTogQVNUdjEuQm9vbGVhbkxpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoeyB0eXBlOiAnQm9vbGVhbkxpdGVyYWwnLCB2YWx1ZTogYm9vbGVhbi52YWx1ZSwgbG9jOiBib29sZWFuLmxvYyB9KTtcbiAgfVxuXG4gIE51bWJlckxpdGVyYWwobnVtYmVyOiBIQlMuTnVtYmVyTGl0ZXJhbCk6IEFTVHYxLk51bWJlckxpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoeyB0eXBlOiAnTnVtYmVyTGl0ZXJhbCcsIHZhbHVlOiBudW1iZXIudmFsdWUsIGxvYzogbnVtYmVyLmxvYyB9KTtcbiAgfVxuXG4gIFVuZGVmaW5lZExpdGVyYWwodW5kZWY6IEhCUy5VbmRlZmluZWRMaXRlcmFsKTogQVNUdjEuVW5kZWZpbmVkTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCh7IHR5cGU6ICdVbmRlZmluZWRMaXRlcmFsJywgdmFsdWU6IHVuZGVmaW5lZCwgbG9jOiB1bmRlZi5sb2MgfSk7XG4gIH1cblxuICBOdWxsTGl0ZXJhbChudWw6IEhCUy5OdWxsTGl0ZXJhbCk6IEFTVHYxLk51bGxMaXRlcmFsIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKHsgdHlwZTogJ051bGxMaXRlcmFsJywgdmFsdWU6IG51bGwsIGxvYzogbnVsLmxvYyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSaWdodFN0cmlwcGVkT2Zmc2V0cyhvcmlnaW5hbDogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAvLyBpZiBpdCBpcyBlbXB0eSwganVzdCByZXR1cm4gdGhlIGNvdW50IG9mIG5ld2xpbmVzXG4gICAgLy8gaW4gb3JpZ2luYWxcbiAgICByZXR1cm4ge1xuICAgICAgbGluZXM6IG9yaWdpbmFsLnNwbGl0KCdcXG4nKS5sZW5ndGggLSAxLFxuICAgICAgY29sdW1uczogMCxcbiAgICB9O1xuICB9XG5cbiAgLy8gb3RoZXJ3aXNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBuZXdsaW5lcyBwcmlvciB0b1xuICAvLyBgdmFsdWVgXG4gIGxldCBkaWZmZXJlbmNlID0gb3JpZ2luYWwuc3BsaXQodmFsdWUpWzBdO1xuICBsZXQgbGluZXMgPSBkaWZmZXJlbmNlLnNwbGl0KC9cXG4vKTtcbiAgbGV0IGxpbmVDb3VudCA9IGxpbmVzLmxlbmd0aCAtIDE7XG5cbiAgcmV0dXJuIHtcbiAgICBsaW5lczogbGluZUNvdW50LFxuICAgIGNvbHVtbnM6IGxpbmVzW2xpbmVDb3VudF0ubGVuZ3RoLFxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUb2tlbml6ZXJMb2NhdGlvbih0b2tlbml6ZXI6IFBhcnNlclsndG9rZW5pemVyJ10sIGNvbnRlbnQ6IEhCUy5Db250ZW50U3RhdGVtZW50KSB7XG4gIGxldCBsaW5lID0gY29udGVudC5sb2Muc3RhcnQubGluZTtcbiAgbGV0IGNvbHVtbiA9IGNvbnRlbnQubG9jLnN0YXJ0LmNvbHVtbjtcblxuICBsZXQgb2Zmc2V0cyA9IGNhbGN1bGF0ZVJpZ2h0U3RyaXBwZWRPZmZzZXRzKFxuICAgIGNvbnRlbnQub3JpZ2luYWwgYXMgUmVjYXN0PEhCUy5TdHJpcEZsYWdzLCBzdHJpbmc+LFxuICAgIGNvbnRlbnQudmFsdWVcbiAgKTtcblxuICBsaW5lID0gbGluZSArIG9mZnNldHMubGluZXM7XG4gIGlmIChvZmZzZXRzLmxpbmVzKSB7XG4gICAgY29sdW1uID0gb2Zmc2V0cy5jb2x1bW5zO1xuICB9IGVsc2Uge1xuICAgIGNvbHVtbiA9IGNvbHVtbiArIG9mZnNldHMuY29sdW1ucztcbiAgfVxuXG4gIHRva2VuaXplci5saW5lID0gbGluZTtcbiAgdG9rZW5pemVyLmNvbHVtbiA9IGNvbHVtbjtcbn1cblxuZnVuY3Rpb24gYWNjZXB0Q2FsbE5vZGVzKFxuICBjb21waWxlcjogSGFuZGxlYmFyc05vZGVWaXNpdG9ycyxcbiAgbm9kZToge1xuICAgIHBhdGg6IEhCUy5QYXRoRXhwcmVzc2lvbjtcbiAgICBwYXJhbXM6IEhCUy5FeHByZXNzaW9uW107XG4gICAgaGFzaDogSEJTLkhhc2g7XG4gIH1cbik6IHsgcGF0aDogQVNUdjEuUGF0aEV4cHJlc3Npb247IHBhcmFtczogQVNUdjEuRXhwcmVzc2lvbltdOyBoYXNoOiBBU1R2MS5IYXNoIH0ge1xuICBsZXQgcGF0aCA9IGNvbXBpbGVyLlBhdGhFeHByZXNzaW9uKG5vZGUucGF0aCk7XG4gIGxldCBwYXJhbXMgPSBub2RlLnBhcmFtcyA/IG5vZGUucGFyYW1zLm1hcCgoZSkgPT4gY29tcGlsZXIuYWNjZXB0Tm9kZTxBU1R2MS5FeHByZXNzaW9uPihlKSkgOiBbXTtcblxuICAvLyBpZiB0aGVyZSBpcyBubyBoYXNoLCBwb3NpdGlvbiBpdCBhcyBhIGNvbGxhcHNlZCBub2RlIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBsYXN0IHBhcmFtIChvciB0aGVcbiAgLy8gcGF0aCwgaWYgdGhlcmUgYXJlIGFsc28gbm8gcGFyYW1zKVxuICBsZXQgZW5kID0gcGFyYW1zLmxlbmd0aCA+IDAgPyBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdLmxvYyA6IHBhdGgubG9jO1xuXG4gIGxldCBoYXNoID0gbm9kZS5oYXNoXG4gICAgPyBjb21waWxlci5IYXNoKG5vZGUuaGFzaClcbiAgICA6ICh7XG4gICAgICAgIHR5cGU6ICdIYXNoJyxcbiAgICAgICAgcGFpcnM6IFtdIGFzIEFTVHYxLkhhc2hQYWlyW10sXG4gICAgICAgIGxvYzogY29tcGlsZXIuc291cmNlLnNwYW5Gb3IoZW5kKS5jb2xsYXBzZSgnZW5kJyksXG4gICAgICB9IGFzIGNvbnN0KTtcblxuICByZXR1cm4geyBwYXRoLCBwYXJhbXMsIGhhc2ggfTtcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudE1vZGlmaWVyKFxuICBlbGVtZW50OiBQYXJzZXJOb2RlQnVpbGRlcjxUYWc8J1N0YXJ0VGFnJz4+LFxuICBtdXN0YWNoZTogQVNUdjEuTXVzdGFjaGVTdGF0ZW1lbnRcbikge1xuICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyB9ID0gbXVzdGFjaGU7XG5cbiAgaWYgKGlzSEJTTGl0ZXJhbChwYXRoKSkge1xuICAgIGxldCBtb2RpZmllciA9IGB7eyR7cHJpbnRMaXRlcmFsKHBhdGgpfX19YDtcbiAgICBsZXQgdGFnID0gYDwke2VsZW1lbnQubmFtZX0gLi4uICR7bW9kaWZpZXJ9IC4uLmA7XG5cbiAgICB0aHJvdyBnZW5lcmF0ZVN5bnRheEVycm9yKGBJbiAke3RhZ30sICR7bW9kaWZpZXJ9IGlzIG5vdCBhIHZhbGlkIG1vZGlmaWVyYCwgbXVzdGFjaGUubG9jKTtcbiAgfVxuXG4gIGxldCBtb2RpZmllciA9IGIuZWxlbWVudE1vZGlmaWVyKHsgcGF0aCwgcGFyYW1zLCBoYXNoLCBsb2MgfSk7XG4gIGVsZW1lbnQubW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==