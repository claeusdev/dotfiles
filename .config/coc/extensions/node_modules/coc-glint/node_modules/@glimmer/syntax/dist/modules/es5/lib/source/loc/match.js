function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var __classPrivateFieldSet = this && this.__classPrivateFieldSet || function (receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  privateMap.set(receiver, value);
  return value;
};

var __classPrivateFieldGet = this && this.__classPrivateFieldGet || function (receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return privateMap.get(receiver);
};

var _whens, _map, _whens_1;

import { assert, isPresent } from '@glimmer/util';
/**
 * This file implements the DSL used by span and offset in places where they need to exhaustively
 * consider all combinations of states (Handlebars offsets, character offsets and invisible/broken
 * offsets).
 *
 * It's probably overkill, but it makes the code that uses it clear. It could be refactored or
 * removed.
 */

export var MatchAny = 'MATCH_ANY';
export var IsInvisible = 'IS_INVISIBLE';

var WhenList = /*#__PURE__*/function () {
  function WhenList(whens) {
    _whens.set(this, void 0);

    __classPrivateFieldSet(this, _whens, whens);
  }

  var _proto = WhenList.prototype;

  _proto.first = function first(kind) {
    for (var _iterator = _createForOfIteratorHelperLoose(__classPrivateFieldGet(this, _whens)), _step; !(_step = _iterator()).done;) {
      var when = _step.value;
      var value = when.match(kind);

      if (isPresent(value)) {
        return value[0];
      }
    }

    return null;
  };

  return WhenList;
}();

_whens = new WeakMap();

var When = /*#__PURE__*/function () {
  function When() {
    _map.set(this, new Map());
  }

  var _proto2 = When.prototype;

  _proto2.get = function get(pattern, or) {
    var value = __classPrivateFieldGet(this, _map).get(pattern);

    if (value) {
      return value;
    }

    value = or();

    __classPrivateFieldGet(this, _map).set(pattern, value);

    return value;
  };

  _proto2.add = function add(pattern, out) {
    __classPrivateFieldGet(this, _map).set(pattern, out);
  };

  _proto2.match = function match(kind) {
    var pattern = patternFor(kind);
    var out = [];

    var exact = __classPrivateFieldGet(this, _map).get(pattern);

    var fallback = __classPrivateFieldGet(this, _map).get(MatchAny);

    if (exact) {
      out.push(exact);
    }

    if (fallback) {
      out.push(fallback);
    }

    return out;
  };

  return When;
}();

_map = new WeakMap();
export function match(callback) {
  return callback(new Matcher()).check();
}

var Matcher = /*#__PURE__*/function () {
  function Matcher() {
    _whens_1.set(this, new When());
  }
  /**
   * You didn't exhaustively match all possibilities.
   */


  var _proto3 = Matcher.prototype;

  _proto3.check = function check() {
    var _this = this;

    return function (left, right) {
      return _this.matchFor(left.kind, right.kind)(left, right);
    };
  };

  _proto3.matchFor = function matchFor(left, right) {
    var nesteds = __classPrivateFieldGet(this, _whens_1).match(left);

    false && assert(isPresent(nesteds), "no match defined for (" + left + ", " + right + ") and no AnyMatch defined either");
    var callback = new WhenList(nesteds).first(right);
    false && assert(callback !== null, "no match defined for (" + left + ", " + right + ") and no AnyMatch defined either");
    return callback;
  };

  _proto3.when = function when(left, right, // eslint-disable-next-line @typescript-eslint/no-explicit-any
  callback) {
    __classPrivateFieldGet(this, _whens_1).get(left, function () {
      return new When();
    }).add(right, callback);

    return this;
  };

  return Matcher;
}();

_whens_1 = new WeakMap();

function patternFor(kind) {
  switch (kind) {
    case "Broken"
    /* Broken */
    :
    case "InternalsSynthetic"
    /* InternalsSynthetic */
    :
    case "NonExistent"
    /* NonExistent */
    :
      return IsInvisible;

    default:
      return kind;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvc291cmNlL2xvYy9tYXRjaC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsU0FBQSxNQUFBLEVBQUEsU0FBQSxRQUFBLGVBQUE7QUFJQTs7Ozs7Ozs7O0FBU0EsT0FBTyxJQUFNLFFBQVEsR0FBZCxXQUFBO0FBV1AsT0FBTyxJQUFNLFdBQVcsR0FBakIsY0FBQTs7SUFLUCxRO0FBR0Usb0JBQUEsS0FBQSxFQUE4QjtBQUY5QixJQUFBLE1BQUEsQ0FBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEtBQUEsQ0FBQTs7QUFHRSxJQUFBLHNCQUFBLENBQUEsSUFBQSxFQUFBLE1BQUEsRUFBQSxLQUFBLENBQUE7QUFDRDs7OztTQUVELEssR0FBQSxlQUFLLElBQUwsRUFBc0I7QUFDcEIseURBQWEsc0JBQUEsQ0FBQSxJQUFBLEVBQWIsTUFBYSxDQUFiLHdDQUE4QjtBQUFBLFVBQTlCLElBQThCO0FBQzVCLFVBQUksS0FBSyxHQUFHLElBQUksQ0FBSixLQUFBLENBQVosSUFBWSxDQUFaOztBQUNBLFVBQUksU0FBUyxDQUFiLEtBQWEsQ0FBYixFQUFzQjtBQUNwQixlQUFPLEtBQUssQ0FBWixDQUFZLENBQVo7QUFDRDtBQUNGOztBQUVELFdBQUEsSUFBQTtBQUNELEc7Ozs7Ozs7SUFHSCxJO0FBQUEsa0JBQUE7QUFDRSxJQUFBLElBQUEsQ0FBQSxHQUFBLENBQUEsSUFBQSxFQUEwQixJQUExQixHQUEwQixFQUExQjtBQXNDRDs7OztVQXBDQyxHLEdBQUEsYUFBRyxPQUFILEVBQUcsRUFBSCxFQUFtQztBQUNqQyxRQUFJLEtBQUssR0FBRyxzQkFBQSxDQUFBLElBQUEsRUFBQSxJQUFBLENBQUEsQ0FBQSxHQUFBLENBQVosT0FBWSxDQUFaOztBQUVBLFFBQUEsS0FBQSxFQUFXO0FBQ1QsYUFBQSxLQUFBO0FBQ0Q7O0FBRUQsSUFBQSxLQUFLLEdBQUcsRUFBUixFQUFBOztBQUVBLElBQUEsc0JBQUEsQ0FBQSxJQUFBLEVBQUEsSUFBQSxDQUFBLENBQUEsR0FBQSxDQUFBLE9BQUEsRUFBQSxLQUFBOztBQUVBLFdBQUEsS0FBQTtBQUNELEc7O1VBRUQsRyxHQUFBLGFBQUcsT0FBSCxFQUFHLEdBQUgsRUFBOEI7QUFDNUIsSUFBQSxzQkFBQSxDQUFBLElBQUEsRUFBQSxJQUFBLENBQUEsQ0FBQSxHQUFBLENBQUEsT0FBQSxFQUFBLEdBQUE7QUFDRCxHOztVQUVELEssR0FBQSxlQUFLLElBQUwsRUFBc0I7QUFDcEIsUUFBSSxPQUFPLEdBQUcsVUFBVSxDQUF4QixJQUF3QixDQUF4QjtBQUVBLFFBQUksR0FBRyxHQUFQLEVBQUE7O0FBRUEsUUFBSSxLQUFLLEdBQUcsc0JBQUEsQ0FBQSxJQUFBLEVBQUEsSUFBQSxDQUFBLENBQUEsR0FBQSxDQUFaLE9BQVksQ0FBWjs7QUFDQSxRQUFJLFFBQVEsR0FBRyxzQkFBQSxDQUFBLElBQUEsRUFBQSxJQUFBLENBQUEsQ0FBQSxHQUFBLENBQWYsUUFBZSxDQUFmOztBQUVBLFFBQUEsS0FBQSxFQUFXO0FBQ1QsTUFBQSxHQUFHLENBQUgsSUFBQSxDQUFBLEtBQUE7QUFDRDs7QUFFRCxRQUFBLFFBQUEsRUFBYztBQUNaLE1BQUEsR0FBRyxDQUFILElBQUEsQ0FBQSxRQUFBO0FBQ0Q7O0FBRUQsV0FBQSxHQUFBO0FBQ0QsRzs7Ozs7O0FBZ0JILE9BQU0sU0FBQSxLQUFBLENBQUEsUUFBQSxFQUEwRTtBQUM5RSxTQUFPLFFBQVEsQ0FBQyxJQUFULE9BQVMsRUFBRCxDQUFSLENBQVAsS0FBTyxFQUFQO0FBQ0Q7O0lBRUQsTztBQUFBLHFCQUFBO0FBQ0UsSUFBQSxRQUFBLENBQUEsR0FBQSxDQUFBLElBQUEsRUFBdUUsSUFBdkUsSUFBdUUsRUFBdkU7QUE4RUQ7QUE1RUM7Ozs7Ozs7VUFHVSxLLEdBQUEsaUJBQUs7QUFBQTs7QUFDYixXQUFPLFVBQUEsSUFBQSxFQUFBLEtBQUE7QUFBQSxhQUFpQixLQUFBLENBQUEsUUFBQSxDQUFjLElBQUksQ0FBbEIsSUFBQSxFQUF5QixLQUFLLENBQTlCLElBQUEsRUFBQSxJQUFBLEVBQXhCLEtBQXdCLENBQWpCO0FBQUEsS0FBUDtBQUNELEc7O1VBRU8sUSxHQUFBLGtCQUFRLElBQVIsRUFBUSxLQUFSLEVBRVc7QUFFakIsUUFBSSxPQUFPLEdBQUcsc0JBQUEsQ0FBQSxJQUFBLEVBQUEsUUFBQSxDQUFBLENBQUEsS0FBQSxDQUFkLElBQWMsQ0FBZDs7QUFGaUIsYUFJakIsTUFBTSxDQUNKLFNBQVMsQ0FETCxPQUNLLENBREwsNkJBRXFCLElBRnJCLFVBSlcsS0FJWCxzQ0FKVztBQVNqQixRQUFJLFFBQVEsR0FBRyxJQUFBLFFBQUEsQ0FBQSxPQUFBLEVBQUEsS0FBQSxDQUFmLEtBQWUsQ0FBZjtBQVRpQixhQVdqQixNQUFNLENBQ0osUUFBUSxLQURKLElBQUEsNkJBRXFCLElBRnJCLFVBWFcsS0FXWCxzQ0FYVztBQWdCakIsV0FBQSxRQUFBO0FBQ0QsRzs7VUF3Q0QsSSxHQUFBLGNBQUksSUFBSixFQUFJLEtBQUosRUFHRTtBQUhFLEVBQUEsUUFBSixFQUkwQztBQUV4QyxJQUFBLHNCQUFBLENBQUEsSUFBQSxFQUFBLFFBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQXNCO0FBQUEsYUFBTSxJQUE1QixJQUE0QixFQUFOO0FBQUEsS0FBdEIsRUFBQSxHQUFBLENBQUEsS0FBQSxFQUFBLFFBQUE7O0FBRUEsV0FBQSxJQUFBO0FBQ0QsRzs7Ozs7OztBQUdILFNBQUEsVUFBQSxDQUFBLElBQUEsRUFBb0M7QUFDbEMsVUFBQSxJQUFBO0FBQ0UsU0FBQTtBQUFBO0FBQUE7QUFDQSxTQUFBO0FBQUE7QUFBQTtBQUNBLFNBQUE7QUFBQTtBQUFBO0FBQ0UsYUFBQSxXQUFBOztBQUNGO0FBQ0UsYUFBQSxJQUFBO0FBTko7QUFRRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFzc2VydCwgaXNQcmVzZW50IH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5cbmltcG9ydCB7IENoYXJQb3NpdGlvbiwgSGJzUG9zaXRpb24sIEludmlzaWJsZVBvc2l0aW9uLCBPZmZzZXRLaW5kLCBQb3NpdGlvbkRhdGEgfSBmcm9tICcuL29mZnNldCc7XG5cbi8qKlxuICogVGhpcyBmaWxlIGltcGxlbWVudHMgdGhlIERTTCB1c2VkIGJ5IHNwYW4gYW5kIG9mZnNldCBpbiBwbGFjZXMgd2hlcmUgdGhleSBuZWVkIHRvIGV4aGF1c3RpdmVseVxuICogY29uc2lkZXIgYWxsIGNvbWJpbmF0aW9ucyBvZiBzdGF0ZXMgKEhhbmRsZWJhcnMgb2Zmc2V0cywgY2hhcmFjdGVyIG9mZnNldHMgYW5kIGludmlzaWJsZS9icm9rZW5cbiAqIG9mZnNldHMpLlxuICpcbiAqIEl0J3MgcHJvYmFibHkgb3ZlcmtpbGwsIGJ1dCBpdCBtYWtlcyB0aGUgY29kZSB0aGF0IHVzZXMgaXQgY2xlYXIuIEl0IGNvdWxkIGJlIHJlZmFjdG9yZWQgb3JcbiAqIHJlbW92ZWQuXG4gKi9cblxuZXhwb3J0IGNvbnN0IE1hdGNoQW55ID0gJ01BVENIX0FOWSc7XG5leHBvcnQgdHlwZSBNYXRjaEFueSA9ICdNQVRDSF9BTlknO1xuXG50eXBlIE1hdGNoZXMgPVxuICB8ICdDaGFyLEhicydcbiAgfCAnSGJzLENoYXInXG4gIHwgJ0hicyxIYnMnXG4gIHwgJ0NoYXIsQ2hhcidcbiAgfCAnSW52aXNpYmxlLEFueSdcbiAgfCAnQW55LEludmlzaWJsZSc7XG5cbmV4cG9ydCBjb25zdCBJc0ludmlzaWJsZSA9ICdJU19JTlZJU0lCTEUnO1xuZXhwb3J0IHR5cGUgSXNJbnZpc2libGUgPSAnSVNfSU5WSVNJQkxFJztcblxudHlwZSBQYXR0ZXJuID0gT2Zmc2V0S2luZCB8IElzSW52aXNpYmxlIHwgTWF0Y2hBbnk7XG5cbmNsYXNzIFdoZW5MaXN0PE91dD4ge1xuICAjd2hlbnM6IFdoZW48T3V0PltdO1xuXG4gIGNvbnN0cnVjdG9yKHdoZW5zOiBXaGVuPE91dD5bXSkge1xuICAgIHRoaXMuI3doZW5zID0gd2hlbnM7XG4gIH1cblxuICBmaXJzdChraW5kOiBPZmZzZXRLaW5kKTogT3V0IHwgbnVsbCB7XG4gICAgZm9yIChsZXQgd2hlbiBvZiB0aGlzLiN3aGVucykge1xuICAgICAgbGV0IHZhbHVlID0gd2hlbi5tYXRjaChraW5kKTtcbiAgICAgIGlmIChpc1ByZXNlbnQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVswXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jbGFzcyBXaGVuPE91dD4ge1xuICAjbWFwOiBNYXA8UGF0dGVybiwgT3V0PiA9IG5ldyBNYXAoKTtcblxuICBnZXQocGF0dGVybjogUGF0dGVybiwgb3I6ICgpID0+IE91dCk6IE91dCB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy4jbWFwLmdldChwYXR0ZXJuKTtcblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhbHVlID0gb3IoKTtcblxuICAgIHRoaXMuI21hcC5zZXQocGF0dGVybiwgdmFsdWUpO1xuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgYWRkKHBhdHRlcm46IFBhdHRlcm4sIG91dDogT3V0KTogdm9pZCB7XG4gICAgdGhpcy4jbWFwLnNldChwYXR0ZXJuLCBvdXQpO1xuICB9XG5cbiAgbWF0Y2goa2luZDogT2Zmc2V0S2luZCk6IE91dFtdIHtcbiAgICBsZXQgcGF0dGVybiA9IHBhdHRlcm5Gb3Ioa2luZCk7XG5cbiAgICBsZXQgb3V0OiBPdXRbXSA9IFtdO1xuXG4gICAgbGV0IGV4YWN0ID0gdGhpcy4jbWFwLmdldChwYXR0ZXJuKTtcbiAgICBsZXQgZmFsbGJhY2sgPSB0aGlzLiNtYXAuZ2V0KE1hdGNoQW55KTtcblxuICAgIGlmIChleGFjdCkge1xuICAgICAgb3V0LnB1c2goZXhhY3QpO1xuICAgIH1cblxuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgb3V0LnB1c2goZmFsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn1cblxudHlwZSBFeGhhdXN0aXZlQ2hlY2s8T3V0LCBJbiBleHRlbmRzIE1hdGNoZXMsIFJlbW92ZWQgZXh0ZW5kcyBNYXRjaGVzPiA9IEV4Y2x1ZGU8XG4gIEluLFxuICBSZW1vdmVkXG4+IGV4dGVuZHMgbmV2ZXJcbiAgPyBFeGhhdXN0aXZlTWF0Y2hlcjxPdXQ+XG4gIDogTWF0Y2hlcjxPdXQsIEV4Y2x1ZGU8SW4sIFJlbW92ZWQ+PjtcblxuZXhwb3J0IHR5cGUgTWF0Y2hGbjxPdXQ+ID0gKGxlZnQ6IFBvc2l0aW9uRGF0YSwgcmlnaHQ6IFBvc2l0aW9uRGF0YSkgPT4gT3V0O1xuXG5pbnRlcmZhY2UgRXhoYXVzdGl2ZU1hdGNoZXI8T3V0PiB7XG4gIGNoZWNrKCk6IE1hdGNoRm48T3V0Pjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoPE91dD4oY2FsbGJhY2s6IChtOiBNYXRjaGVyPE91dD4pID0+IEV4aGF1c3RpdmVNYXRjaGVyPE91dD4pOiBNYXRjaEZuPE91dD4ge1xuICByZXR1cm4gY2FsbGJhY2sobmV3IE1hdGNoZXIoKSkuY2hlY2soKTtcbn1cblxuY2xhc3MgTWF0Y2hlcjxPdXQsIE0gZXh0ZW5kcyBNYXRjaGVzID0gTWF0Y2hlcz4ge1xuICAjd2hlbnM6IFdoZW48V2hlbjwobGVmdDogUG9zaXRpb25EYXRhLCByaWdodDogUG9zaXRpb25EYXRhKSA9PiBPdXQ+PiA9IG5ldyBXaGVuKCk7XG5cbiAgLyoqXG4gICAqIFlvdSBkaWRuJ3QgZXhoYXVzdGl2ZWx5IG1hdGNoIGFsbCBwb3NzaWJpbGl0aWVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGNoZWNrKCk6IE1hdGNoRm48T3V0PiB7XG4gICAgcmV0dXJuIChsZWZ0LCByaWdodCkgPT4gdGhpcy5tYXRjaEZvcihsZWZ0LmtpbmQsIHJpZ2h0LmtpbmQpKGxlZnQsIHJpZ2h0KTtcbiAgfVxuXG4gIHByaXZhdGUgbWF0Y2hGb3IoXG4gICAgbGVmdDogT2Zmc2V0S2luZCxcbiAgICByaWdodDogT2Zmc2V0S2luZFxuICApOiAobGVmdDogUG9zaXRpb25EYXRhLCByaWdodDogUG9zaXRpb25EYXRhKSA9PiBPdXQge1xuICAgIGxldCBuZXN0ZWRzID0gdGhpcy4jd2hlbnMubWF0Y2gobGVmdCk7XG5cbiAgICBhc3NlcnQoXG4gICAgICBpc1ByZXNlbnQobmVzdGVkcyksXG4gICAgICBgbm8gbWF0Y2ggZGVmaW5lZCBmb3IgKCR7bGVmdH0sICR7cmlnaHR9KSBhbmQgbm8gQW55TWF0Y2ggZGVmaW5lZCBlaXRoZXJgXG4gICAgKTtcblxuICAgIGxldCBjYWxsYmFjayA9IG5ldyBXaGVuTGlzdChuZXN0ZWRzKS5maXJzdChyaWdodCk7XG5cbiAgICBhc3NlcnQoXG4gICAgICBjYWxsYmFjayAhPT0gbnVsbCxcbiAgICAgIGBubyBtYXRjaCBkZWZpbmVkIGZvciAoJHtsZWZ0fSwgJHtyaWdodH0pIGFuZCBubyBBbnlNYXRjaCBkZWZpbmVkIGVpdGhlcmBcbiAgICApO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9XG5cbiAgLy8gVGhpcyBiaWcgYmxvY2sgaXMgdGhlIGJ1bGsgb2YgdGhlIGhlYXZ5IGxpZnRpbmcgaW4gdGhpcyBmaWxlLiBJdCBmYWNpbGl0YXRlcyBleGhhdXN0aXZlbmVzc1xuICAvLyBjaGVja2luZyBzbyB0aGF0IG1hdGNoZXJzIGNhbiBlbnN1cmUgdGhleSd2ZSBhY3R1YWxseSBjb3ZlcmVkIGFsbCB0aGUgY2FzZXMgKGFuZCBUeXBlU2NyaXB0XG4gIC8vIHdpbGwgdHJlYXQgaXQgYXMgYW4gZXhoYXVzdGl2ZSBtYXRjaCkuXG4gIHdoZW4oXG4gICAgbGVmdDogT2Zmc2V0S2luZC5DaGFyUG9zaXRpb24sXG4gICAgcmlnaHQ6IE9mZnNldEtpbmQuSGJzUG9zaXRpb24sXG4gICAgY2FsbGJhY2s6IChsZWZ0OiBDaGFyUG9zaXRpb24sIHJpZ2h0OiBIYnNQb3NpdGlvbikgPT4gT3V0XG4gICk6IEV4aGF1c3RpdmVDaGVjazxPdXQsIE0sICdDaGFyLEhicyc+O1xuICB3aGVuKFxuICAgIGxlZnQ6IE9mZnNldEtpbmQuSGJzUG9zaXRpb24sXG4gICAgcmlnaHQ6IE9mZnNldEtpbmQuQ2hhclBvc2l0aW9uLFxuICAgIGNhbGxiYWNrOiAobGVmdDogSGJzUG9zaXRpb24sIHJpZ2h0OiBDaGFyUG9zaXRpb24pID0+IE91dFxuICApOiBFeGhhdXN0aXZlQ2hlY2s8T3V0LCBNLCAnSGJzLENoYXInPjtcbiAgd2hlbihcbiAgICBsZWZ0OiBPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLFxuICAgIHJpZ2h0OiBPZmZzZXRLaW5kLkhic1Bvc2l0aW9uLFxuICAgIGNhbGxiYWNrOiAobGVmdDogSGJzUG9zaXRpb24sIHJpZ2h0OiBIYnNQb3NpdGlvbikgPT4gT3V0XG4gICk6IEV4aGF1c3RpdmVDaGVjazxPdXQsIE0sICdIYnMsSGJzJz47XG4gIHdoZW4oXG4gICAgbGVmdDogT2Zmc2V0S2luZC5DaGFyUG9zaXRpb24sXG4gICAgcmlnaHQ6IE9mZnNldEtpbmQuQ2hhclBvc2l0aW9uLFxuICAgIGNhbGxiYWNrOiAobGVmdDogQ2hhclBvc2l0aW9uLCByaWdodDogQ2hhclBvc2l0aW9uKSA9PiBPdXRcbiAgKTogRXhoYXVzdGl2ZUNoZWNrPE91dCwgTSwgJ0NoYXIsQ2hhcic+O1xuICB3aGVuKFxuICAgIGxlZnQ6IElzSW52aXNpYmxlLFxuICAgIHJpZ2h0OiBNYXRjaEFueSxcbiAgICBjYWxsYmFjazogKGxlZnQ6IEludmlzaWJsZVBvc2l0aW9uLCByaWdodDogUG9zaXRpb25EYXRhKSA9PiBPdXRcbiAgKTogTWF0Y2hlcjxPdXQsIEV4Y2x1ZGU8TSwgJ0ludmlzaWJsZSxBbnknPj47XG4gIHdoZW4oXG4gICAgbGVmdDogTWF0Y2hBbnksXG4gICAgcmlnaHQ6IElzSW52aXNpYmxlLFxuICAgIGNhbGxiYWNrOiAobGVmdDogUG9zaXRpb25EYXRhLCByaWdodDogSW52aXNpYmxlUG9zaXRpb24pID0+IE91dFxuICApOiBFeGhhdXN0aXZlQ2hlY2s8T3V0LCBNLCAnQW55LEludmlzaWJsZSc+O1xuICB3aGVuKFxuICAgIGxlZnQ6IE1hdGNoQW55LFxuICAgIHJpZ2h0OiBNYXRjaEFueSxcbiAgICBjYWxsYmFjazogKGxlZnQ6IFBvc2l0aW9uRGF0YSwgcmlnaHQ6IFBvc2l0aW9uRGF0YSkgPT4gT3V0XG4gICk6IEV4aGF1c3RpdmVNYXRjaGVyPE91dD47XG4gIHdoZW4oXG4gICAgbGVmdDogUGF0dGVybixcbiAgICByaWdodDogUGF0dGVybixcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNhbGxiYWNrOiAobGVmdDogYW55LCByaWdodDogYW55KSA9PiBPdXRcbiAgKTogTWF0Y2hlcjxPdXQsIE1hdGNoZXM+IHwgRXhoYXVzdGl2ZU1hdGNoZXI8T3V0PiB7XG4gICAgdGhpcy4jd2hlbnMuZ2V0KGxlZnQsICgpID0+IG5ldyBXaGVuKCkpLmFkZChyaWdodCwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGF0dGVybkZvcihraW5kOiBPZmZzZXRLaW5kKTogUGF0dGVybiB7XG4gIHN3aXRjaCAoa2luZCkge1xuICAgIGNhc2UgT2Zmc2V0S2luZC5Ccm9rZW46XG4gICAgY2FzZSBPZmZzZXRLaW5kLkludGVybmFsc1N5bnRoZXRpYzpcbiAgICBjYXNlIE9mZnNldEtpbmQuTm9uRXhpc3RlbnQ6XG4gICAgICByZXR1cm4gSXNJbnZpc2libGU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBraW5kO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9