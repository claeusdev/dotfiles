define('@glimmer/util', ['exports', '@glimmer/env'], function (exports, env) { 'use strict';

  var EMPTY_ARRAY = Object.freeze([]);
  function emptyArray() {
    return EMPTY_ARRAY;
  }
  var EMPTY_STRING_ARRAY = emptyArray();
  var EMPTY_NUMBER_ARRAY = emptyArray();
  /**
   * This function returns `true` if the input array is the special empty array sentinel,
   * which is sometimes used for optimizations.
   */

  function isEmptyArray(input) {
    return input === EMPTY_ARRAY;
  }

  // import Logger from './logger';

  function debugAssert(test, msg) {
    // if (!alreadyWarned) {
    //   alreadyWarned = true;
    //   Logger.warn("Don't leave debug assertions on in public builds");
    // }
    if (!test) {
      throw new Error(msg || 'assertion failure');
    }
  }
  function deprecate(desc) {
    LOCAL_LOGGER.warn("DEPRECATION: " + desc);
  }

  var GUID = 0;
  function initializeGuid(object) {
    return object._guid = ++GUID;
  }
  function ensureGuid(object) {
    return object._guid || initializeGuid(object);
  }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
  function dict() {
    return Object.create(null);
  }
  function isDict(u) {
    return u !== null && u !== undefined;
  }
  function isObject(u) {
    return typeof u === 'object' && u !== null;
  }
  var DictSet = /*#__PURE__*/function () {
    function DictSet() {
      this.dict = dict();
    }

    var _proto = DictSet.prototype;

    _proto.add = function add(obj) {
      if (typeof obj === 'string') this.dict[obj] = obj;else this.dict[ensureGuid(obj)] = obj;
      return this;
    };

    _proto["delete"] = function _delete(obj) {
      if (typeof obj === 'string') delete this.dict[obj];else if (obj._guid) delete this.dict[obj._guid];
    };

    return DictSet;
  }();
  var StackImpl = /*#__PURE__*/function () {
    function StackImpl(values) {
      if (values === void 0) {
        values = [];
      }

      this.current = null;
      this.stack = values;
    }

    var _proto2 = StackImpl.prototype;

    _proto2.push = function push(item) {
      this.current = item;
      this.stack.push(item);
    };

    _proto2.pop = function pop() {
      var item = this.stack.pop();
      var len = this.stack.length;
      this.current = len === 0 ? null : this.stack[len - 1];
      return item === undefined ? null : item;
    };

    _proto2.nth = function nth(from) {
      var len = this.stack.length;
      return len < from ? null : this.stack[len - from];
    };

    _proto2.isEmpty = function isEmpty() {
      return this.stack.length === 0;
    };

    _proto2.toArray = function toArray() {
      return this.stack;
    };

    _createClass(StackImpl, [{
      key: "size",
      get: function get() {
        return this.stack.length;
      }
    }]);

    return StackImpl;
  }();
  var NonemptyStackImpl = /*#__PURE__*/function () {
    function NonemptyStackImpl(values) {
      this.stack = values;
      this.current = values[values.length - 1];
    }

    var _proto3 = NonemptyStackImpl.prototype;

    _proto3.push = function push(item) {
      this.current = item;
      this.stack.push(item);
    };

    _proto3.pop = function pop() {
      if (this.stack.length === 1) {
        throw new Error("cannot pop the last element of a NonemptyStack");
      }

      var item = this.stack.pop();
      var len = this.stack.length;
      this.current = this.stack[len - 1];
      return item;
    };

    _proto3.nth = function nth(from) {
      var len = this.stack.length;
      return from >= len ? null : this.stack[from];
    };

    _proto3.nthBack = function nthBack(from) {
      var len = this.stack.length;
      return len < from ? null : this.stack[len - from];
    };

    _proto3.toArray = function toArray() {
      return this.stack;
    };

    _createClass(NonemptyStackImpl, [{
      key: "size",
      get: function get() {
        return this.stack.length;
      }
    }]);

    return NonemptyStackImpl;
  }();

  function clearElement(parent) {
    var current = parent.firstChild;

    while (current) {
      var next = current.nextSibling;
      parent.removeChild(current);
      current = next;
    }
  }

  var SERIALIZATION_FIRST_NODE_STRING = '%+b:0%';
  function isSerializationFirstNode(node) {
    return node.nodeValue === SERIALIZATION_FIRST_NODE_STRING;
  }

  var objKeys = Object.keys;
  function assign(obj) {
    for (var i = 1; i < arguments.length; i++) {
      var assignment = arguments[i];
      if (assignment === null || typeof assignment !== 'object') continue;
      var keys = objKeys(assignment);

      for (var j = 0; j < keys.length; j++) {
        var key = keys[j];
        obj[key] = assignment[key];
      }
    }

    return obj;
  }
  function fillNulls(count) {
    var arr = new Array(count);

    for (var i = 0; i < count; i++) {
      arr[i] = null;
    }

    return arr;
  }
  function values(obj) {
    var vals = [];

    for (var key in obj) {
      vals.push(obj[key]);
    }

    return vals;
  }

  /**
    Strongly hint runtimes to intern the provided string.

    When do I need to use this function?

    For the most part, never. Pre-mature optimization is bad, and often the
    runtime does exactly what you need it to, and more often the trade-off isn't
    worth it.

    Why?

    Runtimes store strings in at least 2 different representations:
    Ropes and Symbols (interned strings). The Rope provides a memory efficient
    data-structure for strings created from concatenation or some other string
    manipulation like splitting.

    Unfortunately checking equality of different ropes can be quite costly as
    runtimes must resort to clever string comparison algorithms. These
    algorithms typically cost in proportion to the length of the string.
    Luckily, this is where the Symbols (interned strings) shine. As Symbols are
    unique by their string content, equality checks can be done by pointer
    comparison.

    How do I know if my string is a rope or symbol?

    Typically (warning general sweeping statement, but truthy in runtimes at
    present) static strings created as part of the JS source are interned.
    Strings often used for comparisons can be interned at runtime if some
    criteria are met.  One of these criteria can be the size of the entire rope.
    For example, in chrome 38 a rope longer then 12 characters will not
    intern, nor will segments of that rope.

    Some numbers: http://jsperf.com/eval-vs-keys/8

    Known Trickâ„¢

    @private
    @return {String} interned version of the provided string
  */
  function intern(str) {
    var obj = {};
    obj[str] = 1;

    for (var key in obj) {
      if (key === str) {
        return key;
      }
    }

    return str;
  }

  var HAS_NATIVE_PROXY = typeof Proxy === 'function';
  var HAS_NATIVE_SYMBOL = function () {
    if (typeof Symbol !== 'function') {
      return false;
    } // eslint-disable-next-line symbol-description


    return typeof Symbol() === 'symbol';
  }();
  function keys(obj) {
    return Object.keys(obj);
  }
  function unwrap(val) {
    if (val === null || val === undefined) throw new Error("Expected value to be present");
    return val;
  }
  function expect(val, message) {
    if (val === null || val === undefined) throw new Error(message);
    return val;
  }
  function unreachable(message) {
    if (message === void 0) {
      message = 'unreachable';
    }

    return new Error(message);
  }
  function exhausted(value) {
    throw new Error("Exhausted " + value);
  }
  var tuple = function tuple() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return args;
  };
  function enumerableSymbol(key) {
    return intern("__" + key + Math.floor(Math.random() * Date.now()) + "__");
  }
  var symbol = HAS_NATIVE_SYMBOL ? Symbol : enumerableSymbol;

  function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function strip(strings) {
    var out = '';

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    for (var i = 0; i < strings.length; i++) {
      var string = strings[i];
      var dynamic = args[i] !== undefined ? String(args[i]) : '';
      out += "" + string + dynamic;
    }

    var lines = out.split('\n');

    while (lines.length && lines[0].match(/^\s*$/)) {
      lines.shift();
    }

    while (lines.length && lines[lines.length - 1].match(/^\s*$/)) {
      lines.pop();
    }

    var min = Infinity;

    for (var _iterator = _createForOfIteratorHelperLoose(lines), _step; !(_step = _iterator()).done;) {
      var line = _step.value;
      var leading = line.match(/^\s*/)[0].length;
      min = Math.min(min, leading);
    }

    var stripped = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(lines), _step2; !(_step2 = _iterator2()).done;) {
      var _line = _step2.value;
      stripped.push(_line.slice(min));
    }

    return stripped.join('\n');
  }

  function isHandle(value) {
    return value >= 0;
  }
  function isNonPrimitiveHandle(value) {
    return value > 3
    /* ENCODED_UNDEFINED_HANDLE */
    ;
  }
  function constants() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    return [false, true, null, undefined].concat(values);
  }
  function isSmallInt(value) {
    return value % 1 === 0 && value <= 536870911
    /* MAX_INT */
    && value >= -536870912
    /* MIN_INT */
    ;
  }
  function encodeNegative(num) {

    return num & -536870913
    /* SIGN_BIT */
    ;
  }
  function decodeNegative(num) {

    return num | ~-536870913
    /* SIGN_BIT */
    ;
  }
  function encodePositive(num) {

    return ~num;
  }
  function decodePositive(num) {

    return ~num;
  }
  function encodeHandle(num) {

    return num;
  }
  function decodeHandle(num) {

    return num;
  }
  function encodeImmediate(num) {
    num |= 0;
    return num < 0 ? encodeNegative(num) : encodePositive(num);
  }
  function decodeImmediate(num) {
    num |= 0;
    return num > -536870913
    /* SIGN_BIT */
    ? decodePositive(num) : decodeNegative(num);
  } // Warm
  [1, -1].forEach(function (x) {
    return decodeImmediate(encodeImmediate(x));
  });

  function unwrapHandle(handle) {
    if (typeof handle === 'number') {
      return handle;
    } else {
      var error = handle.errors[0];
      throw new Error("Compile Error: " + error.problem + " @ " + error.span.start + ".." + error.span.end);
    }
  }
  function unwrapTemplate(template) {
    if (template.result === 'error') {
      throw new Error("Compile Error: " + template.problem + " @ " + template.span.start + ".." + template.span.end);
    }

    return template;
  }
  function extractHandle(handle) {
    if (typeof handle === 'number') {
      return handle;
    } else {
      return handle.handle;
    }
  }
  function isOkHandle(handle) {
    return typeof handle === 'number';
  }
  function isErrHandle(handle) {
    return typeof handle === 'number';
  }

  var weakSet = typeof WeakSet === 'function' ? WeakSet : /*#__PURE__*/function () {
    function WeakSetPolyFill() {
      this._map = new WeakMap();
    }

    var _proto = WeakSetPolyFill.prototype;

    _proto.add = function add(val) {
      this._map.set(val, true);

      return this;
    };

    _proto["delete"] = function _delete(val) {
      return this._map["delete"](val);
    };

    _proto.has = function has(val) {
      return this._map.has(val);
    };

    return WeakSetPolyFill;
  }();

  function castToSimple(node) {
    if (isDocument(node)) {
      return node;
    } else if (isElement(node)) {
      return node;
    } else {
      return node;
    }
  }
  function castToBrowser(node, sugaryCheck) {
    if (node === null || node === undefined) {
      return null;
    }

    if (typeof document === undefined) {
      throw new Error('Attempted to cast to a browser node in a non-browser context');
    }

    if (isDocument(node)) {
      return node;
    }

    if (node.ownerDocument !== document) {
      throw new Error('Attempted to cast to a browser node with a node that was not created from this document');
    }

    return checkNode(node, sugaryCheck);
  }

  function checkError(from, check) {
    return new Error("cannot cast a " + from + " into " + check);
  }

  function isDocument(node) {
    return node.nodeType === 9
    /* DOCUMENT_NODE */
    ;
  }

  function isElement(node) {
    return node.nodeType === 1
    /* ELEMENT_NODE */
    ;
  }

  function checkNode(node, check) {
    var isMatch = false;

    if (node !== null) {
      if (typeof check === 'string') {
        isMatch = stringCheckNode(node, check);
      } else if (Array.isArray(check)) {
        isMatch = check.some(function (c) {
          return stringCheckNode(node, c);
        });
      } else {
        throw unreachable();
      }
    }

    if (isMatch) {
      return node;
    } else {
      throw checkError("SimpleElement(" + node + ")", check);
    }
  }

  function stringCheckNode(node, check) {
    switch (check) {
      case 'NODE':
        return true;

      case 'HTML':
        return node instanceof HTMLElement;

      case 'SVG':
        return node instanceof SVGElement;

      case 'ELEMENT':
        return node instanceof Element;

      default:
        if (check.toUpperCase() === check) {
          throw new Error("BUG: this code is missing handling for a generic node type");
        }

        return node instanceof Element && node.tagName.toLowerCase() === check;
    }
  }

  function _createForOfIteratorHelperLoose$1(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = o[Symbol.iterator](); return it.next.bind(it); }

  function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

  function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function isPresent(list) {
    return list.length > 0;
  }
  function ifPresent(list, ifPresent, otherwise) {
    if (isPresent(list)) {
      return ifPresent(list);
    } else {
      return otherwise();
    }
  }
  function toPresentOption(list) {
    if (isPresent(list)) {
      return list;
    } else {
      return null;
    }
  }
  function assertPresent(list, message) {
    if (message === void 0) {
      message = "unexpected empty list";
    }

    if (!isPresent(list)) {
      throw new Error(message);
    }
  }
  function mapPresent(list, callback) {
    if (list === null) {
      return null;
    }

    var out = [];

    for (var _iterator = _createForOfIteratorHelperLoose$1(list), _step; !(_step = _iterator()).done;) {
      var item = _step.value;
      out.push(callback(item));
    }

    return out;
  }

  var debugToString;

  if (env.DEBUG) {
    var getFunctionName = function getFunctionName(fn) {
      var functionName = fn.name;

      if (functionName === undefined) {
        var match = Function.prototype.toString.call(fn).match(/function (\w+)\s*\(/);
        functionName = match && match[1] || '';
      }

      return functionName.replace(/^bound /, '');
    };

    var getObjectName = function getObjectName(obj) {
      var name;
      var className;

      if (obj.constructor && obj.constructor !== Object) {
        className = getFunctionName(obj.constructor);
      }

      if ('toString' in obj && obj.toString !== Object.prototype.toString && obj.toString !== Function.prototype.toString) {
        name = obj.toString();
      } // If the class has a decent looking name, and the `toString` is one of the
      // default Ember toStrings, replace the constructor portion of the toString
      // with the class name. We check the length of the class name to prevent doing
      // this when the value is minified.


      if (name && name.match(/<.*:ember\d+>/) && className && className[0] !== '_' && className.length > 2 && className !== 'Class') {
        return name.replace(/<.*:/, "<" + className + ":");
      }

      return name || className;
    };

    var getPrimitiveName = function getPrimitiveName(value) {
      return String(value);
    };

    debugToString = function debugToString(value) {
      if (typeof value === 'function') {
        return getFunctionName(value) || "(unknown function)";
      } else if (typeof value === 'object' && value !== null) {
        return getObjectName(value) || "(unknown object)";
      } else {
        return getPrimitiveName(value);
      }
    };
  }

  var debugToString$1 = debugToString;

  var beginTestSteps;
  var endTestSteps;
  var verifySteps;
  var logStep;

  /**
   * This constant exists to make it easier to differentiate normal logs from
   * errant console.logs. LOCAL_LOGGER should only be used inside a
   * LOCAL_SHOULD_LOG check.
   *
   * It does not alleviate the need to check LOCAL_SHOULD_LOG, which is used
   * for stripping.
   */

  var LOCAL_LOGGER = console;
  /**
   * This constant exists to make it easier to differentiate normal logs from
   * errant console.logs. LOGGER can be used outside of LOCAL_SHOULD_LOG checks,
   * and is meant to be used in the rare situation where a console.* call is
   * actually appropriate.
   */

  var LOGGER = console;
  function assertNever(value, desc) {
    if (desc === void 0) {
      desc = 'unexpected unreachable branch';
    }

    LOGGER.log('unreachable', value);
    LOGGER.log(desc + " :: " + JSON.stringify(value) + " (" + value + ")");
    throw new Error("code reached unreachable");
  }

  exports.DictSet = DictSet;
  exports.EMPTY_ARRAY = EMPTY_ARRAY;
  exports.EMPTY_NUMBER_ARRAY = EMPTY_NUMBER_ARRAY;
  exports.EMPTY_STRING_ARRAY = EMPTY_STRING_ARRAY;
  exports.HAS_NATIVE_PROXY = HAS_NATIVE_PROXY;
  exports.HAS_NATIVE_SYMBOL = HAS_NATIVE_SYMBOL;
  exports.LOCAL_LOGGER = LOCAL_LOGGER;
  exports.LOGGER = LOGGER;
  exports.NonemptyStack = NonemptyStackImpl;
  exports.SERIALIZATION_FIRST_NODE_STRING = SERIALIZATION_FIRST_NODE_STRING;
  exports.Stack = StackImpl;
  exports._WeakSet = weakSet;
  exports.assert = debugAssert;
  exports.assertNever = assertNever;
  exports.assertPresent = assertPresent;
  exports.assign = assign;
  exports.beginTestSteps = beginTestSteps;
  exports.castToBrowser = castToBrowser;
  exports.castToSimple = castToSimple;
  exports.checkNode = checkNode;
  exports.clearElement = clearElement;
  exports.constants = constants;
  exports.debugToString = debugToString$1;
  exports.decodeHandle = decodeHandle;
  exports.decodeImmediate = decodeImmediate;
  exports.decodeNegative = decodeNegative;
  exports.decodePositive = decodePositive;
  exports.deprecate = deprecate;
  exports.dict = dict;
  exports.emptyArray = emptyArray;
  exports.encodeHandle = encodeHandle;
  exports.encodeImmediate = encodeImmediate;
  exports.encodeNegative = encodeNegative;
  exports.encodePositive = encodePositive;
  exports.endTestSteps = endTestSteps;
  exports.ensureGuid = ensureGuid;
  exports.enumerableSymbol = enumerableSymbol;
  exports.exhausted = exhausted;
  exports.expect = expect;
  exports.extractHandle = extractHandle;
  exports.fillNulls = fillNulls;
  exports.ifPresent = ifPresent;
  exports.initializeGuid = initializeGuid;
  exports.intern = intern;
  exports.isDict = isDict;
  exports.isEmptyArray = isEmptyArray;
  exports.isErrHandle = isErrHandle;
  exports.isHandle = isHandle;
  exports.isNonPrimitiveHandle = isNonPrimitiveHandle;
  exports.isObject = isObject;
  exports.isOkHandle = isOkHandle;
  exports.isPresent = isPresent;
  exports.isSerializationFirstNode = isSerializationFirstNode;
  exports.isSmallInt = isSmallInt;
  exports.keys = keys;
  exports.logStep = logStep;
  exports.mapPresent = mapPresent;
  exports.strip = strip;
  exports.symbol = symbol;
  exports.toPresentOption = toPresentOption;
  exports.tuple = tuple;
  exports.unreachable = unreachable;
  exports.unwrap = unwrap;
  exports.unwrapHandle = unwrapHandle;
  exports.unwrapTemplate = unwrapTemplate;
  exports.values = values;
  exports.verifySteps = verifySteps;

  Object.defineProperty(exports, '__esModule', { value: true });

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2xpbW1lci11dGlsLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9hcnJheS11dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2Fzc2VydC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2d1aWQudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi9jb2xsZWN0aW9ucy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2RvbS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2lzLXNlcmlhbGl6YXRpb24tZmlyc3Qtbm9kZS50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL29iamVjdC11dGlscy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2ludGVybi50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL3BsYXRmb3JtLXV0aWxzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvc3RyaW5nLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvaW1tZWRpYXRlLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvdGVtcGxhdGUudHMiLCIuLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9AZ2xpbW1lci91dGlsL2xpYi93ZWFrLXNldC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL3NpbXBsZS1jYXN0LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9saWIvcHJlc2VudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2RlYnVnLXRvLXN0cmluZy50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvbGliL2RlYnVnLXN0ZXBzLnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvQGdsaW1tZXIvdXRpbC9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgRU1QVFlfQVJSQVk6IHJlYWRvbmx5IHVua25vd25bXSA9IE9iamVjdC5mcmVlemUoW10pIGFzIHJlYWRvbmx5IHVua25vd25bXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5QXJyYXk8VCBleHRlbmRzIHVua25vd24+KCk6IFRbXSB7XG4gIHJldHVybiBFTVBUWV9BUlJBWSBhcyBUW107XG59XG5cbmV4cG9ydCBjb25zdCBFTVBUWV9TVFJJTkdfQVJSQVkgPSBlbXB0eUFycmF5PHN0cmluZz4oKTtcbmV4cG9ydCBjb25zdCBFTVBUWV9OVU1CRVJfQVJSQVkgPSBlbXB0eUFycmF5PG51bWJlcj4oKTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYHRydWVgIGlmIHRoZSBpbnB1dCBhcnJheSBpcyB0aGUgc3BlY2lhbCBlbXB0eSBhcnJheSBzZW50aW5lbCxcbiAqIHdoaWNoIGlzIHNvbWV0aW1lcyB1c2VkIGZvciBvcHRpbWl6YXRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eUFycmF5KGlucHV0OiB1bmtub3duW10gfCByZWFkb25seSB1bmtub3duW10pOiBib29sZWFuIHtcbiAgcmV0dXJuIGlucHV0ID09PSBFTVBUWV9BUlJBWTtcbn1cbiIsIi8vIGltcG9ydCBMb2dnZXIgZnJvbSAnLi9sb2dnZXInO1xuXG5pbXBvcnQgeyBMT0NBTF9MT0dHRVIgfSBmcm9tICcuLi9pbmRleCc7XG5cbi8vIGxldCBhbHJlYWR5V2FybmVkID0gZmFsc2U7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z0Fzc2VydCh0ZXN0OiBhbnksIG1zZzogc3RyaW5nKTogYXNzZXJ0cyB0ZXN0IHtcbiAgLy8gaWYgKCFhbHJlYWR5V2FybmVkKSB7XG4gIC8vICAgYWxyZWFkeVdhcm5lZCA9IHRydWU7XG4gIC8vICAgTG9nZ2VyLndhcm4oXCJEb24ndCBsZWF2ZSBkZWJ1ZyBhc3NlcnRpb25zIG9uIGluIHB1YmxpYyBidWlsZHNcIik7XG4gIC8vIH1cblxuICBpZiAoIXRlc3QpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdhc3NlcnRpb24gZmFpbHVyZScpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9kQXNzZXJ0KCkge31cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZShkZXNjOiBzdHJpbmcpIHtcbiAgTE9DQUxfTE9HR0VSLndhcm4oYERFUFJFQ0FUSU9OOiAke2Rlc2N9YCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlYnVnQXNzZXJ0O1xuIiwibGV0IEdVSUQgPSAwO1xuXG5leHBvcnQgaW50ZXJmYWNlIEhhc0d1aWQge1xuICBfZ3VpZDogbnVtYmVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUd1aWQob2JqZWN0OiBIYXNHdWlkKTogbnVtYmVyIHtcbiAgcmV0dXJuIChvYmplY3QuX2d1aWQgPSArK0dVSUQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlR3VpZChvYmplY3Q6IEhhc0d1aWQpOiBudW1iZXIge1xuICByZXR1cm4gb2JqZWN0Ll9ndWlkIHx8IGluaXRpYWxpemVHdWlkKG9iamVjdCk7XG59XG4iLCJpbXBvcnQgeyBEaWN0LCBOb25lbXB0eVN0YWNrLCBPcHRpb24sIFN0YWNrIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBlbnN1cmVHdWlkLCBIYXNHdWlkIH0gZnJvbSAnLi9ndWlkJztcblxuZXhwb3J0IGludGVyZmFjZSBTZXQ8VD4ge1xuICBhZGQodmFsdWU6IFQpOiBTZXQ8VD47XG4gIGRlbGV0ZSh2YWx1ZTogVCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWN0PFQgPSB1bmtub3duPigpOiBEaWN0PFQ+IHtcbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0RpY3Q8VD4odTogVCk6IHUgaXMgRGljdCAmIFQge1xuICByZXR1cm4gdSAhPT0gbnVsbCAmJiB1ICE9PSB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdDxUPih1OiBUKTogdSBpcyBvYmplY3QgJiBUIHtcbiAgcmV0dXJuIHR5cGVvZiB1ID09PSAnb2JqZWN0JyAmJiB1ICE9PSBudWxsO1xufVxuXG5leHBvcnQgdHlwZSBTZXRNZW1iZXIgPSBIYXNHdWlkIHwgc3RyaW5nO1xuXG5leHBvcnQgY2xhc3MgRGljdFNldDxUIGV4dGVuZHMgU2V0TWVtYmVyPiBpbXBsZW1lbnRzIFNldDxUPiB7XG4gIHByaXZhdGUgZGljdDogRGljdDxUPjtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRpY3QgPSBkaWN0PFQ+KCk7XG4gIH1cblxuICBhZGQob2JqOiBUKTogU2V0PFQ+IHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHRoaXMuZGljdFtvYmogYXMgYW55XSA9IG9iajtcbiAgICBlbHNlIHRoaXMuZGljdFtlbnN1cmVHdWlkKG9iaiBhcyBhbnkpXSA9IG9iajtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlbGV0ZShvYmo6IFQpIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIGRlbGV0ZSB0aGlzLmRpY3Rbb2JqIGFzIGFueV07XG4gICAgZWxzZSBpZiAoKG9iaiBhcyBhbnkpLl9ndWlkKSBkZWxldGUgdGhpcy5kaWN0WyhvYmogYXMgYW55KS5fZ3VpZF07XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0YWNrSW1wbDxUPiBpbXBsZW1lbnRzIFN0YWNrPFQ+IHtcbiAgcHJpdmF0ZSBzdGFjazogVFtdO1xuICBwdWJsaWMgY3VycmVudDogT3B0aW9uPFQ+ID0gbnVsbDtcblxuICBjb25zdHJ1Y3Rvcih2YWx1ZXM6IFRbXSA9IFtdKSB7XG4gICAgdGhpcy5zdGFjayA9IHZhbHVlcztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjay5sZW5ndGg7XG4gIH1cblxuICBwdXNoKGl0ZW06IFQpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBpdGVtO1xuICAgIHRoaXMuc3RhY2sucHVzaChpdGVtKTtcbiAgfVxuXG4gIHBvcCgpOiBPcHRpb248VD4ge1xuICAgIGxldCBpdGVtID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICBsZXQgbGVuID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgdGhpcy5jdXJyZW50ID0gbGVuID09PSAwID8gbnVsbCA6IHRoaXMuc3RhY2tbbGVuIC0gMV07XG5cbiAgICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGl0ZW07XG4gIH1cblxuICBudGgoZnJvbTogbnVtYmVyKTogT3B0aW9uPFQ+IHtcbiAgICBsZXQgbGVuID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgcmV0dXJuIGxlbiA8IGZyb20gPyBudWxsIDogdGhpcy5zdGFja1tsZW4gLSBmcm9tXTtcbiAgfVxuXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2subGVuZ3RoID09PSAwO1xuICB9XG5cbiAgdG9BcnJheSgpOiBUW10ge1xuICAgIHJldHVybiB0aGlzLnN0YWNrO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOb25lbXB0eVN0YWNrSW1wbDxUPiBpbXBsZW1lbnRzIE5vbmVtcHR5U3RhY2s8VD4ge1xuICBwcml2YXRlIHN0YWNrOiBbVCwgLi4uVFtdXTtcbiAgcHVibGljIGN1cnJlbnQ6IFQ7XG5cbiAgY29uc3RydWN0b3IodmFsdWVzOiBbVCwgLi4uVFtdXSkge1xuICAgIHRoaXMuc3RhY2sgPSB2YWx1ZXM7XG4gICAgdGhpcy5jdXJyZW50ID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjay5sZW5ndGg7XG4gIH1cblxuICBwdXNoKGl0ZW06IFQpIHtcbiAgICB0aGlzLmN1cnJlbnQgPSBpdGVtO1xuICAgIHRoaXMuc3RhY2sucHVzaChpdGVtKTtcbiAgfVxuXG4gIHBvcCgpOiBUIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgY2Fubm90IHBvcCB0aGUgbGFzdCBlbGVtZW50IG9mIGEgTm9uZW1wdHlTdGFja2ApO1xuICAgIH1cblxuICAgIGxldCBpdGVtID0gdGhpcy5zdGFjay5wb3AoKSE7XG4gICAgbGV0IGxlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIHRoaXMuY3VycmVudCA9IHRoaXMuc3RhY2tbbGVuIC0gMV07XG5cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIG50aChmcm9tOiAwKTogVDtcbiAgbnRoKGZyb206IG51bWJlcik6IE9wdGlvbjxUPjtcbiAgbnRoKGZyb206IG51bWJlcik6IE9wdGlvbjxUPiB7XG4gICAgbGV0IGxlbiA9IHRoaXMuc3RhY2subGVuZ3RoO1xuICAgIHJldHVybiBmcm9tID49IGxlbiA/IG51bGwgOiB0aGlzLnN0YWNrW2Zyb21dO1xuICB9XG5cbiAgbnRoQmFjayhmcm9tOiBudW1iZXIpOiBPcHRpb248VD4ge1xuICAgIGxldCBsZW4gPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICByZXR1cm4gbGVuIDwgZnJvbSA/IG51bGwgOiB0aGlzLnN0YWNrW2xlbiAtIGZyb21dO1xuICB9XG5cbiAgdG9BcnJheSgpOiBbVCwgLi4uVFtdXSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2s7XG4gIH1cbn1cbiIsImltcG9ydCB7IE9wdGlvbiB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgU2ltcGxlRWxlbWVudCwgU2ltcGxlTm9kZSB9IGZyb20gJ0BzaW1wbGUtZG9tL2ludGVyZmFjZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckVsZW1lbnQocGFyZW50OiBTaW1wbGVFbGVtZW50KSB7XG4gIGxldCBjdXJyZW50OiBPcHRpb248U2ltcGxlTm9kZT4gPSBwYXJlbnQuZmlyc3RDaGlsZDtcblxuICB3aGlsZSAoY3VycmVudCkge1xuICAgIGxldCBuZXh0ID0gY3VycmVudC5uZXh0U2libGluZztcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY3VycmVudCk7XG4gICAgY3VycmVudCA9IG5leHQ7XG4gIH1cbn1cbiIsImltcG9ydCB7IFNpbXBsZU5vZGUgfSBmcm9tICdAc2ltcGxlLWRvbS9pbnRlcmZhY2UnO1xuXG5leHBvcnQgY29uc3QgU0VSSUFMSVpBVElPTl9GSVJTVF9OT0RFX1NUUklORyA9ICclK2I6MCUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTZXJpYWxpemF0aW9uRmlyc3ROb2RlKG5vZGU6IFNpbXBsZU5vZGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIG5vZGUubm9kZVZhbHVlID09PSBTRVJJQUxJWkFUSU9OX0ZJUlNUX05PREVfU1RSSU5HO1xufVxuIiwiY29uc3QgeyBrZXlzOiBvYmpLZXlzIH0gPSBPYmplY3Q7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ248VCwgVT4ob2JqOiBULCBhc3NpZ25tZW50czogVSk6IFQgJiBVO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVLCBWPihvYmo6IFQsIGE6IFUsIGI6IFYpOiBUICYgVSAmIFY7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFc+KG9iajogVCwgYTogVSwgYjogViwgYzogVyk6IFQgJiBVICYgViAmIFc7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFcsIFg+KG9iajogVCwgYTogVSwgYjogViwgYzogVywgZDogWCk6IFQgJiBVICYgViAmIFcgJiBYO1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbjxULCBVLCBWLCBXLCBYLCBZPihcbiAgb2JqOiBULFxuICBhOiBVLFxuICBiOiBWLFxuICBjOiBXLFxuICBkOiBYLFxuICBlOiBZXG4pOiBUICYgVSAmIFYgJiBXICYgWCAmIFk7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduPFQsIFUsIFYsIFcsIFgsIFksIFo+KFxuICBvYmo6IFQsXG4gIGE6IFUsXG4gIGI6IFYsXG4gIGM6IFcsXG4gIGQ6IFgsXG4gIGU6IFksXG4gIGY6IFpcbik6IFQgJiBVICYgViAmIFcgJiBYICYgWSAmIFo7XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKHRhcmdldDogYW55LCAuLi5hcmdzOiBhbnlbXSk6IGFueTtcbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqOiBhbnkpIHtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYXNzaWdubWVudCA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoYXNzaWdubWVudCA9PT0gbnVsbCB8fCB0eXBlb2YgYXNzaWdubWVudCAhPT0gJ29iamVjdCcpIGNvbnRpbnVlO1xuICAgIGxldCBrZXlzID0gb2JqS2V5cyhhc3NpZ25tZW50KTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxldCBrZXkgPSBrZXlzW2pdO1xuICAgICAgb2JqW2tleV0gPSBhc3NpZ25tZW50W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxsTnVsbHM8VD4oY291bnQ6IG51bWJlcik6IFRbXSB7XG4gIGxldCBhcnIgPSBuZXcgQXJyYXkoY291bnQpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGFycltpXSA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVzPFQ+KG9iajogeyBbczogc3RyaW5nXTogVCB9KTogVFtdIHtcbiAgY29uc3QgdmFscyA9IFtdO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICB2YWxzLnB1c2gob2JqW2tleV0pO1xuICB9XG4gIHJldHVybiB2YWxzO1xufVxuIiwiLyoqXG4gIFN0cm9uZ2x5IGhpbnQgcnVudGltZXMgdG8gaW50ZXJuIHRoZSBwcm92aWRlZCBzdHJpbmcuXG5cbiAgV2hlbiBkbyBJIG5lZWQgdG8gdXNlIHRoaXMgZnVuY3Rpb24/XG5cbiAgRm9yIHRoZSBtb3N0IHBhcnQsIG5ldmVyLiBQcmUtbWF0dXJlIG9wdGltaXphdGlvbiBpcyBiYWQsIGFuZCBvZnRlbiB0aGVcbiAgcnVudGltZSBkb2VzIGV4YWN0bHkgd2hhdCB5b3UgbmVlZCBpdCB0bywgYW5kIG1vcmUgb2Z0ZW4gdGhlIHRyYWRlLW9mZiBpc24ndFxuICB3b3J0aCBpdC5cblxuICBXaHk/XG5cbiAgUnVudGltZXMgc3RvcmUgc3RyaW5ncyBpbiBhdCBsZWFzdCAyIGRpZmZlcmVudCByZXByZXNlbnRhdGlvbnM6XG4gIFJvcGVzIGFuZCBTeW1ib2xzIChpbnRlcm5lZCBzdHJpbmdzKS4gVGhlIFJvcGUgcHJvdmlkZXMgYSBtZW1vcnkgZWZmaWNpZW50XG4gIGRhdGEtc3RydWN0dXJlIGZvciBzdHJpbmdzIGNyZWF0ZWQgZnJvbSBjb25jYXRlbmF0aW9uIG9yIHNvbWUgb3RoZXIgc3RyaW5nXG4gIG1hbmlwdWxhdGlvbiBsaWtlIHNwbGl0dGluZy5cblxuICBVbmZvcnR1bmF0ZWx5IGNoZWNraW5nIGVxdWFsaXR5IG9mIGRpZmZlcmVudCByb3BlcyBjYW4gYmUgcXVpdGUgY29zdGx5IGFzXG4gIHJ1bnRpbWVzIG11c3QgcmVzb3J0IHRvIGNsZXZlciBzdHJpbmcgY29tcGFyaXNvbiBhbGdvcml0aG1zLiBUaGVzZVxuICBhbGdvcml0aG1zIHR5cGljYWxseSBjb3N0IGluIHByb3BvcnRpb24gdG8gdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nLlxuICBMdWNraWx5LCB0aGlzIGlzIHdoZXJlIHRoZSBTeW1ib2xzIChpbnRlcm5lZCBzdHJpbmdzKSBzaGluZS4gQXMgU3ltYm9scyBhcmVcbiAgdW5pcXVlIGJ5IHRoZWlyIHN0cmluZyBjb250ZW50LCBlcXVhbGl0eSBjaGVja3MgY2FuIGJlIGRvbmUgYnkgcG9pbnRlclxuICBjb21wYXJpc29uLlxuXG4gIEhvdyBkbyBJIGtub3cgaWYgbXkgc3RyaW5nIGlzIGEgcm9wZSBvciBzeW1ib2w/XG5cbiAgVHlwaWNhbGx5ICh3YXJuaW5nIGdlbmVyYWwgc3dlZXBpbmcgc3RhdGVtZW50LCBidXQgdHJ1dGh5IGluIHJ1bnRpbWVzIGF0XG4gIHByZXNlbnQpIHN0YXRpYyBzdHJpbmdzIGNyZWF0ZWQgYXMgcGFydCBvZiB0aGUgSlMgc291cmNlIGFyZSBpbnRlcm5lZC5cbiAgU3RyaW5ncyBvZnRlbiB1c2VkIGZvciBjb21wYXJpc29ucyBjYW4gYmUgaW50ZXJuZWQgYXQgcnVudGltZSBpZiBzb21lXG4gIGNyaXRlcmlhIGFyZSBtZXQuICBPbmUgb2YgdGhlc2UgY3JpdGVyaWEgY2FuIGJlIHRoZSBzaXplIG9mIHRoZSBlbnRpcmUgcm9wZS5cbiAgRm9yIGV4YW1wbGUsIGluIGNocm9tZSAzOCBhIHJvcGUgbG9uZ2VyIHRoZW4gMTIgY2hhcmFjdGVycyB3aWxsIG5vdFxuICBpbnRlcm4sIG5vciB3aWxsIHNlZ21lbnRzIG9mIHRoYXQgcm9wZS5cblxuICBTb21lIG51bWJlcnM6IGh0dHA6Ly9qc3BlcmYuY29tL2V2YWwtdnMta2V5cy84XG5cbiAgS25vd24gVHJpY2vihKJcblxuICBAcHJpdmF0ZVxuICBAcmV0dXJuIHtTdHJpbmd9IGludGVybmVkIHZlcnNpb24gb2YgdGhlIHByb3ZpZGVkIHN0cmluZ1xuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGludGVybihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBvYmo6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgb2JqW3N0cl0gPSAxO1xuICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGtleSA9PT0gc3RyKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufVxuIiwiaW1wb3J0IHsgTWF5YmUgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCBpbnRlcm4gZnJvbSAnLi9pbnRlcm4nO1xuXG5leHBvcnQgdHlwZSBGYWN0b3J5PFQ+ID0gbmV3ICguLi5hcmdzOiB1bmtub3duW10pID0+IFQ7XG5cbmV4cG9ydCBjb25zdCBIQVNfTkFUSVZFX1BST1hZID0gdHlwZW9mIFByb3h5ID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgSEFTX05BVElWRV9TWU1CT0wgPSAoZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzeW1ib2wtZGVzY3JpcHRpb25cbiAgcmV0dXJuIHR5cGVvZiBTeW1ib2woKSA9PT0gJ3N5bWJvbCc7XG59KSgpO1xuXG5leHBvcnQgZnVuY3Rpb24ga2V5czxUPihvYmo6IFQpOiBBcnJheTxrZXlvZiBUPiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopIGFzIEFycmF5PGtleW9mIFQ+O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwPFQ+KHZhbDogTWF5YmU8VD4pOiBUIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWx1ZSB0byBiZSBwcmVzZW50YCk7XG4gIHJldHVybiB2YWwgYXMgVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cGVjdDxUPih2YWw6IE1heWJlPFQ+LCBtZXNzYWdlOiBzdHJpbmcpOiBUIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gdmFsIGFzIFQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnJlYWNoYWJsZShtZXNzYWdlID0gJ3VucmVhY2hhYmxlJyk6IEVycm9yIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4aGF1c3RlZCh2YWx1ZTogbmV2ZXIpOiBuZXZlciB7XG4gIHRocm93IG5ldyBFcnJvcihgRXhoYXVzdGVkICR7dmFsdWV9YCk7XG59XG5cbmV4cG9ydCB0eXBlIExpdCA9IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCB1bmRlZmluZWQgfCBudWxsIHwgdm9pZCB8IHt9O1xuXG5leHBvcnQgY29uc3QgdHVwbGUgPSA8VCBleHRlbmRzIExpdFtdPiguLi5hcmdzOiBUKSA9PiBhcmdzO1xuXG5leHBvcnQgZnVuY3Rpb24gZW51bWVyYWJsZVN5bWJvbChrZXk6IHN0cmluZyk6IGFueSB7XG4gIHJldHVybiBpbnRlcm4oYF9fJHtrZXl9JHtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBEYXRlLm5vdygpKX1fX2ApO1xufVxuXG5leHBvcnQgY29uc3Qgc3ltYm9sID0gSEFTX05BVElWRV9TWU1CT0wgPyBTeW1ib2wgOiBlbnVtZXJhYmxlU3ltYm9sO1xuIiwiZXhwb3J0IGZ1bmN0aW9uIHN0cmlwKHN0cmluZ3M6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5hcmdzOiB1bmtub3duW10pIHtcbiAgbGV0IG91dCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgc3RyaW5nID0gc3RyaW5nc1tpXTtcbiAgICBsZXQgZHluYW1pYyA9IGFyZ3NbaV0gIT09IHVuZGVmaW5lZCA/IFN0cmluZyhhcmdzW2ldKSA6ICcnO1xuXG4gICAgb3V0ICs9IGAke3N0cmluZ30ke2R5bmFtaWN9YDtcbiAgfVxuXG4gIGxldCBsaW5lcyA9IG91dC5zcGxpdCgnXFxuJyk7XG5cbiAgd2hpbGUgKGxpbmVzLmxlbmd0aCAmJiBsaW5lc1swXS5tYXRjaCgvXlxccyokLykpIHtcbiAgICBsaW5lcy5zaGlmdCgpO1xuICB9XG5cbiAgd2hpbGUgKGxpbmVzLmxlbmd0aCAmJiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5tYXRjaCgvXlxccyokLykpIHtcbiAgICBsaW5lcy5wb3AoKTtcbiAgfVxuXG4gIGxldCBtaW4gPSBJbmZpbml0eTtcblxuICBmb3IgKGxldCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgbGV0IGxlYWRpbmcgPSBsaW5lLm1hdGNoKC9eXFxzKi8pIVswXS5sZW5ndGg7XG5cbiAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGxlYWRpbmcpO1xuICB9XG5cbiAgbGV0IHN0cmlwcGVkID0gW107XG5cbiAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgIHN0cmlwcGVkLnB1c2gobGluZS5zbGljZShtaW4pKTtcbiAgfVxuXG4gIHJldHVybiBzdHJpcHBlZC5qb2luKCdcXG4nKTtcbn1cbiIsImltcG9ydCB7IExPQ0FMX0RFQlVHIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuaW1wb3J0IHsgZGVidWdBc3NlcnQgYXMgYXNzZXJ0IH0gZnJvbSAnLi9hc3NlcnQnO1xuXG4vKlxuICBFbmNvZGluZyBub3Rlc1xuXG4gIFdlIHVzZSAzMCBiaXQgaW50ZWdlcnMgZm9yIGVuY29kaW5nLCBzbyB0aGF0IHdlIGRvbid0IGV2ZXIgZW5jb2RlIGEgbm9uLVNNSVxuICBpbnRlZ2VyIHRvIHB1c2ggb24gdGhlIHN0YWNrLlxuXG4gIEhhbmRsZXMgYXJlID49IDBcbiAgSW1tZWRpYXRlcyBhcmUgPCAwXG5cbiAgVHJ1ZSwgRmFsc2UsIFVuZGVmaW5lZCBhbmQgTnVsbCBhcmUgcHVzaGVkIGFzIGhhbmRsZXMgaW50byB0aGUgc3ltYm9sIHRhYmxlLFxuICB3aXRoIHdlbGwga25vd24gaGFuZGxlcyAoMCwgMSwgMiwgMylcblxuICBUaGUgbmVnYXRpdmUgc3BhY2UgaXMgZGl2aWRlZCBpbnRvIHBvc2l0aXZlcyBhbmQgbmVnYXRpdmVzLiBQb3NpdGl2ZXMgYXJlXG4gIGhpZ2hlciBudW1iZXJzICgtMSwgLTIsIC0zLCBldGMpLCBuZWdhdGl2ZXMgYXJlIGxvd2VyLlxuXG4gIFdlIG9ubHkgZW5jb2RlIGltbWVkaWF0ZXMgZm9yIHR3byByZWFzb25zOlxuXG4gIDEuIFRvIHRyYW5zZmVyIG92ZXIgdGhlIHdpcmUsIHNvIHRoZXkncmUgc21hbGxlciBpbiBnZW5lcmFsXG4gIDIuIFdoZW4gcHVzaGluZyB2YWx1ZXMgb250byB0aGUgc3RhY2sgZnJvbSB0aGUgbG93IGxldmVsL2lubmVyIFZNLCB3aGljaCBtYXlcbiAgICAgYmUgY29udmVydGVkIGludG8gV0FTTSBvbmUgZGF5LlxuXG4gIFRoaXMgYWxsb3dzIHRoZSBsb3ctbGV2ZWwgVk0gdG8gYWx3YXlzIHVzZSBTTUlzLCBhbmQgdG8gbWluaW1pemUgdXNpbmcgSlNcbiAgdmFsdWVzIHZpYSBoYW5kbGVzIGZvciB0aGluZ3MgbGlrZSB0aGUgc3RhY2sgcG9pbnRlciBhbmQgZnJhbWUgcG9pbnRlci5cbiAgRXh0ZXJuYWxseSwgbW9zdCBjb2RlIHB1c2hlcyB2YWx1ZXMgYXMgSlMgdmFsdWVzLCBleGNlcHQgd2hlbiBiZWluZyBwdWxsZWRcbiAgZnJvbSB0aGUgYXBwZW5kIGJ5dGUgY29kZSB3aGVyZSBpdCB3YXMgYWxyZWFkeSBlbmNvZGVkLlxuXG4gIExvZ2ljYWxseSwgdGhpcyBpcyBiZWNhdXNlIHRoZSBsb3cgbGV2ZWwgVk0gZG9lc24ndCByZWFsbHkgY2FyZSBhYm91dCB0aGVzZVxuICBoaWdoZXIgbGV2ZWwgdmFsdWVzLiBGb3IgaW5zdGFuY2UsIHRoZSByZXN1bHQgb2YgYSB1c2VybGFuZCBoZWxwZXIgbWF5IGJlIGFcbiAgbnVtYmVyLCBvciBhIGJvb2xlYW4sIG9yIHVuZGVmaW5lZC9udWxsLCBidXQgaXQncyBleHRyYSB3b3JrIHRvIGZpZ3VyZSB0aGF0XG4gIG91dCBhbmQgcHVzaCBpdCBjb3JyZWN0bHksIHZzLiBqdXN0IHB1c2hpbmcgdGhlIHZhbHVlIGFzIGEgSlMgdmFsdWUgd2l0aCBhXG4gIGhhbmRsZS5cblxuICBOb3RlOiBUaGUgZGV0YWlscyBjb3VsZCBjaGFuZ2UgaGVyZSBpbiB0aGUgZnV0dXJlLCB0aGlzIGlzIGp1c3QgdGhlIGN1cnJlbnRcbiAgc3RyYXRlZ3kuXG4qL1xuXG5leHBvcnQgY29uc3QgZW51bSBJbW1lZGlhdGVDb25zdGFudHMge1xuICBNQVhfU01JID0gMiAqKiAzMCAtIDEsXG4gIE1JTl9TTUkgPSB+TUFYX1NNSSxcbiAgU0lHTl9CSVQgPSB+KDIgKiogMjkpLFxuICBNQVhfSU5UID0gflNJR05fQklUIC0gMSxcbiAgTUlOX0lOVCA9IH5NQVhfSU5ULFxuXG4gIEZBTFNFX0hBTkRMRSA9IDAsXG4gIFRSVUVfSEFORExFID0gMSxcbiAgTlVMTF9IQU5ETEUgPSAyLFxuICBVTkRFRklORURfSEFORExFID0gMyxcblxuICBFTkNPREVEX0ZBTFNFX0hBTkRMRSA9IEZBTFNFX0hBTkRMRSxcbiAgRU5DT0RFRF9UUlVFX0hBTkRMRSA9IFRSVUVfSEFORExFLFxuICBFTkNPREVEX05VTExfSEFORExFID0gTlVMTF9IQU5ETEUsXG4gIEVOQ09ERURfVU5ERUZJTkVEX0hBTkRMRSA9IFVOREVGSU5FRF9IQU5ETEUsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hhbmRsZSh2YWx1ZTogbnVtYmVyKSB7XG4gIHJldHVybiB2YWx1ZSA+PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOb25QcmltaXRpdmVIYW5kbGUodmFsdWU6IG51bWJlcikge1xuICByZXR1cm4gdmFsdWUgPiBJbW1lZGlhdGVDb25zdGFudHMuRU5DT0RFRF9VTkRFRklORURfSEFORExFO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29uc3RhbnRzKC4uLnZhbHVlczogdW5rbm93bltdKTogdW5rbm93bltdIHtcbiAgcmV0dXJuIFtmYWxzZSwgdHJ1ZSwgbnVsbCwgdW5kZWZpbmVkLCAuLi52YWx1ZXNdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTbWFsbEludCh2YWx1ZTogbnVtYmVyKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgJSAxID09PSAwICYmIHZhbHVlIDw9IEltbWVkaWF0ZUNvbnN0YW50cy5NQVhfSU5UICYmIHZhbHVlID49IEltbWVkaWF0ZUNvbnN0YW50cy5NSU5fSU5UXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVOZWdhdGl2ZShudW06IG51bWJlcikge1xuICBpZiAoTE9DQUxfREVCVUcpIHtcbiAgICBhc3NlcnQoXG4gICAgICBudW0gJSAxID09PSAwICYmIG51bSA+PSBJbW1lZGlhdGVDb25zdGFudHMuTUlOX0lOVCAmJiBudW0gPCAwLFxuICAgICAgYENvdWxkIG5vdCBlbmNvZGUgbmVnYXRpdmU6ICR7bnVtfWBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG51bSAmIEltbWVkaWF0ZUNvbnN0YW50cy5TSUdOX0JJVDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZU5lZ2F0aXZlKG51bTogbnVtYmVyKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIGFzc2VydChcbiAgICAgIG51bSAlIDEgPT09IDAgJiYgbnVtIDwgfkltbWVkaWF0ZUNvbnN0YW50cy5NQVhfSU5UICYmIG51bSA+PSBJbW1lZGlhdGVDb25zdGFudHMuTUlOX1NNSSxcbiAgICAgIGBDb3VsZCBub3QgZGVjb2RlIG5lZ2F0aXZlOiAke251bX1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBudW0gfCB+SW1tZWRpYXRlQ29uc3RhbnRzLlNJR05fQklUO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUG9zaXRpdmUobnVtOiBudW1iZXIpIHtcbiAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgbnVtICUgMSA9PT0gMCAmJiBudW0gPj0gMCAmJiBudW0gPD0gSW1tZWRpYXRlQ29uc3RhbnRzLk1BWF9JTlQsXG4gICAgICBgQ291bGQgbm90IGVuY29kZSBwb3NpdGl2ZTogJHtudW19YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gfm51bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZVBvc2l0aXZlKG51bTogbnVtYmVyKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIGFzc2VydChcbiAgICAgIG51bSAlIDEgPT09IDAgJiYgbnVtIDw9IDAgJiYgbnVtID49IH5JbW1lZGlhdGVDb25zdGFudHMuTUFYX0lOVCxcbiAgICAgIGBDb3VsZCBub3QgZGVjb2RlIHBvc2l0aXZlOiAke251bX1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB+bnVtO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlSGFuZGxlKG51bTogbnVtYmVyKSB7XG4gIGlmIChMT0NBTF9ERUJVRykge1xuICAgIGFzc2VydChcbiAgICAgIG51bSAlIDEgPT09IDAgJiYgbnVtID49IDAgJiYgbnVtIDw9IEltbWVkaWF0ZUNvbnN0YW50cy5NQVhfU01JLFxuICAgICAgYENvdWxkIG5vdCBlbmNvZGUgaGFuZGxlOiAke251bX1gXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBudW07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVIYW5kbGUobnVtOiBudW1iZXIpIHtcbiAgaWYgKExPQ0FMX0RFQlVHKSB7XG4gICAgYXNzZXJ0KFxuICAgICAgbnVtICUgMSA9PT0gMCAmJiBudW0gPD0gSW1tZWRpYXRlQ29uc3RhbnRzLk1BWF9TTUkgJiYgbnVtID49IDAsXG4gICAgICBgQ291bGQgbm90IGRlY29kZSBoYW5kbGU6ICR7bnVtfWBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIG51bTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUltbWVkaWF0ZShudW06IG51bWJlcikge1xuICBudW0gfD0gMDtcbiAgcmV0dXJuIG51bSA8IDAgPyBlbmNvZGVOZWdhdGl2ZShudW0pIDogZW5jb2RlUG9zaXRpdmUobnVtKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUltbWVkaWF0ZShudW06IG51bWJlcikge1xuICBudW0gfD0gMDtcbiAgcmV0dXJuIG51bSA+IEltbWVkaWF0ZUNvbnN0YW50cy5TSUdOX0JJVCA/IGRlY29kZVBvc2l0aXZlKG51bSkgOiBkZWNvZGVOZWdhdGl2ZShudW0pO1xufVxuXG4vLyBXYXJtXG5bMSwgMiwgM10uZm9yRWFjaCgoeCkgPT4gZGVjb2RlSGFuZGxlKGVuY29kZUhhbmRsZSh4KSkpO1xuWzEsIC0xXS5mb3JFYWNoKCh4KSA9PiBkZWNvZGVJbW1lZGlhdGUoZW5jb2RlSW1tZWRpYXRlKHgpKSk7XG4iLCJpbXBvcnQgeyBIYW5kbGVSZXN1bHQsIFRlbXBsYXRlLCBUZW1wbGF0ZU9rLCBPa0hhbmRsZSwgRXJySGFuZGxlIH0gZnJvbSAnQGdsaW1tZXIvaW50ZXJmYWNlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBIYW5kbGUoaGFuZGxlOiBIYW5kbGVSZXN1bHQpOiBudW1iZXIge1xuICBpZiAodHlwZW9mIGhhbmRsZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gaGFuZGxlO1xuICB9IGVsc2Uge1xuICAgIGxldCBlcnJvciA9IGhhbmRsZS5lcnJvcnNbMF07XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb21waWxlIEVycm9yOiAke2Vycm9yLnByb2JsZW19IEAgJHtlcnJvci5zcGFuLnN0YXJ0fS4uJHtlcnJvci5zcGFuLmVuZH1gKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlKTogVGVtcGxhdGVPayB7XG4gIGlmICh0ZW1wbGF0ZS5yZXN1bHQgPT09ICdlcnJvcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgQ29tcGlsZSBFcnJvcjogJHt0ZW1wbGF0ZS5wcm9ibGVtfSBAICR7dGVtcGxhdGUuc3Bhbi5zdGFydH0uLiR7dGVtcGxhdGUuc3Bhbi5lbmR9YFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SGFuZGxlKGhhbmRsZTogSGFuZGxlUmVzdWx0KTogbnVtYmVyIHtcbiAgaWYgKHR5cGVvZiBoYW5kbGUgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGhhbmRsZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFuZGxlLmhhbmRsZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPa0hhbmRsZShoYW5kbGU6IEhhbmRsZVJlc3VsdCk6IGhhbmRsZSBpcyBPa0hhbmRsZSB7XG4gIHJldHVybiB0eXBlb2YgaGFuZGxlID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXJySGFuZGxlKGhhbmRsZTogSGFuZGxlUmVzdWx0KTogaGFuZGxlIGlzIEVyckhhbmRsZSB7XG4gIHJldHVybiB0eXBlb2YgaGFuZGxlID09PSAnbnVtYmVyJztcbn1cbiIsImV4cG9ydCBkZWZhdWx0ICh0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFdlYWtTZXRcbiAgOiBjbGFzcyBXZWFrU2V0UG9seUZpbGw8VCBleHRlbmRzIG9iamVjdD4ge1xuICAgICAgcHJpdmF0ZSBfbWFwID0gbmV3IFdlYWtNYXAoKTtcblxuICAgICAgYWRkKHZhbDogVCk6IHRoaXMge1xuICAgICAgICB0aGlzLl9tYXAuc2V0KHZhbCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUodmFsOiBUKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZGVsZXRlKHZhbCk7XG4gICAgICB9XG5cbiAgICAgIGhhcyh2YWw6IFQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXModmFsKTtcbiAgICAgIH1cbiAgICB9KSBhcyBXZWFrU2V0Q29uc3RydWN0b3I7XG4iLCJpbXBvcnQgeyB1bnJlYWNoYWJsZSB9IGZyb20gJy4vcGxhdGZvcm0tdXRpbHMnO1xuaW1wb3J0IHsgTm9kZVR5cGUsIFNpbXBsZURvY3VtZW50LCBTaW1wbGVFbGVtZW50LCBTaW1wbGVOb2RlIH0gZnJvbSAnQHNpbXBsZS1kb20vaW50ZXJmYWNlJztcblxuaW50ZXJmYWNlIEdlbmVyaWNFbGVtZW50VGFncyB7XG4gIEhUTUw6IEhUTUxFbGVtZW50O1xuICBTVkc6IFNWR0VsZW1lbnQ7XG4gIEVMRU1FTlQ6IEhUTUxFbGVtZW50IHwgU1ZHRWxlbWVudDtcbn1cblxuaW50ZXJmYWNlIEdlbmVyaWNOb2RlVGFncyB7XG4gIE5PREU6IE5vZGU7XG59XG5cbnR5cGUgR2VuZXJpY05vZGVUYWcgPSBrZXlvZiBHZW5lcmljTm9kZVRhZ3M7XG5cbmludGVyZmFjZSBCcm93c2VyRWxlbWVudFRhZ3MgZXh0ZW5kcyBIVE1MRWxlbWVudFRhZ05hbWVNYXAsIEdlbmVyaWNFbGVtZW50VGFncyB7fVxudHlwZSBCcm93c2VyRWxlbWVudFRhZyA9IGtleW9mIEJyb3dzZXJFbGVtZW50VGFncztcblxuaW50ZXJmYWNlIEJyb3dzZXJUYWdzIGV4dGVuZHMgQnJvd3NlckVsZW1lbnRUYWdzLCBHZW5lcmljTm9kZVRhZ3Mge31cbnR5cGUgQnJvd3NlclRhZyA9IGtleW9mIEJyb3dzZXJUYWdzO1xuXG50eXBlIE5vZGVDaGVjazxOIGV4dGVuZHMgTm9kZT4gPSAobm9kZTogTm9kZSkgPT4gbm9kZSBpcyBOO1xudHlwZSBTdWdhcnlOb2RlQ2hlY2s8SyBleHRlbmRzIEJyb3dzZXJUYWcgPSBCcm93c2VyVGFnPiA9IE5vZGVDaGVjazxCcm93c2VyVGFnc1tLXT4gfCBLIHwgS1tdO1xudHlwZSBOb2RlRm9yU3VnYXJ5Q2hlY2s8UyBleHRlbmRzIFN1Z2FyeU5vZGVDaGVjazxCcm93c2VyVGFnPj4gPSBTIGV4dGVuZHMgTm9kZUNoZWNrPGluZmVyIE4+XG4gID8gTlxuICA6IFMgZXh0ZW5kcyBrZXlvZiBCcm93c2VyVGFnc1xuICA/IEJyb3dzZXJUYWdzW1NdXG4gIDogUyBleHRlbmRzIChrZXlvZiBCcm93c2VyVGFncylbXVxuICA/IEJyb3dzZXJUYWdzW1NbbnVtYmVyXV1cbiAgOiBuZXZlcjtcblxudHlwZSBCcm93c2VyTm9kZSA9IEVsZW1lbnQgfCBEb2N1bWVudCB8IERvY3VtZW50RnJhZ21lbnQgfCBUZXh0IHwgQ29tbWVudCB8IE5vZGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXN0VG9TaW1wbGUoZG9jOiBEb2N1bWVudCB8IFNpbXBsZURvY3VtZW50KTogU2ltcGxlRG9jdW1lbnQ7XG5leHBvcnQgZnVuY3Rpb24gY2FzdFRvU2ltcGxlKGVsZW06IEVsZW1lbnQgfCBTaW1wbGVFbGVtZW50KTogU2ltcGxlRWxlbWVudDtcbmV4cG9ydCBmdW5jdGlvbiBjYXN0VG9TaW1wbGUobm9kZTogTm9kZSB8IFNpbXBsZU5vZGUpOiBTaW1wbGVOb2RlO1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3RUb1NpbXBsZShcbiAgbm9kZTogRG9jdW1lbnQgfCBFbGVtZW50IHwgTm9kZSB8IFNpbXBsZURvY3VtZW50IHwgU2ltcGxlRWxlbWVudCB8IFNpbXBsZU5vZGVcbikge1xuICBpZiAoaXNEb2N1bWVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlIGFzIFNpbXBsZURvY3VtZW50O1xuICB9IGVsc2UgaWYgKGlzRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlIGFzIFNpbXBsZUVsZW1lbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUgYXMgU2ltcGxlTm9kZTtcbiAgfVxufVxuXG4vLyBJZiBwYXNzZWQgYSBkb2N1bWVudCwgdmVyaWZ5IHdlJ3JlIGluIHRoZSBicm93c2VyIGFuZCByZXR1cm4gaXQgYXMgYSBEb2N1bWVudFxuZXhwb3J0IGZ1bmN0aW9uIGNhc3RUb0Jyb3dzZXIoZG9jOiBEb2N1bWVudCB8IFNpbXBsZURvY3VtZW50KTogRG9jdW1lbnQ7XG4vLyBJZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhpcyBpcywgYnV0IHRoZSBjaGVjayByZXF1aXJlcyBpdCB0byBiZSBhbiBlbGVtZW50LFxuLy8gdGhlIGNhc3Qgd2lsbCBtYW5kYXRlIHRoYXQgaXQncyBhIGJyb3dzZXIgZWxlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIGNhc3RUb0Jyb3dzZXI8UyBleHRlbmRzIFN1Z2FyeU5vZGVDaGVjazxCcm93c2VyRWxlbWVudFRhZz4+KFxuICBub2RlOiBCcm93c2VyTm9kZSB8IFNpbXBsZU5vZGUsXG4gIGNoZWNrOiBTXG4pOiBOb2RlRm9yU3VnYXJ5Q2hlY2s8Uz47XG4vLyBGaW5hbGx5LCBpZiBpdCdzIGEgbW9yZSBnZW5lcmljIGNoZWNrLCB0aGUgY2FzdCB3aWxsIG1hbmRhdGUgdGhhdCBpdCdzIGFcbi8vIGJyb3dzZXIgbm9kZSBhbmQgcmV0dXJuIGEgQnJvd3Nlck5vZGVVdGlscyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjaGVja1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3RUb0Jyb3dzZXI8UyBleHRlbmRzIFN1Z2FyeU5vZGVDaGVjazxHZW5lcmljTm9kZVRhZz4+KFxuICBlbGVtZW50OiBCcm93c2VyTm9kZSB8IFNpbXBsZU5vZGUsXG4gIGNoZWNrOiBTXG4pOiBOb2RlRm9yU3VnYXJ5Q2hlY2s8Uz47XG5leHBvcnQgZnVuY3Rpb24gY2FzdFRvQnJvd3NlcjxLIGV4dGVuZHMga2V5b2YgSFRNTEVsZW1lbnRUYWdOYW1lTWFwPihcbiAgZWxlbWVudDogU2ltcGxlRWxlbWVudCB8IEVsZW1lbnQsXG4gIGNoZWNrOiBLXG4pOiBIVE1MRWxlbWVudFRhZ05hbWVNYXBbS107XG5leHBvcnQgZnVuY3Rpb24gY2FzdFRvQnJvd3NlcjxTIGV4dGVuZHMgU3VnYXJ5Tm9kZUNoZWNrPihcbiAgbm9kZTogU2ltcGxlTm9kZSB8IEJyb3dzZXJOb2RlIHwgbnVsbCB8IHVuZGVmaW5lZCxcbiAgc3VnYXJ5Q2hlY2s/OiBTXG4pOiBEb2N1bWVudCB8IE5vZGVGb3JTdWdhcnlDaGVjazxTPiB8IG51bGwge1xuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQXR0ZW1wdGVkIHRvIGNhc3QgdG8gYSBicm93c2VyIG5vZGUgaW4gYSBub24tYnJvd3NlciBjb250ZXh0Jyk7XG4gIH1cblxuICBpZiAoaXNEb2N1bWVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlIGFzIERvY3VtZW50O1xuICB9XG5cbiAgaWYgKG5vZGUub3duZXJEb2N1bWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQXR0ZW1wdGVkIHRvIGNhc3QgdG8gYSBicm93c2VyIG5vZGUgd2l0aCBhIG5vZGUgdGhhdCB3YXMgbm90IGNyZWF0ZWQgZnJvbSB0aGlzIGRvY3VtZW50J1xuICAgICk7XG4gIH1cblxuICByZXR1cm4gY2hlY2tOb2RlPFM+KG5vZGUsIHN1Z2FyeUNoZWNrISk7XG59XG5cbmZ1bmN0aW9uIGNoZWNrRXJyb3IoZnJvbTogc3RyaW5nLCBjaGVjazogU3VnYXJ5Tm9kZUNoZWNrKTogRXJyb3Ige1xuICByZXR1cm4gbmV3IEVycm9yKGBjYW5ub3QgY2FzdCBhICR7ZnJvbX0gaW50byAke2NoZWNrfWApO1xufVxuXG5mdW5jdGlvbiBpc0RvY3VtZW50KG5vZGU6IE5vZGUgfCBTaW1wbGVOb2RlIHwgU2ltcGxlRG9jdW1lbnQpOiBub2RlIGlzIERvY3VtZW50IHwgU2ltcGxlRG9jdW1lbnQge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuRE9DVU1FTlRfTk9ERTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGU6IE5vZGUgfCBTaW1wbGVOb2RlIHwgU2ltcGxlRWxlbWVudCk6IG5vZGUgaXMgRWxlbWVudCB8IFNpbXBsZUVsZW1lbnQge1xuICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZVR5cGUuRUxFTUVOVF9OT0RFO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tOb2RlPFMgZXh0ZW5kcyBTdWdhcnlOb2RlQ2hlY2s+KFxuICBub2RlOiBOb2RlIHwgbnVsbCxcbiAgY2hlY2s6IFNcbik6IE5vZGVGb3JTdWdhcnlDaGVjazxTPiB7XG4gIGxldCBpc01hdGNoID0gZmFsc2U7XG5cbiAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGNoZWNrID09PSAnc3RyaW5nJykge1xuICAgICAgaXNNYXRjaCA9IHN0cmluZ0NoZWNrTm9kZShub2RlLCBjaGVjayBhcyBCcm93c2VyVGFnKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hlY2spKSB7XG4gICAgICBpc01hdGNoID0gY2hlY2suc29tZSgoYykgPT4gc3RyaW5nQ2hlY2tOb2RlKG5vZGUsIGMgYXMgQnJvd3NlclRhZykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB1bnJlYWNoYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc01hdGNoKSB7XG4gICAgcmV0dXJuIG5vZGUgYXMgTm9kZUZvclN1Z2FyeUNoZWNrPFM+O1xuICB9IGVsc2Uge1xuICAgIHRocm93IGNoZWNrRXJyb3IoYFNpbXBsZUVsZW1lbnQoJHtub2RlfSlgLCBjaGVjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RyaW5nQ2hlY2tOb2RlPFMgZXh0ZW5kcyBCcm93c2VyVGFnPihub2RlOiBOb2RlLCBjaGVjazogUyk6IG5vZGUgaXMgQnJvd3NlclRhZ3NbU10ge1xuICBzd2l0Y2ggKGNoZWNrKSB7XG4gICAgY2FzZSAnTk9ERSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdIVE1MJzpcbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gICAgY2FzZSAnU1ZHJzpcbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgU1ZHRWxlbWVudDtcbiAgICBjYXNlICdFTEVNRU5UJzpcbiAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGNoZWNrLnRvVXBwZXJDYXNlKCkgPT09IGNoZWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQlVHOiB0aGlzIGNvZGUgaXMgbWlzc2luZyBoYW5kbGluZyBmb3IgYSBnZW5lcmljIG5vZGUgdHlwZWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBjaGVjaztcbiAgfVxufVxuIiwiaW1wb3J0IHsgT3B0aW9uLCBQcmVzZW50QXJyYXkgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJlc2VudDxUPihsaXN0OiByZWFkb25seSBUW10pOiBsaXN0IGlzIFByZXNlbnRBcnJheTxUPiB7XG4gIHJldHVybiBsaXN0Lmxlbmd0aCA+IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpZlByZXNlbnQ8VCwgVSwgVj4oXG4gIGxpc3Q6IFRbXSxcbiAgaWZQcmVzZW50OiAoaW5wdXQ6IFByZXNlbnRBcnJheTxUPikgPT4gVSxcbiAgb3RoZXJ3aXNlOiAoKSA9PiBWXG4pOiBVIHwgViB7XG4gIGlmIChpc1ByZXNlbnQobGlzdCkpIHtcbiAgICByZXR1cm4gaWZQcmVzZW50KGxpc3QpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvdGhlcndpc2UoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9QcmVzZW50T3B0aW9uPFQ+KGxpc3Q6IFRbXSk6IE9wdGlvbjxQcmVzZW50QXJyYXk8VD4+IHtcbiAgaWYgKGlzUHJlc2VudChsaXN0KSkge1xuICAgIHJldHVybiBsaXN0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRQcmVzZW50PFQ+KFxuICBsaXN0OiBUW10sXG4gIG1lc3NhZ2UgPSBgdW5leHBlY3RlZCBlbXB0eSBsaXN0YFxuKTogYXNzZXJ0cyBsaXN0IGlzIFByZXNlbnRBcnJheTxUPiB7XG4gIGlmICghaXNQcmVzZW50KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBQcmVzZW50PFQsIFU+KGxpc3Q6IFByZXNlbnRBcnJheTxUPiwgY2FsbGJhY2s6IChpbnB1dDogVCkgPT4gVSk6IFByZXNlbnRBcnJheTxVPjtcbmV4cG9ydCBmdW5jdGlvbiBtYXBQcmVzZW50PFQsIFU+KFxuICBsaXN0OiBQcmVzZW50QXJyYXk8VD4gfCBudWxsLFxuICBjYWxsYmFjazogKGlucHV0OiBUKSA9PiBVXG4pOiBQcmVzZW50QXJyYXk8VT4gfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFByZXNlbnQ8VCwgVT4oXG4gIGxpc3Q6IFByZXNlbnRBcnJheTxUPiB8IG51bGwsXG4gIGNhbGxiYWNrOiAoaW5wdXQ6IFQpID0+IFVcbik6IFByZXNlbnRBcnJheTxVPiB8IG51bGwge1xuICBpZiAobGlzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBvdXQ6IFVbXSA9IFtdO1xuXG4gIGZvciAobGV0IGl0ZW0gb2YgbGlzdCkge1xuICAgIG91dC5wdXNoKGNhbGxiYWNrKGl0ZW0pKTtcbiAgfVxuXG4gIHJldHVybiBvdXQgYXMgUHJlc2VudEFycmF5PFU+O1xufVxuIiwiaW1wb3J0IHsgREVCVUcgfSBmcm9tICdAZ2xpbW1lci9lbnYnO1xuXG5sZXQgZGVidWdUb1N0cmluZzogdW5kZWZpbmVkIHwgKCh2YWx1ZTogdW5rbm93bikgPT4gc3RyaW5nKTtcblxuaWYgKERFQlVHKSB7XG4gIGxldCBnZXRGdW5jdGlvbk5hbWUgPSAoZm46IEZ1bmN0aW9uKSA9PiB7XG4gICAgbGV0IGZ1bmN0aW9uTmFtZSA9IGZuLm5hbWU7XG5cbiAgICBpZiAoZnVuY3Rpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGxldCBtYXRjaCA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZuKS5tYXRjaCgvZnVuY3Rpb24gKFxcdyspXFxzKlxcKC8pO1xuXG4gICAgICBmdW5jdGlvbk5hbWUgPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbk5hbWUucmVwbGFjZSgvXmJvdW5kIC8sICcnKTtcbiAgfTtcblxuICBsZXQgZ2V0T2JqZWN0TmFtZSA9IChvYmo6IG9iamVjdCkgPT4ge1xuICAgIGxldCBuYW1lO1xuICAgIGxldCBjbGFzc05hbWU7XG5cbiAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmIG9iai5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICBjbGFzc05hbWUgPSBnZXRGdW5jdGlvbk5hbWUob2JqLmNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAndG9TdHJpbmcnIGluIG9iaiAmJlxuICAgICAgb2JqLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nICYmXG4gICAgICBvYmoudG9TdHJpbmcgIT09IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZ1xuICAgICkge1xuICAgICAgbmFtZSA9IG9iai50b1N0cmluZygpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBjbGFzcyBoYXMgYSBkZWNlbnQgbG9va2luZyBuYW1lLCBhbmQgdGhlIGB0b1N0cmluZ2AgaXMgb25lIG9mIHRoZVxuICAgIC8vIGRlZmF1bHQgRW1iZXIgdG9TdHJpbmdzLCByZXBsYWNlIHRoZSBjb25zdHJ1Y3RvciBwb3J0aW9uIG9mIHRoZSB0b1N0cmluZ1xuICAgIC8vIHdpdGggdGhlIGNsYXNzIG5hbWUuIFdlIGNoZWNrIHRoZSBsZW5ndGggb2YgdGhlIGNsYXNzIG5hbWUgdG8gcHJldmVudCBkb2luZ1xuICAgIC8vIHRoaXMgd2hlbiB0aGUgdmFsdWUgaXMgbWluaWZpZWQuXG4gICAgaWYgKFxuICAgICAgbmFtZSAmJlxuICAgICAgbmFtZS5tYXRjaCgvPC4qOmVtYmVyXFxkKz4vKSAmJlxuICAgICAgY2xhc3NOYW1lICYmXG4gICAgICBjbGFzc05hbWVbMF0gIT09ICdfJyAmJlxuICAgICAgY2xhc3NOYW1lLmxlbmd0aCA+IDIgJiZcbiAgICAgIGNsYXNzTmFtZSAhPT0gJ0NsYXNzJ1xuICAgICkge1xuICAgICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvPC4qOi8sIGA8JHtjbGFzc05hbWV9OmApO1xuICAgIH1cblxuICAgIHJldHVybiBuYW1lIHx8IGNsYXNzTmFtZTtcbiAgfTtcblxuICBsZXQgZ2V0UHJpbWl0aXZlTmFtZSA9ICh2YWx1ZTogYW55KSA9PiB7XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH07XG5cbiAgZGVidWdUb1N0cmluZyA9ICh2YWx1ZTogdW5rbm93bikgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBnZXRGdW5jdGlvbk5hbWUodmFsdWUpIHx8IGAodW5rbm93biBmdW5jdGlvbilgO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGdldE9iamVjdE5hbWUodmFsdWUpIHx8IGAodW5rbm93biBvYmplY3QpYDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldFByaW1pdGl2ZU5hbWUodmFsdWUpO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVidWdUb1N0cmluZztcbiIsImltcG9ydCB7IExPQ0FMX0RFQlVHIH0gZnJvbSAnQGdsaW1tZXIvbG9jYWwtZGVidWctZmxhZ3MnO1xuaW1wb3J0IGFzc2VydCBmcm9tICcuL2Fzc2VydCc7XG5pbXBvcnQgeyBleHBlY3QgfSBmcm9tICcuL3BsYXRmb3JtLXV0aWxzJztcblxuZXhwb3J0IGxldCBiZWdpblRlc3RTdGVwczogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBlbmRUZXN0U3RlcHM6ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IGxldCB2ZXJpZnlTdGVwczpcbiAgfCAoKHR5cGU6IHN0cmluZywgc3RlcHM6IHVua25vd25bXSB8ICgoc3RlcHM6IHVua25vd25bXSkgPT4gdm9pZCksIG1lc3NhZ2U/OiBzdHJpbmcpID0+IHZvaWQpXG4gIHwgdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBsb2dTdGVwOiAoKHR5cGU6IHN0cmluZywgc3RlcHM6IHVua25vd24pID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuXG5pZiAoTE9DQUxfREVCVUcpIHtcbiAgbGV0IExPR0dFRF9TVEVQUzogUmVjb3JkPHN0cmluZywgdW5rbm93bltdPiB8IG51bGwgPSBudWxsO1xuXG4gIGJlZ2luVGVzdFN0ZXBzID0gKCkgPT4ge1xuICAgIGFzc2VydChMT0dHRURfU1RFUFMgPT09IG51bGwsICdhdHRlbXB0ZWQgdG8gc3RhcnQgc3RlcHMsIGJ1dCBpdCBhbHJlYWR5IGJlZ2FuJyk7XG5cbiAgICBMT0dHRURfU1RFUFMgPSB7fTtcbiAgfTtcblxuICBlbmRUZXN0U3RlcHMgPSAoKSA9PiB7XG4gICAgYXNzZXJ0KExPR0dFRF9TVEVQUywgJ2F0dGVtcHRlZCB0byBlbmQgc3RlcHMsIGJ1dCB0aGV5IHdlcmUgbm90IHN0YXJ0ZWQnKTtcblxuICAgIExPR0dFRF9TVEVQUyA9IG51bGw7XG4gIH07XG5cbiAgbG9nU3RlcCA9ICh0eXBlOiBzdHJpbmcsIHN0ZXA6IHVua25vd24pID0+IHtcbiAgICBpZiAoTE9HR0VEX1NURVBTID09PSBudWxsKSByZXR1cm47XG5cbiAgICBMT0dHRURfU1RFUFNbdHlwZV0gPSBMT0dHRURfU1RFUFNbdHlwZV0gfHwgW107XG4gICAgTE9HR0VEX1NURVBTW3R5cGVdLnB1c2goc3RlcCk7XG4gIH07XG5cbiAgdmVyaWZ5U3RlcHMgPSAoXG4gICAgdHlwZTogc3RyaW5nLFxuICAgIGV4cGVjdGVkU3RlcHM6IHVua25vd25bXSB8ICgoc3RlcHM6IHVua25vd25bXSkgPT4gdm9pZCksXG4gICAgbWVzc2FnZT86IHN0cmluZ1xuICApID0+IHtcbiAgICBsZXQgbG9nZ2VkU3RlcHMgPSBleHBlY3QoTE9HR0VEX1NURVBTLCAnYXR0ZW1wZXRkIHRvIHZlcmlmeSBzdGVwcywgYnV0IHN0ZXBzIHdlcmUgbm90IHN0YXJ0ZWQnKTtcblxuICAgIGxldCBzdGVwcyA9IGxvZ2dlZFN0ZXBzW3R5cGVdIHx8IFtdO1xuXG4gICAgbG9nZ2VkU3RlcHNbdHlwZV0gPSBbXTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkU3RlcHMpKSB7XG4gICAgICBRVW5pdC5jb25maWcuY3VycmVudC5hc3NlcnQuZGVlcEVxdWFsKHN0ZXBzLCBleHBlY3RlZFN0ZXBzLCBtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwZWN0ZWRTdGVwcyhzdGVwcyk7XG4gICAgfVxuICB9O1xufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9saWIvYXJyYXktdXRpbHMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBhc3NlcnQsIGRlcHJlY2F0ZSB9IGZyb20gJy4vbGliL2Fzc2VydCc7XG5leHBvcnQge1xuICBkaWN0LFxuICBEaWN0U2V0LFxuICBpc0RpY3QsXG4gIGlzT2JqZWN0LFxuICBTZXQsXG4gIFN0YWNrSW1wbCBhcyBTdGFjayxcbiAgTm9uZW1wdHlTdGFja0ltcGwgYXMgTm9uZW1wdHlTdGFjayxcbn0gZnJvbSAnLi9saWIvY29sbGVjdGlvbnMnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvZG9tJztcbmV4cG9ydCB7IGVuc3VyZUd1aWQsIEhhc0d1aWQsIGluaXRpYWxpemVHdWlkIH0gZnJvbSAnLi9saWIvZ3VpZCc7XG5leHBvcnQge1xuICBpc1NlcmlhbGl6YXRpb25GaXJzdE5vZGUsXG4gIFNFUklBTElaQVRJT05fRklSU1RfTk9ERV9TVFJJTkcsXG59IGZyb20gJy4vbGliL2lzLXNlcmlhbGl6YXRpb24tZmlyc3Qtbm9kZSc7XG5leHBvcnQgeyBhc3NpZ24sIGZpbGxOdWxscywgdmFsdWVzIH0gZnJvbSAnLi9saWIvb2JqZWN0LXV0aWxzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3BsYXRmb3JtLXV0aWxzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3N0cmluZyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9pbW1lZGlhdGUnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvdGVtcGxhdGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBfV2Vha1NldCB9IGZyb20gJy4vbGliL3dlYWstc2V0JztcbmV4cG9ydCB7IGNhc3RUb1NpbXBsZSwgY2FzdFRvQnJvd3NlciwgY2hlY2tOb2RlIH0gZnJvbSAnLi9saWIvc2ltcGxlLWNhc3QnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvcHJlc2VudCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGludGVybiB9IGZyb20gJy4vbGliL2ludGVybic7XG5cbmV4cG9ydCB7IGRlZmF1bHQgYXMgZGVidWdUb1N0cmluZyB9IGZyb20gJy4vbGliL2RlYnVnLXRvLXN0cmluZyc7XG5leHBvcnQgeyBiZWdpblRlc3RTdGVwcywgZW5kVGVzdFN0ZXBzLCBsb2dTdGVwLCB2ZXJpZnlTdGVwcyB9IGZyb20gJy4vbGliL2RlYnVnLXN0ZXBzJztcblxuZXhwb3J0IHR5cGUgRklYTUU8VCwgUyBleHRlbmRzIHN0cmluZz4gPSAoVCAmIFMpIHwgVDtcblxuLyoqXG4gKiBUaGlzIGNvbnN0YW50IGV4aXN0cyB0byBtYWtlIGl0IGVhc2llciB0byBkaWZmZXJlbnRpYXRlIG5vcm1hbCBsb2dzIGZyb21cbiAqIGVycmFudCBjb25zb2xlLmxvZ3MuIExPQ0FMX0xPR0dFUiBzaG91bGQgb25seSBiZSB1c2VkIGluc2lkZSBhXG4gKiBMT0NBTF9TSE9VTERfTE9HIGNoZWNrLlxuICpcbiAqIEl0IGRvZXMgbm90IGFsbGV2aWF0ZSB0aGUgbmVlZCB0byBjaGVjayBMT0NBTF9TSE9VTERfTE9HLCB3aGljaCBpcyB1c2VkXG4gKiBmb3Igc3RyaXBwaW5nLlxuICovXG5leHBvcnQgY29uc3QgTE9DQUxfTE9HR0VSID0gY29uc29sZTtcblxuLyoqXG4gKiBUaGlzIGNvbnN0YW50IGV4aXN0cyB0byBtYWtlIGl0IGVhc2llciB0byBkaWZmZXJlbnRpYXRlIG5vcm1hbCBsb2dzIGZyb21cbiAqIGVycmFudCBjb25zb2xlLmxvZ3MuIExPR0dFUiBjYW4gYmUgdXNlZCBvdXRzaWRlIG9mIExPQ0FMX1NIT1VMRF9MT0cgY2hlY2tzLFxuICogYW5kIGlzIG1lYW50IHRvIGJlIHVzZWQgaW4gdGhlIHJhcmUgc2l0dWF0aW9uIHdoZXJlIGEgY29uc29sZS4qIGNhbGwgaXNcbiAqIGFjdHVhbGx5IGFwcHJvcHJpYXRlLlxuICovXG5leHBvcnQgY29uc3QgTE9HR0VSID0gY29uc29sZTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5ldmVyKHZhbHVlOiBuZXZlciwgZGVzYyA9ICd1bmV4cGVjdGVkIHVucmVhY2hhYmxlIGJyYW5jaCcpOiBuZXZlciB7XG4gIExPR0dFUi5sb2coJ3VucmVhY2hhYmxlJywgdmFsdWUpO1xuICBMT0dHRVIubG9nKGAke2Rlc2N9IDo6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSAoJHt2YWx1ZX0pYCk7XG5cbiAgdGhyb3cgbmV3IEVycm9yKGBjb2RlIHJlYWNoZWQgdW5yZWFjaGFibGVgKTtcbn1cbiJdLCJuYW1lcyI6WyJERUJVRyJdLCJtYXBwaW5ncyI6Ijs7TUFBYSxXQUFXLEdBQXVCLE1BQU0sQ0FBTixNQUFBLENBQXhDLEVBQXdDO0VBRXpDLFNBQUEsVUFBQSxHQUFvQjtFQUN4QixTQUFBLFdBQUE7RUFDRDtNQUVZLGtCQUFrQixHQUFHLFVBQTNCO01BQ00sa0JBQWtCLEdBQUcsVUFBM0I7RUFFUDs7Ozs7RUFJTSxTQUFBLFlBQUEsQ0FBQSxLQUFBLEVBQTREO0VBQ2hFLFNBQU8sS0FBSyxLQUFaLFdBQUE7RUFDRDs7RUNmRDtBQUVBO0FBSUEsRUFBTSxTQUFBLFdBQUEsQ0FBQSxJQUFBLEVBQUEsR0FBQSxFQUE0QztFQUNoRDtFQUNBO0VBQ0E7RUFDQTtFQUVBLE1BQUksQ0FBSixJQUFBLEVBQVc7RUFDVCxVQUFNLElBQUEsS0FBQSxDQUFVLEdBQUcsSUFBbkIsbUJBQU0sQ0FBTjtFQUNEO0VBQ0Y7QUFFRCxFQUVNLFNB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
