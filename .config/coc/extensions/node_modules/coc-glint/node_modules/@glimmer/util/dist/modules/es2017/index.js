export * from './lib/array-utils';
export { default as assert, deprecate } from './lib/assert';
export { dict, DictSet, isDict, isObject, StackImpl as Stack, NonemptyStackImpl as NonemptyStack } from './lib/collections';
export * from './lib/dom';
export { ensureGuid, initializeGuid } from './lib/guid';
export { isSerializationFirstNode, SERIALIZATION_FIRST_NODE_STRING } from './lib/is-serialization-first-node';
export { assign, fillNulls, values } from './lib/object-utils';
export * from './lib/platform-utils';
export * from './lib/string';
export * from './lib/immediate';
export * from './lib/template';
export { default as _WeakSet } from './lib/weak-set';
export { castToSimple, castToBrowser, checkNode } from './lib/simple-cast';
export * from './lib/present';
export { default as intern } from './lib/intern';
export { default as debugToString } from './lib/debug-to-string';
export { beginTestSteps, endTestSteps, logStep, verifySteps } from './lib/debug-steps';
/**
 * This constant exists to make it easier to differentiate normal logs from
 * errant console.logs. LOCAL_LOGGER should only be used inside a
 * LOCAL_SHOULD_LOG check.
 *
 * It does not alleviate the need to check LOCAL_SHOULD_LOG, which is used
 * for stripping.
 */

export const LOCAL_LOGGER = console;
/**
 * This constant exists to make it easier to differentiate normal logs from
 * errant console.logs. LOGGER can be used outside of LOCAL_SHOULD_LOG checks,
 * and is meant to be used in the rare situation where a console.* call is
 * actually appropriate.
 */

export const LOGGER = console;
export function assertNever(value, desc = 'unexpected unreachable branch') {
  LOGGER.log('unreachable', value);
  LOGGER.log(`${desc} :: ${JSON.stringify(value)} (${value})`);
  throw new Error(`code reached unreachable`);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3V0aWwvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBZDtBQUNBLFNBQVMsT0FBTyxJQUFJLE1BQXBCLEVBQTRCLFNBQTVCLFFBQTZDLGNBQTdDO0FBQ0EsU0FDRSxJQURGLEVBRUUsT0FGRixFQUdFLE1BSEYsRUFJRSxRQUpGLEVBTUUsU0FBUyxJQUFJLEtBTmYsRUFPRSxpQkFBaUIsSUFBSSxhQVB2QixRQVFPLG1CQVJQO0FBU0EsY0FBYyxXQUFkO0FBQ0EsU0FBUyxVQUFULEVBQThCLGNBQTlCLFFBQW9ELFlBQXBEO0FBQ0EsU0FDRSx3QkFERixFQUVFLCtCQUZGLFFBR08sbUNBSFA7QUFJQSxTQUFTLE1BQVQsRUFBaUIsU0FBakIsRUFBNEIsTUFBNUIsUUFBMEMsb0JBQTFDO0FBQ0EsY0FBYyxzQkFBZDtBQUNBLGNBQWMsY0FBZDtBQUNBLGNBQWMsaUJBQWQ7QUFDQSxjQUFjLGdCQUFkO0FBQ0EsU0FBUyxPQUFPLElBQUksUUFBcEIsUUFBb0MsZ0JBQXBDO0FBQ0EsU0FBUyxZQUFULEVBQXVCLGFBQXZCLEVBQXNDLFNBQXRDLFFBQXVELG1CQUF2RDtBQUNBLGNBQWMsZUFBZDtBQUNBLFNBQVMsT0FBTyxJQUFJLE1BQXBCLFFBQWtDLGNBQWxDO0FBRUEsU0FBUyxPQUFPLElBQUksYUFBcEIsUUFBeUMsdUJBQXpDO0FBQ0EsU0FBUyxjQUFULEVBQXlCLFlBQXpCLEVBQXVDLE9BQXZDLEVBQWdELFdBQWhELFFBQW1FLG1CQUFuRTtBQUlBOzs7Ozs7Ozs7QUFRQSxPQUFPLE1BQU0sWUFBWSxHQUFHLE9BQXJCO0FBRVA7Ozs7Ozs7QUFNQSxPQUFPLE1BQU0sTUFBTSxHQUFHLE9BQWY7QUFFUCxPQUFNLFNBQVUsV0FBVixDQUFzQixLQUF0QixFQUFvQyxJQUFJLEdBQUcsK0JBQTNDLEVBQTBFO0FBQzlFLEVBQUEsTUFBTSxDQUFDLEdBQVAsQ0FBVyxhQUFYLEVBQTBCLEtBQTFCO0FBQ0EsRUFBQSxNQUFNLENBQUMsR0FBUCxDQUFXLEdBQUcsSUFBSSxPQUFPLElBQUksQ0FBQyxTQUFMLENBQWUsS0FBZixDQUFxQixLQUFLLEtBQUssR0FBeEQ7QUFFQSxRQUFNLElBQUksS0FBSixDQUFVLDBCQUFWLENBQU47QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vbGliL2FycmF5LXV0aWxzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXNzZXJ0LCBkZXByZWNhdGUgfSBmcm9tICcuL2xpYi9hc3NlcnQnO1xuZXhwb3J0IHtcbiAgZGljdCxcbiAgRGljdFNldCxcbiAgaXNEaWN0LFxuICBpc09iamVjdCxcbiAgU2V0LFxuICBTdGFja0ltcGwgYXMgU3RhY2ssXG4gIE5vbmVtcHR5U3RhY2tJbXBsIGFzIE5vbmVtcHR5U3RhY2ssXG59IGZyb20gJy4vbGliL2NvbGxlY3Rpb25zJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2RvbSc7XG5leHBvcnQgeyBlbnN1cmVHdWlkLCBIYXNHdWlkLCBpbml0aWFsaXplR3VpZCB9IGZyb20gJy4vbGliL2d1aWQnO1xuZXhwb3J0IHtcbiAgaXNTZXJpYWxpemF0aW9uRmlyc3ROb2RlLFxuICBTRVJJQUxJWkFUSU9OX0ZJUlNUX05PREVfU1RSSU5HLFxufSBmcm9tICcuL2xpYi9pcy1zZXJpYWxpemF0aW9uLWZpcnN0LW5vZGUnO1xuZXhwb3J0IHsgYXNzaWduLCBmaWxsTnVsbHMsIHZhbHVlcyB9IGZyb20gJy4vbGliL29iamVjdC11dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9wbGF0Zm9ybS11dGlscyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9zdHJpbmcnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvaW1tZWRpYXRlJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3RlbXBsYXRlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgX1dlYWtTZXQgfSBmcm9tICcuL2xpYi93ZWFrLXNldCc7XG5leHBvcnQgeyBjYXN0VG9TaW1wbGUsIGNhc3RUb0Jyb3dzZXIsIGNoZWNrTm9kZSB9IGZyb20gJy4vbGliL3NpbXBsZS1jYXN0JztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3ByZXNlbnQnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBpbnRlcm4gfSBmcm9tICcuL2xpYi9pbnRlcm4nO1xuXG5leHBvcnQgeyBkZWZhdWx0IGFzIGRlYnVnVG9TdHJpbmcgfSBmcm9tICcuL2xpYi9kZWJ1Zy10by1zdHJpbmcnO1xuZXhwb3J0IHsgYmVnaW5UZXN0U3RlcHMsIGVuZFRlc3RTdGVwcywgbG9nU3RlcCwgdmVyaWZ5U3RlcHMgfSBmcm9tICcuL2xpYi9kZWJ1Zy1zdGVwcyc7XG5cbmV4cG9ydCB0eXBlIEZJWE1FPFQsIFMgZXh0ZW5kcyBzdHJpbmc+ID0gKFQgJiBTKSB8IFQ7XG5cbi8qKlxuICogVGhpcyBjb25zdGFudCBleGlzdHMgdG8gbWFrZSBpdCBlYXNpZXIgdG8gZGlmZmVyZW50aWF0ZSBub3JtYWwgbG9ncyBmcm9tXG4gKiBlcnJhbnQgY29uc29sZS5sb2dzLiBMT0NBTF9MT0dHRVIgc2hvdWxkIG9ubHkgYmUgdXNlZCBpbnNpZGUgYVxuICogTE9DQUxfU0hPVUxEX0xPRyBjaGVjay5cbiAqXG4gKiBJdCBkb2VzIG5vdCBhbGxldmlhdGUgdGhlIG5lZWQgdG8gY2hlY2sgTE9DQUxfU0hPVUxEX0xPRywgd2hpY2ggaXMgdXNlZFxuICogZm9yIHN0cmlwcGluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IExPQ0FMX0xPR0dFUiA9IGNvbnNvbGU7XG5cbi8qKlxuICogVGhpcyBjb25zdGFudCBleGlzdHMgdG8gbWFrZSBpdCBlYXNpZXIgdG8gZGlmZmVyZW50aWF0ZSBub3JtYWwgbG9ncyBmcm9tXG4gKiBlcnJhbnQgY29uc29sZS5sb2dzLiBMT0dHRVIgY2FuIGJlIHVzZWQgb3V0c2lkZSBvZiBMT0NBTF9TSE9VTERfTE9HIGNoZWNrcyxcbiAqIGFuZCBpcyBtZWFudCB0byBiZSB1c2VkIGluIHRoZSByYXJlIHNpdHVhdGlvbiB3aGVyZSBhIGNvbnNvbGUuKiBjYWxsIGlzXG4gKiBhY3R1YWxseSBhcHByb3ByaWF0ZS5cbiAqL1xuZXhwb3J0IGNvbnN0IExPR0dFUiA9IGNvbnNvbGU7XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcih2YWx1ZTogbmV2ZXIsIGRlc2MgPSAndW5leHBlY3RlZCB1bnJlYWNoYWJsZSBicmFuY2gnKTogbmV2ZXIge1xuICBMT0dHRVIubG9nKCd1bnJlYWNoYWJsZScsIHZhbHVlKTtcbiAgTE9HR0VSLmxvZyhgJHtkZXNjfSA6OiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gKCR7dmFsdWV9KWApO1xuXG4gIHRocm93IG5ldyBFcnJvcihgY29kZSByZWFjaGVkIHVucmVhY2hhYmxlYCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9