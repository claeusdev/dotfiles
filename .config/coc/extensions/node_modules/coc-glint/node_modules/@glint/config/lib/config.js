"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizePath = exports.GlintConfig = void 0;
const path_1 = __importDefault(require("path"));
const minimatch_1 = require("minimatch");
const environment_1 = require("./environment");
const silent_error_1 = __importDefault(require("silent-error"));
/**
 * This class represents a parsed `.glintrc` file, with methods for interrogating
 * project configuration based on the contents of the file.
 */
class GlintConfig {
    constructor(rootDir, config = {}) {
        var _a, _b;
        validateConfigInput(config);
        this.rootDir = normalizePath(rootDir);
        this.environment = environment_1.GlintEnvironment.load(config.environment, { rootDir });
        this.checkStandaloneTemplates = (_a = config.checkStandaloneTemplates) !== null && _a !== void 0 ? _a : true;
        let extensions = this.environment.getConfiguredFileExtensions();
        let include = Array.isArray(config.include)
            ? config.include
            : config.include
                ? [config.include]
                : extensions.map((ext) => `**/*${ext}`);
        let exclude = Array.isArray(config.exclude)
            ? config.exclude
            : [(_b = config.exclude) !== null && _b !== void 0 ? _b : '**/node_modules/**'];
        this.includeMatchers = this.buildMatchers(include);
        this.excludeMatchers = this.buildMatchers(exclude);
    }
    /**
     * Indicates whether this configuration object applies to the file at the
     * given path.
     */
    includesFile(rawFileName) {
        let fileName = normalizePath(rawFileName);
        return (this.excludeMatchers.every((matcher) => !matcher.match(fileName)) &&
            this.includeMatchers.some((matcher) => matcher.match(fileName)));
    }
    // Given the path of a template or script (potentially with a custom extension),
    // returns the corresponding .js or .ts path we present to the TS language service.
    getSynthesizedScriptPathForTS(filename) {
        let extension = path_1.default.extname(filename);
        let filenameWithoutExtension = filename.slice(0, filename.lastIndexOf(extension));
        switch (this.environment.getSourceKind(filename)) {
            case 'template':
                return `${filenameWithoutExtension}${this.checkStandaloneTemplates ? '.ts' : '.js'}`;
            case 'typed-script':
                return `${filenameWithoutExtension}.ts`;
            case 'untyped-script':
                return `${filenameWithoutExtension}.js`;
            default:
                return filename;
        }
    }
    buildMatchers(globs) {
        return globs.map((glob) => new minimatch_1.Minimatch(normalizePath(path_1.default.resolve(this.rootDir, glob))));
    }
}
exports.GlintConfig = GlintConfig;
function normalizePath(fileName) {
    if (path_1.default.sep !== '/') {
        return fileName.split(path_1.default.sep).join('/');
    }
    return fileName;
}
exports.normalizePath = normalizePath;
function validateConfigInput(input) {
    assert(Array.isArray(input['environment'])
        ? input['environment'].every((env) => typeof env === 'string')
        : typeof input['environment'] === 'string' ||
            (typeof input['environment'] === 'object' && input['environment']), 'Glint config must specify an `environment` that is a string, array of strings, or an object ' +
        'mapping environment names to their config.');
    assert(input['checkStandaloneTemplates'] === undefined ||
        typeof input['checkStandaloneTemplates'] === 'boolean', 'If defined, `checkStandaloneTemplates` must be a boolean');
    assert(Array.isArray(input['include'])
        ? input['include'].every((item) => typeof item === 'string')
        : !input['include'] || typeof input['include'] === 'string', 'If defined, `include` must be a string or array of strings');
    assert(Array.isArray(input['exclude'])
        ? input['exclude'].every((item) => typeof item === 'string')
        : !input['exclude'] || typeof input['exclude'] === 'string', 'If defined, `exclude` must be a string or array of strings');
}
function assert(test, message) {
    if (!test) {
        throw new silent_error_1.default(`@glint/config: ${message}`);
    }
}
//# sourceMappingURL=config.js.map