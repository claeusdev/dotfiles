"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bindLanguageServer = exports.capabilities = void 0;
const vscode_languageserver_1 = require("vscode-languageserver");
const scheduling_1 = require("../common/scheduling");
exports.capabilities = {
    textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Full,
    completionProvider: {
        resolveProvider: true,
    },
    referencesProvider: true,
    hoverProvider: true,
    definitionProvider: true,
    workspaceSymbolProvider: true,
    renameProvider: {
        prepareProvider: true,
    },
};
function bindLanguageServer(args) {
    let { connection, languageServer, openDocuments } = args;
    let { scheduleDiagnostics, captureErrors } = buildHelpers(args);
    connection.onInitialize(() => ({ capabilities: exports.capabilities }));
    openDocuments.onDidOpen(({ document }) => {
        languageServer.openFile(document.uri, document.getText());
        scheduleDiagnostics();
    });
    openDocuments.onDidClose(({ document }) => {
        languageServer.closeFile(document.uri);
    });
    openDocuments.onDidChangeContent(({ document }) => {
        languageServer.updateFile(document.uri, document.getText());
        scheduleDiagnostics();
    });
    connection.onPrepareRename(({ textDocument, position }) => {
        return captureErrors(() => languageServer.prepareRename(textDocument.uri, position));
    });
    connection.onRenameRequest(({ textDocument, position, newName }) => {
        return captureErrors(() => languageServer.getEditsForRename(textDocument.uri, position, newName));
    });
    connection.onCompletion(({ textDocument, position }) => {
        return captureErrors(() => languageServer.getCompletions(textDocument.uri, position));
    });
    connection.onCompletionResolve((item) => {
        var _a;
        return (_a = captureErrors(() => languageServer.getCompletionDetails(item))) !== null && _a !== void 0 ? _a : item;
    });
    connection.onHover(({ textDocument, position }) => {
        return captureErrors(() => languageServer.getHover(textDocument.uri, position));
    });
    connection.onDefinition(({ textDocument, position }) => {
        return captureErrors(() => languageServer.getDefinition(textDocument.uri, position));
    });
    connection.onReferences(({ textDocument, position }) => {
        return captureErrors(() => languageServer.getReferences(textDocument.uri, position));
    });
    connection.onWorkspaceSymbol(({ query }) => {
        return captureErrors(() => languageServer.findSymbols(query));
    });
    connection.onDidChangeWatchedFiles(({ changes }) => {
        for (let change of changes) {
            if (change.type === vscode_languageserver_1.FileChangeType.Created) {
                languageServer.watchedFileWasAdded(change.uri);
            }
            else if (change.type === vscode_languageserver_1.FileChangeType.Deleted) {
                languageServer.watchedFileWasRemoved(change.uri);
            }
            else {
                languageServer.watchedFileDidChange(change.uri);
            }
        }
        scheduleDiagnostics();
    });
}
exports.bindLanguageServer = bindLanguageServer;
function buildHelpers({ languageServer, openDocuments, connection }) {
    return {
        scheduleDiagnostics: (0, scheduling_1.debounce)(250, () => {
            for (let { uri } of openDocuments.all()) {
                try {
                    const diagnostics = languageServer.getDiagnostics(uri);
                    connection.sendDiagnostics({ uri, diagnostics });
                }
                catch (error) {
                    connection.sendDiagnostics({
                        uri,
                        diagnostics: [
                            {
                                range: { start: { line: 0, character: 0 }, end: { line: 0, character: 1 } },
                                message: 'Glint encountered an error computing diagnostics for this file. ' +
                                    'This is likely a bug in Glint; please file an issue, including any ' +
                                    'code and/or steps to follow to reproduce the error.\n\n' +
                                    errorMessage(error),
                            },
                        ],
                    });
                    connection.console.error(`Error getting diagnostics for ${uri}.\n${errorMessage(error)}`);
                }
            }
        }),
        captureErrors(callback) {
            try {
                return callback();
            }
            catch (error) {
                connection.console.error(errorMessage(error));
            }
        },
    };
}
function errorMessage(error) {
    return (error instanceof Error && error.stack) || `${error}`;
}
//# sourceMappingURL=binding.js.map