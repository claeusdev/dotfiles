"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapTemplateContents = exports.Identifier = void 0;
const syntax_1 = require("@glimmer/syntax");
const mapping_tree_1 = __importDefault(require("./mapping-tree"));
const util_1 = require("./util");
/**
 * @glimmer/syntax parses identifiers as strings. Aside from meaning
 * we often have to reverse engineer location information for them
 * by hand, it also means we can't treat mappings from identifiers
 * consistently with how we treat mappings from other AST nodes.
 *
 * This class just gives us a uniform way to store identifiers
 * or other nodes as the `source` for a mapping.
 */
class Identifier {
    constructor(name) {
        this.name = name;
        this.type = 'Identifier';
    }
}
exports.Identifier = Identifier;
/**
 * Given the text of an HBS template, invokes the given callback
 * with a set of tools to emit mapped contents corresponding to
 * that template, tracking the text emitted in order to provide
 * a mapping of ranges in the input to ranges in the output.
 */
function mapTemplateContents(template, callback) {
    let ast;
    let lineOffsets = calculateLineOffsets(template);
    try {
        ast = (0, syntax_1.preprocess)(template);
    }
    catch (error) {
        let message = getErrorMessage(error);
        let location;
        if (isHBSSyntaxError(error)) {
            location = {
                start: lineOffsets[error.hash.loc.first_line] + error.hash.loc.first_column,
                end: lineOffsets[error.hash.loc.last_line] + error.hash.loc.last_column,
            };
        }
        else {
            let match = /line (\d+) : column (\d+)/.exec(message);
            if (match) {
                let offset = lineOffsets[Number(match[1])] + Number(match[2]);
                location = { start: offset, end: offset };
            }
        }
        return {
            errors: [{ message, location }],
        };
    }
    let rangeForNode = buildRangeForNode(lineOffsets);
    let rangeForLine = (line) => {
        var _a;
        return ({
            start: lineOffsets[line],
            end: (_a = lineOffsets[line + 1]) !== null && _a !== void 0 ? _a : template.length,
        });
    };
    let segmentsStack = [[]];
    let mappingsStack = [[]];
    let indent = '';
    let offset = 0;
    let needsIndent = false;
    let errors = [];
    let directives = [];
    // Associates all content emitted during the given callback with the
    // given range in the template source and corresponding AST node.
    // If an exception is thrown while executing the callback, the error
    // will be captured and associated with the given range, and no content
    // will be emitted.
    let captureMapping = (hbsRange, source, allowEmpty, callback) => {
        let start = offset;
        let mappings = [];
        let segments = [];
        segmentsStack.unshift(segments);
        mappingsStack.unshift(mappings);
        try {
            callback();
        }
        catch (error) {
            errors.push({ message: getErrorMessage(error), location: hbsRange });
            offset = start;
        }
        mappingsStack.shift();
        segmentsStack.shift();
        // If the offset didn't change (either because nothing was emitted
        // or because an exception was thrown), don't add a new node to the
        // mapping tree or flush any new content.
        if (start !== offset || allowEmpty) {
            let end = offset;
            let tsRange = { start, end };
            mappingsStack[0].push(new mapping_tree_1.default(tsRange, hbsRange, mappings, source));
            segmentsStack[0].push(...segments);
        }
    };
    let record = {
        error(message, location) {
            errors.push({ message, location });
        },
        directive(kind, location, areaOfEffect) {
            directives.push({ kind, location, areaOfEffect });
        },
    };
    let emit = {
        indent() {
            indent += '  ';
        },
        dedent() {
            indent = indent.slice(2);
        },
        newline() {
            offset += 1;
            segmentsStack[0].push('\n');
            needsIndent = true;
        },
        text(value) {
            if (needsIndent) {
                offset += indent.length;
                segmentsStack[0].push(indent);
                needsIndent = false;
            }
            offset += value.length;
            segmentsStack[0].push(value);
        },
        synthetic(value) {
            if (value.length) {
                emit.identifier(value, 0, 0);
            }
        },
        nothing(node) {
            captureMapping(rangeForNode(node), node, true, () => { });
        },
        identifier(value, hbsOffset, hbsLength = value.length) {
            // If there's a pending indent, flush that so it's not included in
            // the range mapping for the identifier we're about to emit
            if (needsIndent) {
                emit.text('');
            }
            let hbsRange = { start: hbsOffset, end: hbsOffset + hbsLength };
            let source = new Identifier(value);
            captureMapping(hbsRange, source, true, () => emit.text(value));
        },
        forNode(node, callback) {
            captureMapping(rangeForNode(node), node, false, callback);
        },
    };
    callback(ast, { emit, record, rangeForLine, rangeForNode });
    (0, util_1.assert)(segmentsStack.length === 1);
    let code = segmentsStack[0].join('');
    let mapping = new mapping_tree_1.default({ start: 0, end: code.length }, rangeForNode(ast), mappingsStack[0], ast);
    return { errors, result: { code, directives, mapping } };
}
exports.mapTemplateContents = mapTemplateContents;
const LEADING_WHITESPACE = /^\s+/;
const TRAILING_WHITESPACE = /\s+$/;
function calculateLineOffsets(template) {
    let lines = template.split('\n');
    let total = 0;
    let offsets = [0];
    for (let [index, line] of lines.entries()) {
        // lines from @glimmer/syntax are 1-indexed
        offsets[index + 1] = total;
        total += line.length + 1;
    }
    return offsets;
}
function buildRangeForNode(offsets) {
    return (node) => {
        var _a, _b, _c, _d;
        let { loc } = node;
        let start = offsets[loc.start.line] + loc.start.column;
        let end = offsets[loc.end.line] + loc.end.column;
        // This makes error reporting for illegal text nodes (e.g. alongside named blocks)
        // a bit nicer by only highlighting the content rather than all the surrounding
        // newlines and attendant whitespace
        if (node.type === 'TextNode') {
            let leading = (_b = (_a = LEADING_WHITESPACE.exec(node.chars)) === null || _a === void 0 ? void 0 : _a[0].length) !== null && _b !== void 0 ? _b : 0;
            let trailing = (_d = (_c = TRAILING_WHITESPACE.exec(node.chars)) === null || _c === void 0 ? void 0 : _c[0].length) !== null && _d !== void 0 ? _d : 0;
            if (leading !== node.chars.length) {
                start += leading;
                end -= trailing;
            }
        }
        return { start, end };
    };
}
function getErrorMessage(error) {
    var _a;
    return (_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : '(unknown error)';
}
function isHBSSyntaxError(error) {
    if (typeof error === 'object' && !!error && 'hash' in error) {
        let { hash } = error;
        return typeof (hash === null || hash === void 0 ? void 0 : hash.loc) === 'object';
    }
    return false;
}
//# sourceMappingURL=map-template-contents.js.map