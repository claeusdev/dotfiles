"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContainingTypeInfo = void 0;
/**
 * Given an AST node for an embedded template, determines the appropriate
 * instance type to be passed to `@glint/template`'s `ResolveContext`, as well
 * as any type parameters that need to be propagated as inputs to the template's
 * root generator function.
 *
 * For example, a template declared within `class MyComponent<T extends string>`
 * would give `MyComponent<T>` as the context type, and `<T extends string>` as
 * the type params, ultimately resulting in a template function like:
 *
 *     template(function*<T extends string>(ùö™: ResolveContext<MyComponent<T>>){
 *       // ...
 *     })
 */
function getContainingTypeInfo(ts, node) {
    var _a;
    let container = findContainingClass(ts, node);
    let inClass = Boolean(container);
    let className = (_a = container === null || container === void 0 ? void 0 : container.name) === null || _a === void 0 ? void 0 : _a.text;
    let contextType = className;
    let typeParams = undefined;
    if (container === null || container === void 0 ? void 0 : container.typeParameters) {
        let params = container.typeParameters;
        typeParams = `<${params.map((param) => param.getText()).join(', ')}>`;
        contextType += `<${params.map((param) => param.name.getText()).join(', ')}>`;
    }
    return { contextType, typeParams, className, inClass };
}
exports.getContainingTypeInfo = getContainingTypeInfo;
function findContainingClass(ts, node) {
    let current = node;
    do {
        if (ts.isClassLike(current)) {
            return current;
        }
    } while ((current = current.parent));
    return null;
}
//# sourceMappingURL=index.js.map