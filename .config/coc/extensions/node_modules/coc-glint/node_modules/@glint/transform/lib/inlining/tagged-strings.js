"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateTaggedTemplateSpans = void 0;
const _1 = require(".");
const template_to_typescript_1 = require("../template-to-typescript");
const util_1 = require("../util");
function calculateTaggedTemplateSpans(ts, node, meta, script, environment) {
    var _a, _b;
    let directives = [];
    let errors = [];
    let partialSpans = [];
    let tag = node.tag;
    if (!ts.isIdentifier(tag)) {
        return { errors, directives, partialSpans };
    }
    let info = resolveTagInfo(ts, tag, environment);
    if (info) {
        (0, util_1.assert)(ts.isNoSubstitutionTemplateLiteral(node.template), 'No interpolated values in template strings');
        let { typesSource, globals } = info.tagConfig;
        let tagName = tag.text;
        let contents = (_a = node.template.rawText) !== null && _a !== void 0 ? _a : node.template.text;
        // Pad the template to account for the tag and surrounding ` characters
        let template = `${''.padStart(tagName.length)} ${contents} `;
        // environment-specific transforms may emit templateLocation in meta, in
        // which case we use that. Otherwise we use the reported location from the
        // node itself (which is presumably correct because no transform has messed
        // with it).
        let templateLocation = (_b = meta === null || meta === void 0 ? void 0 : meta.templateLocation) !== null && _b !== void 0 ? _b : {
            start: node.getStart(),
            end: node.getEnd(),
        };
        let preamble = [];
        if (!info.importedBinding.synthetic) {
            preamble.push(`${tagName};`);
        }
        let { inClass, className, typeParams, contextType } = (0, _1.getContainingTypeInfo)(ts, node);
        let transformedTemplate = (0, template_to_typescript_1.templateToTypescript)(template, {
            typesPath: typesSource,
            meta,
            preamble,
            globals,
            typeParams,
            contextType,
            useJsDoc: environment.isUntypedScript(script.filename),
        });
        if (inClass && !className) {
            errors.push({
                source: script,
                message: 'Classes containing templates must have a name',
                location: templateLocation,
            });
        }
        for (let { message, location } of transformedTemplate.errors) {
            if (location) {
                errors.push({
                    source: script,
                    message,
                    location: addOffset(location, templateLocation.start),
                });
            }
            else {
                errors.push({
                    source: script,
                    message,
                    location: {
                        start: tag.getStart(),
                        end: tag.getEnd(),
                    },
                });
            }
        }
        if (transformedTemplate.result) {
            for (let { kind, location, areaOfEffect } of transformedTemplate.result.directives) {
                directives.push({
                    kind: kind,
                    source: script,
                    location: addOffset(location, templateLocation.start),
                    areaOfEffect: addOffset(areaOfEffect, templateLocation.start),
                });
            }
            partialSpans.push({
                originalFile: script,
                originalStart: templateLocation.start,
                originalLength: templateLocation.end - templateLocation.start,
                insertionPoint: templateLocation.start,
                transformedSource: transformedTemplate.result.code,
                mapping: transformedTemplate.result.mapping,
            });
        }
    }
    return { errors, directives, partialSpans };
}
exports.calculateTaggedTemplateSpans = calculateTaggedTemplateSpans;
function addOffset(location, offset) {
    return {
        start: location.start + offset,
        end: location.end + offset,
    };
}
function resolveTagInfo(ts, tag, environment) {
    let importedBindings = collectImportedBindings(ts, tag.getSourceFile());
    let importedBinding = importedBindings[tag.text];
    if (!importedBinding) {
        return;
    }
    for (let [importSource, tags] of Object.entries(environment.getConfiguredTemplateTags())) {
        for (let [importSpecifier, tagConfig] of Object.entries(tags)) {
            if (importSource === importedBinding.source &&
                importSpecifier === importedBinding.specifier) {
                return { importedBinding, tagConfig };
            }
        }
    }
}
function collectImportedBindings(ts, sourceFile) {
    var _a, _b;
    let result = {};
    for (let statement of sourceFile.statements) {
        if (ts.isImportDeclaration(statement)) {
            (0, util_1.assert)(ts.isStringLiteral(statement.moduleSpecifier));
            let { importClause } = statement;
            if (!importClause)
                continue;
            let synthetic = statement.pos === statement.end;
            if (importClause.name) {
                result[importClause.name.text] = {
                    specifier: 'default',
                    source: statement.moduleSpecifier.text,
                    synthetic,
                };
            }
            if (importClause.namedBindings && ts.isNamedImports(importClause.namedBindings)) {
                for (let binding of importClause.namedBindings.elements) {
                    result[binding.name.text] = {
                        specifier: (_b = (_a = binding.propertyName) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : binding.name.text,
                        source: statement.moduleSpecifier.text,
                        synthetic,
                    };
                }
            }
        }
    }
    return result;
}
//# sourceMappingURL=tagged-strings.js.map