import type ts from 'typescript';
import { CorrelatedSpan, Directive, TransformError } from '../transformed-module';
import { TSLib } from '../util';
export declare type PartialCorrelatedSpan = Omit<CorrelatedSpan, 'transformedStart' | 'transformedLength'>;
export declare type CorrelatedSpansResult = {
    errors: Array<TransformError>;
    directives: Array<Directive>;
    partialSpans: Array<PartialCorrelatedSpan>;
};
export declare type ContainingTypeInfo = {
    inClass: boolean;
    className: string | undefined;
    contextType: string | undefined;
    typeParams: string | undefined;
};
/**
 * Given an AST node for an embedded template, determines the appropriate
 * instance type to be passed to `@glint/template`'s `ResolveContext`, as well
 * as any type parameters that need to be propagated as inputs to the template's
 * root generator function.
 *
 * For example, a template declared within `class MyComponent<T extends string>`
 * would give `MyComponent<T>` as the context type, and `<T extends string>` as
 * the type params, ultimately resulting in a template function like:
 *
 *     template(function*<T extends string>(ùö™: ResolveContext<MyComponent<T>>){
 *       // ...
 *     })
 */
export declare function getContainingTypeInfo(ts: TSLib, node: ts.Node): ContainingTypeInfo;
