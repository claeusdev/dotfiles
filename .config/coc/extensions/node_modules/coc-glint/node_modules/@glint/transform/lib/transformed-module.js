"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
/**
 * This class represents the result of transforming a TypeScript
 * module with one or more embedded HBS templates. It contains
 * both the original and transformed source text of the module, as
 * well any errors encountered during transformation.
 *
 * It can be queried with an offset or range in either the
 * original or transformed source to determine the corresponding
 * offset or range in the other.
 */
class TransformedModule {
    constructor(transformedContents, errors, directives, correlatedSpans) {
        this.transformedContents = transformedContents;
        this.errors = errors;
        this.directives = directives;
        this.correlatedSpans = correlatedSpans;
    }
    toDebugString() {
        let mappingStrings = this.correlatedSpans.map((span) => {
            var _a;
            return (_a = span.mapping) === null || _a === void 0 ? void 0 : _a.toDebugString({
                originalStart: span.originalStart,
                originalSource: span.originalFile.contents.slice(span.originalStart, span.originalStart + span.originalLength),
                transformedStart: span.transformedStart,
                transformedSource: span.transformedSource,
            });
        });
        return `TransformedModule\n\n${mappingStrings.filter(Boolean).join('\n\n')}`;
    }
    getOriginalOffset(transformedOffset) {
        let { start, source } = this.getOriginalRange(transformedOffset, transformedOffset);
        return { source, offset: start };
    }
    getTransformedOffset(originalFileName, originalOffset) {
        return this.getTransformedRange(originalFileName, originalOffset, originalOffset).start;
    }
    getOriginalRange(transformedStart, transformedEnd) {
        var _a;
        let startInfo = this.determineOriginalOffsetAndSpan(transformedStart);
        let endInfo = this.determineOriginalOffsetAndSpan(transformedEnd);
        (0, util_1.assert)(startInfo.correlatedSpan.originalFile === endInfo.correlatedSpan.originalFile, 'Attempted to transform a range across two different files');
        let source = startInfo.correlatedSpan.originalFile;
        let start = startInfo.originalOffset;
        let end = endInfo.originalOffset;
        if (startInfo.correlatedSpan === endInfo.correlatedSpan) {
            let { correlatedSpan } = startInfo;
            let mapping = (_a = correlatedSpan.mapping) === null || _a === void 0 ? void 0 : _a.narrowestMappingForTransformedRange({
                start: start - correlatedSpan.originalStart,
                end: end - correlatedSpan.originalStart,
            });
            if (mapping) {
                let start = correlatedSpan.originalStart + mapping.originalRange.start;
                let end = correlatedSpan.originalStart + mapping.originalRange.end;
                return { mapping, start, end, source };
            }
        }
        return { start, end, source };
    }
    getTransformedRange(originalFileName, originalStart, originalEnd) {
        var _a;
        let startInfo = this.determineTransformedOffsetAndSpan(originalFileName, originalStart);
        let endInfo = this.determineTransformedOffsetAndSpan(originalFileName, originalEnd);
        let start = startInfo.transformedOffset;
        let end = endInfo.transformedOffset;
        if (startInfo.correlatedSpan && startInfo.correlatedSpan === endInfo.correlatedSpan) {
            let { correlatedSpan } = startInfo;
            let mapping = (_a = correlatedSpan.mapping) === null || _a === void 0 ? void 0 : _a.narrowestMappingForOriginalRange({
                start: start - correlatedSpan.transformedStart,
                end: end - correlatedSpan.transformedStart,
            });
            if (mapping) {
                let start = correlatedSpan.transformedStart + mapping.transformedRange.start;
                let end = correlatedSpan.transformedStart + mapping.transformedRange.end;
                return { mapping, start, end };
            }
        }
        return { start, end };
    }
    determineOriginalOffsetAndSpan(transformedOffset) {
        for (let span of this.correlatedSpans) {
            if (transformedOffset >= span.transformedStart &&
                transformedOffset < span.transformedStart + span.transformedLength) {
                return {
                    originalOffset: transformedOffset - span.transformedStart + span.originalStart,
                    correlatedSpan: span,
                };
            }
        }
        (0, util_1.assert)(false, 'Internal error: offset out of bounds');
    }
    determineTransformedOffsetAndSpan(originalFileName, originalOffset) {
        for (let span of this.correlatedSpans) {
            if (span.originalFile.filename === originalFileName &&
                originalOffset >= span.originalStart &&
                originalOffset < span.originalStart + span.originalLength) {
                return {
                    transformedOffset: originalOffset - span.originalStart + span.transformedStart,
                    correlatedSpan: span,
                };
            }
        }
        (0, util_1.assert)(false, 'Internal error: offset out of bounds');
    }
}
exports.default = TransformedModule;
//# sourceMappingURL=transformed-module.js.map