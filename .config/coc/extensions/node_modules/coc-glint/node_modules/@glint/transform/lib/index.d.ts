import type ts from 'typescript';
import { GlintEnvironment } from '@glint/config';
import { TSLib } from './util';
import TransformedModule, { SourceFile, Directive, Range } from './transformed-module';
export { TransformedModule, Directive, Range, SourceFile };
/**
 * Given a TypeScript diagnostic object from a module that was rewritten
 * by `rewriteModule`, as well as the resulting `TransformedModule`, returns
 * a rewritten version of that diagnostic that maps to the corresponding
 * location in the original source file.
 */
export declare function rewriteDiagnostic<T extends ts.DiagnosticWithLocation | ts.DiagnosticRelatedInformation>(ts: TSLib, transformedDiagnostic: T, locateTransformedModule: (fileName: string) => TransformedModule | null | undefined): T;
export declare type Diagnostic = ts.Diagnostic & {
    isGlintTransformDiagnostic?: boolean;
};
export declare function createTransformDiagnostic(ts: TSLib, source: SourceFile, message: string, location: Range): Diagnostic;
/**
 * Input to the process of rewriting a template, containing one or both of:
 *   script: the backing JS/TS module for a component, which may contain
 *           embedded templates depending on the environment
 *   template: a standalone template file
 */
export declare type RewriteInput = {
    script: SourceFile;
    template?: SourceFile;
};
/**
 * Given the script and/or template that together comprise a component module,
 * returns a `TransformedModule` representing the combined result, with the
 * template(s), either alongside or inline, rewritten into equivalent TypeScript
 * in terms of the active glint environment's exported types.
 *
 * May return `null` if an unrecoverable parse error occurs or if there is
 * no transformation to be done.
 */
export declare function rewriteModule(ts: TSLib, { script, template }: RewriteInput, environment: GlintEnvironment): TransformedModule | null;
