"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rewriteModule = exports.createTransformDiagnostic = exports.rewriteDiagnostic = exports.TransformedModule = void 0;
const path_1 = __importDefault(require("path"));
const util_1 = require("./util");
const transformed_module_1 = __importDefault(require("./transformed-module"));
exports.TransformedModule = transformed_module_1.default;
const tagged_strings_1 = require("./inlining/tagged-strings");
const companion_file_1 = require("./inlining/companion-file");
/**
 * Given a TypeScript diagnostic object from a module that was rewritten
 * by `rewriteModule`, as well as the resulting `TransformedModule`, returns
 * a rewritten version of that diagnostic that maps to the corresponding
 * location in the original source file.
 */
function rewriteDiagnostic(ts, transformedDiagnostic, locateTransformedModule) {
    (0, util_1.assert)(transformedDiagnostic.file);
    (0, util_1.assert)(transformedDiagnostic.start);
    (0, util_1.assert)(transformedDiagnostic.length);
    let transformedModule = locateTransformedModule(transformedDiagnostic.file.fileName);
    if (!transformedModule) {
        return transformedDiagnostic;
    }
    let { start, end, source } = transformedModule.getOriginalRange(transformedDiagnostic.start, transformedDiagnostic.start + transformedDiagnostic.length);
    let length = end - start;
    let diagnostic = {
        // This cast is safe (it's the declared parameter type), but needed as of 4.3.0-dev.20210322
        ...transformedDiagnostic,
        start,
        length,
        file: (0, util_1.createSyntheticSourceFile)(ts, source),
    };
    if (hasRelatedInformation(diagnostic) && diagnostic.relatedInformation) {
        diagnostic.relatedInformation = diagnostic.relatedInformation.map((relatedInfo) => rewriteDiagnostic(ts, relatedInfo, locateTransformedModule));
    }
    return diagnostic;
}
exports.rewriteDiagnostic = rewriteDiagnostic;
function createTransformDiagnostic(ts, source, message, location) {
    return {
        isGlintTransformDiagnostic: true,
        category: ts.DiagnosticCategory.Error,
        code: 0,
        file: (0, util_1.createSyntheticSourceFile)(ts, source),
        start: location.start,
        length: location.end - location.start,
        messageText: message,
    };
}
exports.createTransformDiagnostic = createTransformDiagnostic;
function hasRelatedInformation(value) {
    return 'relatedInformation' in value && Boolean(value.relatedInformation);
}
/**
 * Given the script and/or template that together comprise a component module,
 * returns a `TransformedModule` representing the combined result, with the
 * template(s), either alongside or inline, rewritten into equivalent TypeScript
 * in terms of the active glint environment's exported types.
 *
 * May return `null` if an unrecoverable parse error occurs or if there is
 * no transformation to be done.
 */
function rewriteModule(ts, { script, template }, environment) {
    var _a, _b;
    let { errors, directives, partialSpans } = calculateCorrelatedSpans(ts, script, template, environment);
    if (!partialSpans.length && !errors.length) {
        return null;
    }
    let sparseSpans = completeCorrelatedSpans(partialSpans);
    let { contents, correlatedSpans } = calculateTransformedSource(script, sparseSpans);
    (_b = (_a = globalThis).GLINT_DEBUG_IR) === null || _b === void 0 ? void 0 : _b.call(_a, script.filename, contents);
    return new transformed_module_1.default(contents, errors, directives, correlatedSpans);
}
exports.rewriteModule = rewriteModule;
/**
 * Locates any embedded templates in the given AST and returns a corresponding
 * `PartialReplacedSpan` for each, as well as any errors encountered. These
 * spans are then used in `rewriteModule` above to calculate the full set of
 * source-to-source location information as well as the final transformed source
 * string.
 */
function calculateCorrelatedSpans(ts, script, template, environment) {
    let directives = [];
    let errors = [];
    let partialSpans = [];
    let { ast, emitMetadata } = parseScript(ts, script, environment);
    ts.transform(ast, [
        (context) => function visit(node) {
            if (ts.isTaggedTemplateExpression(node)) {
                let meta = emitMetadata.get(node);
                let result = (0, tagged_strings_1.calculateTaggedTemplateSpans)(ts, node, meta, script, environment);
                directives.push(...result.directives);
                errors.push(...result.errors);
                partialSpans.push(...result.partialSpans);
            }
            else if (ts.isModuleDeclaration(node)) {
                // don't traverse into declare module
                return node;
            }
            return ts.visitEachChild(node, visit, context);
        },
    ]);
    if (template) {
        let result = (0, companion_file_1.calculateCompanionTemplateSpans)(ts, ast, script, template, environment);
        directives.push(...result.directives);
        errors.push(...result.errors);
        partialSpans.push(...result.partialSpans);
    }
    return { errors, directives, partialSpans };
}
function parseScript(ts, script, environment) {
    var _a, _b;
    let { filename, contents } = script;
    let extension = path_1.default.extname(filename);
    let emitMetadata = new WeakMap();
    let setEmitMetadata = (node, data) => { var _a; return void emitMetadata.set(node, Object.assign((_a = emitMetadata.get(node)) !== null && _a !== void 0 ? _a : {}, data)); };
    let { preprocess, transform } = (_a = environment.getConfigForExtension(extension)) !== null && _a !== void 0 ? _a : {};
    let preprocessed = (_b = preprocess === null || preprocess === void 0 ? void 0 : preprocess(contents, filename)) !== null && _b !== void 0 ? _b : { contents };
    let ast = ts.createSourceFile(filename, preprocessed.contents, ts.ScriptTarget.Latest, true // setParentNodes
    );
    if (transform) {
        let { transformed } = ts.transform(ast, [
            (context) => transform(preprocessed.data, { ts, context, setEmitMetadata }),
        ]);
        (0, util_1.assert)(transformed.length === 1 && ts.isSourceFile(transformed[0]));
        ast = transformed[0];
    }
    return { ast, emitMetadata };
}
/**
 * Given a sparse `CorrelatedSpan` array and the original source for a module,
 * returns the resulting full transformed source string for that module, as
 * well as a filled-in array of correlated spans that includes chunks of the
 * original source that were not transformed.
 */
function calculateTransformedSource(originalFile, sparseSpans) {
    let correlatedSpans = [];
    let originalOffset = 0;
    let transformedOffset = 0;
    for (let span of sparseSpans) {
        let interstitial = originalFile.contents.slice(originalOffset, span.insertionPoint);
        if (interstitial.length) {
            correlatedSpans.push({
                originalFile,
                originalStart: originalOffset,
                originalLength: interstitial.length,
                insertionPoint: originalOffset,
                transformedStart: transformedOffset,
                transformedLength: interstitial.length,
                transformedSource: interstitial,
            });
        }
        correlatedSpans.push(span);
        transformedOffset += interstitial.length + span.transformedLength;
        originalOffset +=
            interstitial.length + (span.originalFile === originalFile ? span.originalLength : 0);
    }
    let trailingContent = originalFile.contents.slice(originalOffset);
    correlatedSpans.push({
        originalFile,
        originalStart: originalOffset,
        originalLength: trailingContent.length + 1,
        insertionPoint: originalOffset,
        transformedStart: transformedOffset,
        transformedLength: trailingContent.length + 1,
        transformedSource: trailingContent,
    });
    return {
        contents: correlatedSpans.map((span) => span.transformedSource).join(''),
        correlatedSpans,
    };
}
/**
 * Given an array of `PartialCorrelatedSpan`s for a file, calculates
 * their `transformedLength` and `transformedStart` values, resulting
 * in full `ReplacedSpan`s.
 */
function completeCorrelatedSpans(partialSpans) {
    let replacedSpans = [];
    for (let i = 0; i < partialSpans.length; i++) {
        let current = partialSpans[i];
        let transformedLength = current.transformedSource.length;
        let transformedStart = current.insertionPoint;
        if (i > 0) {
            let previous = replacedSpans[i - 1];
            transformedStart =
                previous.transformedStart +
                    previous.transformedSource.length +
                    (current.insertionPoint - previous.insertionPoint - previous.originalLength);
        }
        replacedSpans.push({ ...current, transformedStart, transformedLength });
    }
    return replacedSpans;
}
//# sourceMappingURL=index.js.map