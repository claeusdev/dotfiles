"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.COMMANDS = void 0;
exports.activate = activate;

var _coc = require("coc.nvim");

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const languageServerPath = ['node_modules', '@lifeart', 'ember-language-server'];
const serverBin = ['lib', 'start-server.js'];
const addonPath = ['lib', 'addons']; // https://github.com/lifeart/vscode-ember/blob/master/src/constants.ts

const COMMANDS = {
  OPEN_RELATED_FILE: 'els.openRelatedFile',
  RELOAD_PROJECT: 'els.reloadProject',
  SET_STATUS_BAR_TEXT: 'els.setStatusBarText',
  RUN_IN_EMBER_CLI: 'els.runInEmberCLI',
  GET_USER_INPUT: 'els.getUserInput',
  EXECUTE_IN_EMBER_CLI: 'els.executeInEmberCLI',
  SET_CONFIG: 'els.setConfig',
  GET_RELATED_FILES: 'els.getRelatedFiles',
  GET_KIND_USAGES: 'els.getKindUsages'
};
exports.COMMANDS = COMMANDS;

async function activate(context) {
  try {
    await boot(context);
  } catch (e) {
    console.error(e);
    throw e;
  }
}

async function boot(context) {
  let config = getConfig();
  let isEnabled = config.get('enable', true);
  let isDebugging = config.get('debug', false);
  if (!isEnabled) return;
  let isEmberCli = await isEmberCliProject(); // Not really an error, but this is important information for the first phase of debugging.

  console.info('isEmberCli', isEmberCli);

  if (!isEmberCli) {
    return;
  }

  let client = await startLanguageServerClient(context, isDebugging);
  console.info('Configuring LanguageServerClient...');
  configureClient(client, context);
}

async function startLanguageServerClient(context, isDebugging = false) {
  let binPath = context.asAbsolutePath(_path.default.join(...languageServerPath, ...serverBin));
  console.info('UELS bin @', binPath);
  let debugOptions = isDebugging ? {
    execArgv: ['--nolazy', '--inspect=6004']
  } : {}; // If the extension is launched in debug mode then the debug
  // server options are used...
  // Otherwise the run options are used

  let serverOptions = {
    run: {
      module: binPath,
      transport: _coc.TransportKind.ipc
    },
    debug: {
      module: binPath,
      transport: _coc.TransportKind.ipc,
      options: debugOptions
    }
  };
  let clientOptions = buildClientOptions();
  let client = new _coc.LanguageClient('ember-language-server', 'Ember Language Server', serverOptions, clientOptions);
  context.subscriptions.push(_coc.services.registLanguageClient(client));
  await client.onReady();
  return client;
}

function configureClient(client, context) {
  let addonsRelPath = _path.default.join(...addonPath);

  let addonAbsolutePath = context.asAbsolutePath(addonsRelPath);
  console.info('UELS Addons @', addonAbsolutePath);
  let cocUELSConfig = insertLocalAddonPath(addonAbsolutePath);

  _coc.commands.executeCommand(COMMANDS.SET_CONFIG, cocUELSConfig);

  let {
    nvim
  } = _coc.workspace;
  context.subscriptions.push(_coc.commands.registerCommand(COMMANDS.GET_USER_INPUT, async (opts, callbackName, tail) => {
    try {
      console.info('Getting user input...');
      let name = await nvim.call('input', ['Component Name', '']);
      let document = tail.uri;
      console.info(callbackName, document, name, tail);
      await _coc.commands.executeCommand(callbackName, document, name, tail); // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (e) {
      _coc.window.showMessage(e.toString(), 'error');
    }
  }));
}

function insertLocalAddonPath(addonPath) {
  let config = getUELSConfig();
  let local = config.local || {};
  let addons = local.addons || [];
  let addonPaths = (0, _fs.readdirSync)(_path.default.join(addonPath, 'node_modules'), {
    withFileTypes: true
  }).filter(dirent => dirent.isDirectory()).map(dirent => dirent.name).filter(name => name.startsWith('els-')).map(addonName => _path.default.join(addonPath, 'node_modules', addonName));
  console.info(addonPaths);
  return _objectSpread(_objectSpread({}, config), {}, {
    local: _objectSpread(_objectSpread({}, local), {}, {
      addons: [...addons, ...addonPaths]
    })
  });
}

function getConfig() {
  let config = _coc.workspace.getConfiguration('ember');

  return config;
}

function getUELSConfig() {
  let config = _coc.workspace.getConfiguration('els');

  return config;
}

function buildClientOptions() {
  return {
    documentSelector: ['hbs', 'html.handlebars', 'handlebars', 'typescript', 'javascript', 'typescript.glimmer', 'javascript.glimmer'],
    initializationOptions: {
      editor: 'vscode' // hack

    },
    outputChannelName: 'ember-language-server'
  };
}

async function isEmberCliProject() {
  let emberCliBuildFile = await _coc.workspace.findUp('ember-cli-build.js');
  return !!emberCliBuildFile;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJsYW5ndWFnZVNlcnZlclBhdGgiLCJzZXJ2ZXJCaW4iLCJhZGRvblBhdGgiLCJDT01NQU5EUyIsIk9QRU5fUkVMQVRFRF9GSUxFIiwiUkVMT0FEX1BST0pFQ1QiLCJTRVRfU1RBVFVTX0JBUl9URVhUIiwiUlVOX0lOX0VNQkVSX0NMSSIsIkdFVF9VU0VSX0lOUFVUIiwiRVhFQ1VURV9JTl9FTUJFUl9DTEkiLCJTRVRfQ09ORklHIiwiR0VUX1JFTEFURURfRklMRVMiLCJHRVRfS0lORF9VU0FHRVMiLCJhY3RpdmF0ZSIsImNvbnRleHQiLCJib290IiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImNvbmZpZyIsImdldENvbmZpZyIsImlzRW5hYmxlZCIsImdldCIsImlzRGVidWdnaW5nIiwiaXNFbWJlckNsaSIsImlzRW1iZXJDbGlQcm9qZWN0IiwiaW5mbyIsImNsaWVudCIsInN0YXJ0TGFuZ3VhZ2VTZXJ2ZXJDbGllbnQiLCJjb25maWd1cmVDbGllbnQiLCJiaW5QYXRoIiwiYXNBYnNvbHV0ZVBhdGgiLCJwYXRoIiwiam9pbiIsImRlYnVnT3B0aW9ucyIsImV4ZWNBcmd2Iiwic2VydmVyT3B0aW9ucyIsInJ1biIsIm1vZHVsZSIsInRyYW5zcG9ydCIsIlRyYW5zcG9ydEtpbmQiLCJpcGMiLCJkZWJ1ZyIsIm9wdGlvbnMiLCJjbGllbnRPcHRpb25zIiwiYnVpbGRDbGllbnRPcHRpb25zIiwiTGFuZ3VhZ2VDbGllbnQiLCJzdWJzY3JpcHRpb25zIiwicHVzaCIsInNlcnZpY2VzIiwicmVnaXN0TGFuZ3VhZ2VDbGllbnQiLCJvblJlYWR5IiwiYWRkb25zUmVsUGF0aCIsImFkZG9uQWJzb2x1dGVQYXRoIiwiY29jVUVMU0NvbmZpZyIsImluc2VydExvY2FsQWRkb25QYXRoIiwiY29tbWFuZHMiLCJleGVjdXRlQ29tbWFuZCIsIm52aW0iLCJ3b3Jrc3BhY2UiLCJyZWdpc3RlckNvbW1hbmQiLCJvcHRzIiwiY2FsbGJhY2tOYW1lIiwidGFpbCIsIm5hbWUiLCJjYWxsIiwiZG9jdW1lbnQiLCJ1cmkiLCJ3aW5kb3ciLCJzaG93TWVzc2FnZSIsInRvU3RyaW5nIiwiZ2V0VUVMU0NvbmZpZyIsImxvY2FsIiwiYWRkb25zIiwiYWRkb25QYXRocyIsIndpdGhGaWxlVHlwZXMiLCJmaWx0ZXIiLCJkaXJlbnQiLCJpc0RpcmVjdG9yeSIsIm1hcCIsInN0YXJ0c1dpdGgiLCJhZGRvbk5hbWUiLCJnZXRDb25maWd1cmF0aW9uIiwiZG9jdW1lbnRTZWxlY3RvciIsImluaXRpYWxpemF0aW9uT3B0aW9ucyIsImVkaXRvciIsIm91dHB1dENoYW5uZWxOYW1lIiwiZW1iZXJDbGlCdWlsZEZpbGUiLCJmaW5kVXAiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7QUFTQSxNQUFNQSxrQkFBa0IsR0FBRyxDQUFDLGNBQUQsRUFBaUIsVUFBakIsRUFBNkIsdUJBQTdCLENBQTNCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLENBQUMsS0FBRCxFQUFRLGlCQUFSLENBQWxCO0FBQ0EsTUFBTUMsU0FBUyxHQUFHLENBQUMsS0FBRCxFQUFRLFFBQVIsQ0FBbEIsQyxDQUVBOztBQUNPLE1BQU1DLFFBQVEsR0FBRztBQUN0QkMsRUFBQUEsaUJBQWlCLEVBQUUscUJBREc7QUFFdEJDLEVBQUFBLGNBQWMsRUFBRSxtQkFGTTtBQUd0QkMsRUFBQUEsbUJBQW1CLEVBQUUsc0JBSEM7QUFJdEJDLEVBQUFBLGdCQUFnQixFQUFFLG1CQUpJO0FBS3RCQyxFQUFBQSxjQUFjLEVBQUUsa0JBTE07QUFNdEJDLEVBQUFBLG9CQUFvQixFQUFFLHVCQU5BO0FBT3RCQyxFQUFBQSxVQUFVLEVBQUUsZUFQVTtBQVF0QkMsRUFBQUEsaUJBQWlCLEVBQUUscUJBUkc7QUFTdEJDLEVBQUFBLGVBQWUsRUFBRTtBQVRLLENBQWpCOzs7QUFZQSxlQUFlQyxRQUFmLENBQXdCQyxPQUF4QixFQUFrRTtBQUN2RSxNQUFJO0FBQ0YsVUFBTUMsSUFBSSxD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QWVEOztBQUVELGVBQWU3RCxpQkFBZixHQUFxRDtBQUNuRCxNQUFJOEQsaUJBQWlCLEdBQUcsTUFBTTVCLGVBQVU2QixNQUFWLENBQWlCLG9CQUFqQixDQUE5QjtBQUVBLFNBQU8sQ0FBQyxDQUFDRCxpQkFBVDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY29tbWFuZHMsIExhbmd1YWdlQ2xpZW50LCBzZXJ2aWNlcywgVHJhbnNwb3J0S2luZCwgd2luZG93LCB3b3Jrc3BhY2UgfSBmcm9tICdjb2MubnZpbSc7XG5pbXBvcnQgeyByZWFkZGlyU3luYyB9IGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgdHlwZSB7XG4gIEV4dGVuc2lvbkNvbnRleHQsXG4gIExhbmd1YWdlQ2xpZW50T3B0aW9ucyxcbiAgU2VydmVyT3B0aW9ucyxcbiAgV29ya3NwYWNlQ29uZmlndXJhdGlvbixcbn0gZnJvbSAnY29jLm52aW0nO1xuXG5jb25zdCBsYW5ndWFnZVNlcnZlclBhdGggPSBbJ25vZGVfbW9kdWxlcycsICdAbGlmZWFydCcsICdlbWJlci1sYW5ndWFnZS1zZXJ2ZXInXTtcbmNvbnN0IHNlcnZlckJpbiA9IFsnbGliJywgJ3N0YXJ0LXNlcnZlci5qcyddO1xuY29uc3QgYWRkb25QYXRoID0gWydsaWInLCAnYWRkb25zJ107XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9saWZlYXJ0L3ZzY29kZS1lbWJlci9ibG9iL21hc3Rlci9zcmMvY29uc3RhbnRzLnRzXG5leHBvcnQgY29uc3QgQ09NTUFORFMgPSB7XG4gIE9QRU5fUkVMQVRFRF9GSUxFOiAnZWxzLm9wZW5SZWxhdGVkRmlsZScsXG4gIFJFTE9BRF9QUk9KRUNUOiAnZWxzLnJlbG9hZFByb2plY3QnLFxuICBTRVRfU1RBVFVTX0JBUl9URVhUOiAnZWxzLnNldFN0YXR1c0JhclRleHQnLFxuICBSVU5fSU5fRU1CRVJfQ0xJOiAnZWxzLnJ1bkluRW1iZXJDTEknLFxuICBHRVRfVVNFUl9JTlBVVDogJ2Vscy5nZXRVc2VySW5wdXQnLFxuICBFWEVDVVRFX0lOX0VNQkVSX0NMSTogJ2Vscy5leGVjdXRlSW5FbWJlckNMSScsXG4gIFNFVF9DT05GSUc6ICdlbHMuc2V0Q29uZmlnJyxcbiAgR0VUX1JFTEFURURfRklMRVM6ICdlbHMuZ2V0UmVsYXRlZEZpbGVzJyxcbiAgR0VUX0tJTkRfVVNBR0VTOiAnZWxzLmdldEtpbmRVc2FnZXMnLFxufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFjdGl2YXRlKGNvbnRleHQ6IEV4dGVuc2lvbkNvbnRleHQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCBib290KGNvbnRleHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcihlKTtcblxuICAgIHRocm93IGU7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gYm9vdChjb250ZXh0OiBFeHRlbnNpb25Db250ZXh0KSB7XG4gIGxldCBjb25maWcgPSBnZXRDb25maWcoKTtcbiAgbGV0IGlzRW5hYmxlZCA9IGNvbmZpZy5nZXQ8Ym9vbGVhbj4oJ2VuYWJsZScsIHRydWUpO1xuICBsZXQgaXNEZWJ1Z2dpbmcgPSBjb25maWcuZ2V0PGJvb2xlYW4+KCdkZWJ1ZycsIGZhbHNlKTtcblxuICBpZiAoIWlzRW5hYmxlZCkgcmV0dXJuO1xuXG4gIGxldCBpc0VtYmVyQ2xpID0gYXdhaXQgaXNFbWJlckNsaVByb2plY3QoKTtcblxuICAvLyBOb3QgcmVhbGx5IGFuIGVycm9yLCBidXQgdGhpcyBpcyBpbXBvcnRhbnQgaW5mb3JtYXRpb24gZm9yIHRoZSBmaXJzdCBwaGFzZSBvZiBkZWJ1Z2dpbmcuXG4gIGNvbnNvbGUuaW5mbygnaXNFbWJlckNsaScsIGlzRW1iZXJDbGkpO1xuXG4gIGlmICghaXNFbWJlckNsaSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGxldCBjbGllbnQgPSBhd2FpdCBzdGFydExhbmd1YWdlU2VydmVyQ2xpZW50KGNvbnRleHQsIGlzRGVidWdnaW5nKTtcblxuICBjb25zb2xlLmluZm8oJ0NvbmZpZ3VyaW5nIExhbmd1YWdlU2VydmVyQ2xpZW50Li4uJyk7XG5cbiAgY29uZmlndXJlQ2xpZW50KGNsaWVudCwgY29udGV4dCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHN0YXJ0TGFuZ3VhZ2VTZXJ2ZXJDbGllbnQoY29udGV4dDogRXh0ZW5zaW9uQ29udGV4dCwgaXNEZWJ1Z2dpbmcgPSBmYWxzZSkge1xuICBsZXQgYmluUGF0aCA9IGNvbnRleHQuYXNBYnNvbHV0ZVBhdGgocGF0aC5qb2luKC4uLmxhbmd1YWdlU2VydmVyUGF0aCwgLi4uc2VydmVyQmluKSk7XG5cbiAgY29uc29sZS5pbmZvKCdVRUxTIGJpbiBAJywgYmluUGF0aCk7XG5cbiAgbGV0IGRlYnVnT3B0aW9ucyA9IGlzRGVidWdnaW5nID8geyBleGVjQXJndjogWyctLW5vbGF6eScsICctLWluc3BlY3Q9NjAwNCddIH0gOiB7fTtcblxuICAvLyBJZiB0aGUgZXh0ZW5zaW9uIGlzIGxhdW5jaGVkIGluIGRlYnVnIG1vZGUgdGhlbiB0aGUgZGVidWdcbiAgLy8gc2VydmVyIG9wdGlvbnMgYXJlIHVzZWQuLi5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBydW4gb3B0aW9ucyBhcmUgdXNlZFxuICBsZXQgc2VydmVyT3B0aW9uczogU2VydmVyT3B0aW9ucyA9IHtcbiAgICBydW46IHtcbiAgICAgIG1vZHVsZTogYmluUGF0aCxcbiAgICAgIHRyYW5zcG9ydDogVHJhbnNwb3J0S2luZC5pcGMsXG4gICAgfSxcbiAgICBkZWJ1Zzoge1xuICAgICAgbW9kdWxlOiBiaW5QYXRoLFxuICAgICAgdHJhbnNwb3J0OiBUcmFuc3BvcnRLaW5kLmlwYyxcbiAgICAgIG9wdGlvbnM6IGRlYnVnT3B0aW9ucyxcbiAgICB9LFxuICB9O1xuXG4gIGxldCBjbGllbnRPcHRpb25zID0gYnVpbGRDbGllbnRPcHRpb25zKCk7XG5cbiAgbGV0IGNsaWVudCA9IG5ldyBMYW5ndWFnZUNsaWVudChcbiAgICAnZW1iZXItbGFuZ3VhZ2Utc2VydmVyJyxcbiAgICAnRW1iZXIgTGFuZ3VhZ2UgU2VydmVyJyxcbiAgICBzZXJ2ZXJPcHRpb25zLFxuICAgIGNsaWVudE9wdGlvbnNcbiAgKTtcblxuICBjb250ZXh0LnN1YnNjcmlwdGlvbnMucHVzaChzZXJ2aWNlcy5yZWdpc3RMYW5ndWFnZUNsaWVudChjbGllbnQpKTtcblxuICBhd2FpdCBjbGllbnQub25SZWFkeSgpO1xuXG4gIHJldHVybiBjbGllbnQ7XG59XG5cbmZ1bmN0aW9uIGNvbmZpZ3VyZUNsaWVudChjbGllbnQ6IExhbmd1YWdlQ2xpZW50LCBjb250ZXh0OiBFeHRlbnNpb25Db250ZXh0KSB7XG4gIGxldCBhZGRvbnNSZWxQYXRoID0gcGF0aC5qb2luKC4uLmFkZG9uUGF0aCk7XG4gIGxldCBhZGRvbkFic29sdXRlUGF0aCA9IGNvbnRleHQuYXNBYnNvbHV0ZVBhdGgoYWRkb25zUmVsUGF0aCk7XG5cbiAgY29uc29sZS5pbmZvKCdVRUxTIEFkZG9ucyBAJywgYWRkb25BYnNvbHV0ZVBhdGgpO1xuXG4gIGxldCBjb2NVRUxTQ29uZmlnID0gaW5zZXJ0TG9jYWxBZGRvblBhdGgoYWRkb25BYnNvbHV0ZVBhdGgpO1xuXG4gIGNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kKENPTU1BTkRTLlNFVF9DT05GSUcsIGNvY1VFTFNDb25maWcpO1xuXG4gIGxldCB7IG52aW0gfSA9IHdvcmtzcGFjZTtcblxuICBjb250ZXh0LnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICBjb21tYW5kcy5yZWdpc3RlckNvbW1hbmQoQ09NTUFORFMuR0VUX1VTRVJfSU5QVVQsIGFzeW5jIChvcHRzLCBjYWxsYmFja05hbWUsIHRhaWwpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnR2V0dGluZyB1c2VyIGlucHV0Li4uJyk7XG5cbiAgICAgICAgbGV0IG5hbWUgPSBhd2FpdCBudmltLmNhbGwoJ2lucHV0JywgWydDb21wb25lbnQgTmFtZScsICcnXSk7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRhaWwudXJpO1xuXG4gICAgICAgIGNvbnNvbGUuaW5mbyhjYWxsYmFja05hbWUsIGRvY3VtZW50LCBuYW1lLCB0YWlsKTtcblxuICAgICAgICBhd2FpdCBjb21tYW5kcy5leGVjdXRlQ29tbWFuZChjYWxsYmFja05hbWUsIGRvY3VtZW50LCBuYW1lLCB0YWlsKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgICB3aW5kb3cuc2hvd01lc3NhZ2UoZS50b1N0cmluZygpLCAnZXJyb3InKTtcbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRMb2NhbEFkZG9uUGF0aChhZGRvblBhdGg6IHN0cmluZykge1xuICBsZXQgY29uZmlnID0gZ2V0VUVMU0NvbmZpZygpO1xuXG4gIGxldCBsb2NhbCA9IGNvbmZpZy5sb2NhbCB8fCB7fTtcbiAgbGV0IGFkZG9ucyA9IGxvY2FsLmFkZG9ucyB8fCBbXTtcblxuICBsZXQgYWRkb25QYXRocyA9IHJlYWRkaXJTeW5jKHBhdGguam9pbihhZGRvblBhdGgsICdub2RlX21vZHVsZXMnKSwge1xuICAgIHdpdGhGaWxlVHlwZXM6IHRydWUsXG4gIH0pXG4gICAgLmZpbHRlcigoZGlyZW50KSA9PiBkaXJlbnQuaXNEaXJlY3RvcnkoKSlcbiAgICAubWFwKChkaXJlbnQpID0+IGRpcmVudC5uYW1lKVxuICAgIC5maWx0ZXIoKG5hbWUpID0+IG5hbWUuc3RhcnRzV2l0aCgnZWxzLScpKVxuICAgIC5tYXAoKGFkZG9uTmFtZSkgPT4gcGF0aC5qb2luKGFkZG9uUGF0aCwgJ25vZGVfbW9kdWxlcycsIGFkZG9uTmFtZSkpO1xuXG4gIGNvbnNvbGUuaW5mbyhhZGRvblBhdGhzKTtcblxuICByZXR1cm4ge1xuICAgIC4uLmNvbmZpZyxcbiAgICBsb2NhbDoge1xuICAgICAgLi4ubG9jYWwsXG4gICAgICBhZGRvbnM6IFsuLi5hZGRvbnMsIC4uLmFkZG9uUGF0aHNdLFxuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldENvbmZpZygpOiBXb3Jrc3BhY2VDb25maWd1cmF0aW9uIHtcbiAgbGV0IGNvbmZpZyA9IHdvcmtzcGFjZS5nZXRDb25maWd1cmF0aW9uKCdlbWJlcicpO1xuXG4gIHJldHVybiBjb25maWc7XG59XG5cbmZ1bmN0aW9uIGdldFVFTFNDb25maWcoKTogV29ya3NwYWNlQ29uZmlndXJhdGlvbiB7XG4gIGxldCBjb25maWcgPSB3b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbignZWxzJyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuZnVuY3Rpb24gYnVpbGRDbGllbnRPcHRpb25zKCk6IExhbmd1YWdlQ2xpZW50T3B0aW9ucyB7XG4gIHJldHVybiB7XG4gICAgZG9jdW1lbnRTZWxlY3RvcjogW1xuICAgICAgJ2hicycsXG4gICAgICAnaHRtbC5oYW5kbGViYXJzJyxcbiAgICAgICdoYW5kbGViYXJzJyxcbiAgICAgICd0eXBlc2NyaXB0JyxcbiAgICAgICdqYXZhc2NyaXB0JyxcbiAgICAgICd0eXBlc2NyaXB0LmdsaW1tZXInLFxuICAgICAgJ2phdmFzY3JpcHQuZ2xpbW1lcicsXG4gICAgXSxcbiAgICBpbml0aWFsaXphdGlvbk9wdGlvbnM6IHtcbiAgICAgIGVkaXRvcjogJ3ZzY29kZScsIC8vIGhhY2tcbiAgICB9LFxuICAgIG91dHB1dENoYW5uZWxOYW1lOiAnZW1iZXItbGFuZ3VhZ2Utc2VydmVyJyxcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaXNFbWJlckNsaVByb2plY3QoKTogUHJvbWlzZTxib29sZWFuPiB7XG4gIGxldCBlbWJlckNsaUJ1aWxkRmlsZSA9IGF3YWl0IHdvcmtzcGFjZS5maW5kVXAoJ2VtYmVyLWNsaS1idWlsZC5qcycpO1xuXG4gIHJldHVybiAhIWVtYmVyQ2xpQnVpbGRGaWxlO1xufVxuIl19